{"ast":null,"code":"import _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash as _hash, keys } from '../../util';\nimport { getMarkPropOrConfig } from '../common';\nimport { DataFlowNode } from './dataflow';\nexport var FilterInvalidNode =\n/*#__PURE__*/\nfunction (_DataFlowNode) {\n  _inherits(FilterInvalidNode, _DataFlowNode);\n\n  function FilterInvalidNode(parent, filter) {\n    var _this;\n\n    _classCallCheck(this, FilterInvalidNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterInvalidNode).call(this, parent));\n    _this.filter = filter;\n    return _this;\n  }\n\n  _createClass(FilterInvalidNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new FilterInvalidNode(null, Object.assign({}, this.filter));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(keys(this.filter));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(); // filter does not produce any new fields\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"FilterInvalid \".concat(_hash(this.filter));\n    }\n    /**\n     * Create the VgTransforms for each of the filtered fields.\n     */\n\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _this2 = this;\n\n      var filters = keys(this.filter).reduce(function (vegaFilters, field) {\n        var fieldDef = _this2.filter[field];\n        var ref = fieldRef(fieldDef, {\n          expr: 'datum'\n        });\n\n        if (fieldDef !== null) {\n          if (fieldDef.type === 'temporal') {\n            vegaFilters.push(\"(isDate(\".concat(ref, \") || (isValid(\").concat(ref, \") && isFinite(+\").concat(ref, \")))\"));\n          } else if (fieldDef.type === 'quantitative') {\n            vegaFilters.push(\"isValid(\".concat(ref, \")\"));\n            vegaFilters.push(\"isFinite(+\".concat(ref, \")\"));\n          } else {// should never get here\n          }\n        }\n\n        return vegaFilters;\n      }, []);\n      return filters.length > 0 ? {\n        type: 'filter',\n        expr: filters.join(' && ')\n      } : null;\n    }\n  }], [{\n    key: \"make\",\n    value: function make(parent, model) {\n      var config = model.config,\n          mark = model.mark,\n          markDef = model.markDef;\n      var invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n      if (invalid !== 'filter') {\n        return null;\n      }\n\n      var filter = model.reduceFieldDef(function (aggregator, fieldDef, channel) {\n        var scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n\n        if (scaleComponent) {\n          var scaleType = scaleComponent.get('type'); // While discrete domain scales can handle invalid values, continuous scales can't.\n          // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n          // (For path marks, we will use \"defined\" property and skip these values instead.)\n\n          if (hasContinuousDomain(scaleType) && !fieldDef.aggregate && !isPathMark(mark)) {\n            aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n          }\n        }\n\n        return aggregator;\n      }, {});\n\n      if (!keys(filter).length) {\n        return null;\n      }\n\n      return new FilterInvalidNode(parent, filter);\n    }\n  }]);\n\n  return FilterInvalidNode;\n}(DataFlowNode);","map":null,"metadata":{},"sourceType":"module"}