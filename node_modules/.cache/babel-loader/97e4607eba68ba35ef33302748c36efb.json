{"ast":null,"code":"import { getSizeType } from '../channel';\nimport { stringify, replaceAll } from '../util';\n/**\n * Collection of all Vega-Lite Error Messages\n */\n\nexport function invalidSpec(spec) {\n  return \"Invalid specification \".concat(JSON.stringify(spec), \". Make sure the specification includes at least one of the following properties: \\\"mark\\\", \\\"layer\\\", \\\"facet\\\", \\\"hconcat\\\", \\\"vconcat\\\", \\\"concat\\\", or \\\"repeat\\\".\");\n} // FIT\n\nexport var FIT_NON_SINGLE = 'Autosize \"fit\" only works for single views and layered views.';\nexport function containerSizeNonSingle(name) {\n  var uName = name == 'width' ? 'Width' : 'Height';\n  return \"\".concat(uName, \" \\\"container\\\" only works for single views and layered views.\");\n}\nexport function containerSizeNotCompatibleWithAutosize(name) {\n  var uName = name == 'width' ? 'Width' : 'Height';\n  return \"\".concat(uName, \" \\\"container\\\" only works well with autosize \\\"fit\\\" or \\\"fit-x\\\".\");\n}\nexport function droppingFit(channel) {\n  return channel ? \"Dropping \\\"fit-\".concat(channel, \"\\\" because spec has discrete \").concat(getSizeType(channel), \".\") : \"Dropping \\\"fit\\\" because spec has discrete size.\";\n} // SELECTION\n\nexport function cannotProjectOnChannelWithoutField(channel) {\n  return \"Cannot project a selection on encoding channel \\\"\".concat(channel, \"\\\", which has no field.\");\n}\nexport function cannotProjectAggregate(channel, aggregate) {\n  return \"Cannot project a selection on encoding channel \\\"\".concat(channel, \"\\\" as it uses an aggregate function (\\\"\").concat(aggregate, \"\\\").\");\n}\nexport function nearestNotSupportForContinuous(mark) {\n  return \"The \\\"nearest\\\" transform is not supported for \".concat(mark, \" marks.\");\n}\nexport function selectionNotSupported(mark) {\n  return \"Selection not supported for \".concat(mark, \" yet.\");\n}\nexport function selectionNotFound(name) {\n  return \"Cannot find a selection named \\\"\".concat(name, \"\\\".\");\n}\nexport var SCALE_BINDINGS_CONTINUOUS = 'Scale bindings are currently only supported for scales with unbinned, continuous domains.';\nexport var LEGEND_BINDINGS_PROJECT_LENGTH = 'Legend bindings are only supported for selections over an individual field or encoding channel.';\nexport function noSameUnitLookup(name) {\n  return \"Cannot define and lookup the \\\"\".concat(name, \"\\\" selection in the same view. \") + \"Try moving the lookup into a second, layered view?\";\n} // REPEAT\n\nexport function noSuchRepeatedValue(field) {\n  return \"Unknown repeated value \\\"\".concat(field, \"\\\".\");\n}\nexport function columnsNotSupportByRowCol(type) {\n  return \"The \\\"columns\\\" property cannot be used when \\\"\".concat(type, \"\\\" has nested row/column.\");\n} // CONCAT\n\nexport var CONCAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in concatenated views yet (https://github.com/vega/vega-lite/issues/2415).'; // REPEAT\n\nexport var REPEAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in repeated views yet (https://github.com/vega/vega-lite/issues/2415).'; // DATA\n\nexport function unrecognizedParse(p) {\n  return \"Unrecognized parse \\\"\".concat(p, \"\\\".\");\n}\nexport function differentParse(field, local, ancestor) {\n  return \"An ancestor parsed field \\\"\".concat(field, \"\\\" as \").concat(ancestor, \" but a child wants to parse the field as \").concat(local, \".\");\n} // TRANSFORMS\n\nexport function invalidTransformIgnored(transform) {\n  return \"Ignoring an invalid transform: \".concat(stringify(transform), \".\");\n}\nexport var NO_FIELDS_NEEDS_AS = 'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.'; // ENCODING & FACET\n\nexport function encodingOverridden(channels) {\n  return \"Layer's shared \".concat(channels.join(','), \" channel \").concat(channels.length === 1 ? 'is' : 'are', \" overriden.\");\n}\nexport function projectionOverridden(opt) {\n  var parentProjection = opt.parentProjection,\n      projection = opt.projection;\n  return \"Layer's shared projection \".concat(stringify(parentProjection), \" is overridden by a child projection \").concat(stringify(projection), \".\");\n}\nexport function primitiveChannelDef(channel, type, value) {\n  return \"Channel \".concat(channel, \" is a \").concat(type, \". Converted to {value: \").concat(stringify(value), \"}.\");\n}\nexport function invalidFieldType(type) {\n  return \"Invalid field type \\\"\".concat(type, \"\\\".\");\n}\nexport function nonZeroScaleUsedWithLengthMark(mark, channel, opt) {\n  var scaleText = opt.scaleType ? \"\".concat(opt.scaleType, \" scale\") : opt.zeroFalse ? 'scale with zero=false' : 'scale with custom domain that excludes zero';\n  return \"A \".concat(scaleText, \" is used to encode \").concat(mark, \"'s \").concat(channel, \". This can be misleading as the \").concat(channel === 'x' ? 'width' : 'height', \" of the \").concat(mark, \" can be arbitrary based on the scale domain. You may want to use point mark instead.\");\n}\nexport function invalidFieldTypeForCountAggregate(type, aggregate) {\n  return \"Invalid field type \\\"\".concat(type, \"\\\" for aggregate: \\\"\").concat(aggregate, \"\\\", using \\\"quantitative\\\" instead.\");\n}\nexport function invalidAggregate(aggregate) {\n  return \"Invalid aggregation operator \\\"\".concat(aggregate, \"\\\".\");\n}\nexport function missingFieldType(channel, newType) {\n  return \"Missing type for channel \\\"\".concat(channel, \"\\\", using \\\"\").concat(newType, \"\\\" instead.\");\n}\nexport function droppingColor(type, opt) {\n  var fill = opt.fill,\n      stroke = opt.stroke;\n  return \"Dropping color \".concat(type, \" as the plot also has \").concat(fill && stroke ? 'fill and stroke' : fill ? 'fill' : 'stroke', \".\");\n}\nexport function emptyFieldDef(fieldDef, channel) {\n  return \"Dropping \".concat(stringify(fieldDef), \" from channel \\\"\").concat(channel, \"\\\" since it does not contain data field or value.\");\n}\nexport function latLongDeprecated(channel, type, newChannel) {\n  return \"\".concat(channel, \"-encoding with type \").concat(type, \" is deprecated. Replacing with \").concat(newChannel, \"-encoding.\");\n}\nexport var LINE_WITH_VARYING_SIZE = 'Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.';\nexport function incompatibleChannel(channel, markOrFacet, when) {\n  return \"\".concat(channel, \" dropped as it is incompatible with \\\"\").concat(markOrFacet, \"\\\"\").concat(when ? \" when \".concat(when) : '', \".\");\n}\nexport function invalidEncodingChannel(channel) {\n  return \"\".concat(channel, \"-encoding is dropped as \").concat(channel, \" is not a valid encoding channel.\");\n}\nexport function facetChannelShouldBeDiscrete(channel) {\n  return \"\".concat(channel, \" encoding should be discrete (ordinal / nominal / binned).\");\n}\nexport function facetChannelDropped(channels) {\n  return \"Facet encoding dropped as \".concat(channels.join(' and '), \" \").concat(channels.length > 1 ? 'are' : 'is', \" also specified.\");\n}\nexport function discreteChannelCannotEncode(channel, type) {\n  return \"Using discrete channel \\\"\".concat(channel, \"\\\" to encode \\\"\").concat(type, \"\\\" field can be misleading as it does not encode \").concat(type === 'ordinal' ? 'order' : 'magnitude', \".\");\n} // Mark\n\nexport function lineWithRange(hasX2, hasY2) {\n  var channels = hasX2 && hasY2 ? 'x2 and y2' : hasX2 ? 'x2' : 'y2';\n  return \"Line mark is for continuous lines and thus cannot be used with \".concat(channels, \". We will use the rule mark (line segments) instead.\");\n}\nexport function orientOverridden(original, actual) {\n  return \"Specified orient \\\"\".concat(original, \"\\\" overridden with \\\"\").concat(actual, \"\\\".\");\n} // SCALE\n\nexport var CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'Custom domain scale cannot be unioned with default field-based domain.';\nexport var RANGE_STEP_DEPRECATED = \"Scale's \\\"rangeStep\\\" is deprecated and will be removed in Vega-Lite 5.0. Please use \\\"width\\\"/\\\"height\\\": {\\\"step\\\": ...} instead. See https://vega.github.io/vega-lite/docs/size.html.\";\nexport function cannotUseScalePropertyWithNonColor(prop) {\n  return \"Cannot use the scale property \\\"\".concat(prop, \"\\\" with non-color channel.\");\n}\nexport function unaggregateDomainHasNoEffectForRawField(fieldDef) {\n  return \"Using unaggregated domain with raw field has no effect (\".concat(stringify(fieldDef), \").\");\n}\nexport function unaggregateDomainWithNonSharedDomainOp(aggregate) {\n  return \"Unaggregated domain not applicable for \\\"\".concat(aggregate, \"\\\" since it produces values outside the origin domain of the source data.\");\n}\nexport function unaggregatedDomainWithLogScale(fieldDef) {\n  return \"Unaggregated domain is currently unsupported for log scale (\".concat(stringify(fieldDef), \").\");\n}\nexport function cannotApplySizeToNonOrientedMark(mark) {\n  return \"Cannot apply size to non-oriented mark \\\"\".concat(mark, \"\\\".\");\n}\nexport function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {\n  return \"Channel \\\"\".concat(channel, \"\\\" does not work with \\\"\").concat(scaleType, \"\\\" scale. We are using \\\"\").concat(defaultScaleType, \"\\\" scale instead.\");\n}\nexport function scaleTypeNotWorkWithFieldDef(scaleType, defaultScaleType) {\n  return \"FieldDef does not work with \\\"\".concat(scaleType, \"\\\" scale. We are using \\\"\").concat(defaultScaleType, \"\\\" scale instead.\");\n}\nexport function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {\n  return \"\".concat(channel, \"-scale's \\\"\").concat(propName, \"\\\" is dropped as it does not work with \").concat(scaleType, \" scale.\");\n}\nexport function scaleTypeNotWorkWithMark(mark, scaleType) {\n  return \"Scale type \\\"\".concat(scaleType, \"\\\" does not work with mark \\\"\").concat(mark, \"\\\".\");\n}\nexport function stepDropped(channel) {\n  return \"The step for \\\"\".concat(channel, \"\\\" is dropped because the \").concat(channel === 'width' ? 'x' : 'y', \" is continuous.\");\n}\nexport function mergeConflictingProperty(property, propertyOf, v1, v2) {\n  return \"Conflicting \".concat(propertyOf.toString(), \" property \\\"\").concat(property.toString(), \"\\\" (\").concat(stringify(v1), \" and \").concat(stringify(v2), \"). Using \").concat(stringify(v1), \".\");\n}\nexport function mergeConflictingDomainProperty(property, propertyOf, v1, v2) {\n  return \"Conflicting \".concat(propertyOf.toString(), \" property \\\"\").concat(property.toString(), \"\\\" (\").concat(stringify(v1), \" and \").concat(stringify(v2), \"). Using the union of the two domains.\");\n}\nexport function independentScaleMeansIndependentGuide(channel) {\n  return \"Setting the scale to be independent for \\\"\".concat(channel, \"\\\" means we also have to set the guide (axis or legend) to be independent.\");\n}\nexport function domainSortDropped(sort) {\n  return \"Dropping sort property \".concat(stringify(sort), \" as unioned domains only support boolean or op \\\"count\\\", \\\"min\\\", and \\\"max\\\".\");\n}\nexport var UNABLE_TO_MERGE_DOMAINS = 'Unable to merge domains.';\nexport var MORE_THAN_ONE_SORT = 'Domains that should be unioned has conflicting sort properties. Sort will be set to true.'; // AXIS\n\nexport var INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.'; // STACK\n\nexport function cannotStackRangedMark(channel) {\n  return \"Cannot stack \\\"\".concat(channel, \"\\\" if there is already \\\"\").concat(channel, \"2\\\".\");\n}\nexport function cannotStackNonLinearScale(scaleType) {\n  return \"Cannot stack non-linear scale (\".concat(scaleType, \").\");\n}\nexport function stackNonSummativeAggregate(aggregate) {\n  return \"Stacking is applied even though the aggregate function is non-summative (\\\"\".concat(aggregate, \"\\\").\");\n} // TIMEUNIT\n\nexport function invalidTimeUnit(unitName, value) {\n  return \"Invalid \".concat(unitName, \": \").concat(stringify(value), \".\");\n}\nexport function dayReplacedWithDate(fullTimeUnit) {\n  return \"Time unit \\\"\".concat(fullTimeUnit, \"\\\" is not supported. We are replacing it with \").concat(replaceAll(fullTimeUnit, 'day', 'date'), \".\");\n}\nexport function droppedDay(d) {\n  return \"Dropping day from datetime \".concat(stringify(d), \" as day cannot be combined with other units.\");\n}\nexport function errorBarCenterAndExtentAreNotNeeded(center, extent) {\n  return \"\".concat(extent ? 'extent ' : '').concat(extent && center ? 'and ' : '').concat(center ? 'center ' : '').concat(extent && center ? 'are ' : 'is ', \"not needed when data are aggregated.\");\n}\nexport function errorBarCenterIsUsedWithWrongExtent(center, extent, mark) {\n  return \"\".concat(center, \" is not usually used with \").concat(extent, \" for \").concat(mark, \".\");\n}\nexport function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {\n  return \"Continuous axis should not have customized aggregation function \".concat(aggregate, \"; \").concat(compositeMark, \" already agregates the axis.\");\n}\nexport function errorBarCenterIsNotNeeded(extent, mark) {\n  return \"Center is not needed to be specified in \".concat(mark, \" when extent is \").concat(extent, \".\");\n}\nexport function errorBand1DNotSupport(property) {\n  return \"1D error band does not support \".concat(property, \".\");\n} // CHANNEL\n\nexport function channelRequiredForBinned(channel) {\n  return \"Channel \".concat(channel, \" is required for \\\"binned\\\" bin.\");\n}\nexport function domainRequiredForThresholdScale(channel) {\n  return \"Domain for \".concat(channel, \" is required for threshold scale.\");\n}","map":null,"metadata":{},"sourceType":"module"}