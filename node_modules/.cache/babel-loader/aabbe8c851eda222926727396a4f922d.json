{"ast":null,"code":"import { entry, ref, keyFieldRef, aggrField, sortKey } from './util';\nimport { Aggregate, Collect } from './transforms';\nimport { isString } from 'vega-util';\nexport default function DataScope(scope, input, output, values, aggr) {\n  this.scope = scope; // parent scope object\n\n  this.input = input; // first operator in pipeline (tuple input)\n\n  this.output = output; // last operator in pipeline (tuple output)\n\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n  // last aggregate in transform pipeline\n\n  this.aggregate = aggr; // lookup table of field indices\n\n  this.index = {};\n}\n\nDataScope.fromEntries = function (scope, entries) {\n  var n = entries.length,\n      i = 1,\n      input = entries[0],\n      values = entries[n - 1],\n      output = entries[n - 2],\n      aggr = null;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  } // add operator entries to this scope, wire up pulse chain\n\n\n  scope.add(entries[0]);\n\n  for (; i < n; ++i) {\n    entries[i].params.pulse = ref(entries[i - 1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nvar prototype = DataScope.prototype;\n\nprototype.countsRef = function (scope, field, sort) {\n  var ds = this,\n      cache = ds.counts || (ds.counts = {}),\n      k = fieldKey(field),\n      v,\n      a,\n      p;\n\n  if (k != null) {\n    scope = ds.scope;\n    v = cache[k];\n  }\n\n  if (!v) {\n    p = {\n      groupby: scope.fieldRef(field, 'key'),\n      pulse: ref(ds.output)\n    };\n    if (sort && sort.field) addSortField(scope, p, sort);\n    a = scope.add(Aggregate(p));\n    v = scope.add(Collect({\n      pulse: ref(a)\n    }));\n    v = {\n      agg: a,\n      ref: ref(v)\n    };\n    if (k != null) cache[k] = v;\n  } else if (sort && sort.field) {\n    addSortField(scope, v.agg.params, sort);\n  }\n\n  return v.ref;\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  var as = aggrField(sort.op, sort.field),\n      s;\n\n  if (p.ops) {\n    for (var i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n\n  if (sort.op) {\n    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  var cache = ds[name] || (ds[name] = {}),\n      sort = sortKey(counts),\n      k = fieldKey(field),\n      v,\n      op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    var params = counts ? {\n      field: keyFieldRef,\n      pulse: ds.countsRef(scope, field, counts)\n    } : {\n      field: scope.fieldRef(field),\n      pulse: ref(ds.output)\n    };\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n\n  return v;\n}\n\nprototype.tuplesRef = function () {\n  return ref(this.values);\n};\n\nprototype.extentRef = function (scope, field) {\n  return cache(scope, this, 'extent', 'extent', field, false);\n};\n\nprototype.domainRef = function (scope, field) {\n  return cache(scope, this, 'domain', 'values', field, false);\n};\n\nprototype.valuesRef = function (scope, field, sort) {\n  return cache(scope, this, 'vals', 'values', field, sort || true);\n};\n\nprototype.lookupRef = function (scope, field) {\n  return cache(scope, this, 'lookup', 'tupleindex', field, false);\n};\n\nprototype.indataRef = function (scope, field) {\n  return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n};","map":null,"metadata":{},"sourceType":"module"}