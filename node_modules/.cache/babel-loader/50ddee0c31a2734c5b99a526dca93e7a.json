{"ast":null,"code":"import boundStroke from '../bound/boundStroke';\nimport context from '../bound/boundContext';\nimport pathParse from '../path/parse';\nimport pathRender from '../path/render';\nimport { intersectPath } from '../util/intersect';\nimport { drawAll } from '../util/canvas/draw';\nimport { pickPath } from '../util/canvas/pick';\nimport { transformItem } from '../util/svg/transform';\nimport { DegToRad } from '../util/constants';\n\nfunction attr(emit, item) {\n  var sx = item.scaleX || 1,\n      sy = item.scaleY || 1;\n\n  if (sx !== 1 || sy !== 1) {\n    emit('vector-effect', 'non-scaling-stroke');\n  }\n\n  emit('transform', transformItem(item));\n  emit('d', item.path);\n}\n\nfunction path(context, item) {\n  var path = item.path;\n  if (path == null) return true;\n  var x = item.x || 0,\n      y = item.y || 0,\n      sx = item.scaleX || 1,\n      sy = item.scaleY || 1,\n      a = (item.angle || 0) * DegToRad,\n      cache = item.pathCache;\n\n  if (!cache || cache.path !== path) {\n    (item.pathCache = cache = pathParse(path)).path = path;\n  }\n\n  if (a && context.rotate && context.translate) {\n    context.translate(x, y);\n    context.rotate(a);\n    pathRender(context, cache, 0, 0, sx, sy);\n    context.rotate(-a);\n    context.translate(-x, -y);\n  } else {\n    pathRender(context, cache, x, y, sx, sy);\n  }\n}\n\nfunction bound(bounds, item) {\n  path(context(bounds), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);\n\n  if (item.angle) {\n    bounds.rotate(item.angle * DegToRad, item.x || 0, item.y || 0);\n  }\n\n  return bounds;\n}\n\nexport default {\n  type: 'path',\n  tag: 'path',\n  nested: false,\n  attr: attr,\n  bound: bound,\n  draw: drawAll(path),\n  pick: pickPath(path),\n  isect: intersectPath(path)\n};","map":null,"metadata":{},"sourceType":"module"}