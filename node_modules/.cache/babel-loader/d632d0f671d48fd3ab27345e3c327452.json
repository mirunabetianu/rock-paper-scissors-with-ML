{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { max } from 'd3-array';\nimport { ingest, rederive, Transform } from 'vega-dataflow';\nimport { identity, inherits, isArray, isFunction, isNumber } from 'vega-util';\nimport contours from './util/contours';\nimport quantize from './util/quantize';\n/**\n * Generate isocontours (level sets) based on input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   specified, the levels, nice, resolve, and zero parameters are ignored.\n * @param {number} [params.levels] - The desired number of contour levels.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified levels.\n * @param {string} [params.resolve] - The method for resolving thresholds\n *   across multiple input grids. If 'independent' (the default), threshold\n *   calculation will be performed separately for each grid. If 'shared', a\n *   single set of threshold values will be used for all input grids.\n * @param {boolean} [params.zero] - Boolean flag indicating if the contour\n *   threshold values should include zero.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n * @param {boolean} [params.scale] - Optional numerical value by which to\n *   scale the output isocontour coordinates. This parameter can be useful\n *   to scale the contours to match a desired output resolution.\n * @param {string} [params.as='contour'] - The output field in which to store\n *   the generated isocontour data (default 'contour').\n */\n\nexport default function Isocontour(params) {\n  Transform.call(this, null, params);\n}\nIsocontour.Definition = {\n  \"type\": \"Isocontour\",\n  \"metadata\": {\n    \"generates\": true\n  },\n  \"params\": [{\n    \"name\": \"field\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"thresholds\",\n    \"type\": \"number\",\n    \"array\": true\n  }, {\n    \"name\": \"levels\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"nice\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }, {\n    \"name\": \"resolve\",\n    \"type\": \"enum\",\n    \"values\": [\"shared\", \"independent\"],\n    \"default\": \"independent\"\n  }, {\n    \"name\": \"zero\",\n    \"type\": \"boolean\",\n    \"default\": true\n  }, {\n    \"name\": \"smooth\",\n    \"type\": \"boolean\",\n    \"default\": true\n  }, {\n    \"name\": \"scale\",\n    \"type\": \"number\",\n    \"expr\": true\n  }, {\n    \"name\": \"translate\",\n    \"type\": \"number\",\n    \"array\": true,\n    \"expr\": true\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"null\": true,\n    \"default\": \"contour\"\n  }]\n};\nvar prototype = inherits(Isocontour, Transform);\n\nprototype.transform = function (_, pulse) {\n  if (this.value && !pulse.changed() && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      source = pulse.materialize(pulse.SOURCE).source,\n      field = _.field || identity,\n      contour = contours().smooth(_.smooth !== false),\n      tz = _.thresholds || levels(source, field, _),\n      as = _.as === null ? null : _.as || 'contour',\n      values = [];\n  source.forEach(function (t) {\n    var grid = field(t); // generate contour paths in GeoJSON format\n\n    var paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values)); // adjust contour path coordinates as needed\n\n    transformPaths(paths, grid, t, _); // ingest; copy source data properties to output\n\n    paths.forEach(function (p) {\n      values.push(rederive(t, ingest(as != null ? _defineProperty({}, as, p) : p)));\n    });\n  });\n  if (this.value) out.rem = this.value;\n  this.value = out.source = out.add = values;\n  return out;\n};\n\nfunction levels(values, f, _) {\n  var q = quantize(_.levels || 10, _.nice, _.zero !== false);\n  return _.resolve !== 'shared' ? q : q(values.map(function (t) {\n    return max(f(t).values);\n  }));\n}\n\nfunction transformPaths(paths, grid, datum, _) {\n  var s = _.scale || grid.scale,\n      t = _.translate || grid.translate;\n  if (isFunction(s)) s = s(datum, _);\n  if (isFunction(t)) t = t(datum, _);\n  if ((s === 1 || s == null) && !t) return;\n  var sx = (isNumber(s) ? s : s[0]) || 1,\n      sy = (isNumber(s) ? s : s[1]) || 1,\n      tx = t && t[0] || 0,\n      ty = t && t[1] || 0;\n  paths.forEach(transform(grid, sx, sy, tx, ty));\n}\n\nexport function transform(grid, sx, sy, tx, ty) {\n  var x1 = grid.x1 || 0,\n      y1 = grid.y1 || 0,\n      flip = sx * sy < 0;\n\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n\n  function transformRing(coordinates) {\n    if (flip) coordinates.reverse(); // maintain winding order\n\n    coordinates.forEach(transformPoint);\n  }\n\n  function transformPoint(coordinates) {\n    coordinates[0] = (coordinates[0] - x1) * sx + tx;\n    coordinates[1] = (coordinates[1] - y1) * sy + ty;\n  }\n\n  return function (geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}