{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isString, toSet } from 'vega-util';\nimport * as CHANNEL from './channel';\nimport { CHANNELS, isColorChannel } from './channel';\nimport * as log from './log';\nimport * as TYPE from './type';\nimport { TYPE_INDEX } from './type';\nimport { contains, keys } from './util';\nexport var ScaleType;\n\n(function (ScaleType) {\n  // Continuous - Quantitative\n  ScaleType.LINEAR = 'linear';\n  ScaleType.LOG = 'log';\n  ScaleType.POW = 'pow';\n  ScaleType.SQRT = 'sqrt';\n  ScaleType.SYMLOG = 'symlog'; // Continuous - Time\n\n  ScaleType.TIME = 'time';\n  ScaleType.UTC = 'utc'; // Discretizing scales\n\n  ScaleType.QUANTILE = 'quantile';\n  ScaleType.QUANTIZE = 'quantize';\n  ScaleType.THRESHOLD = 'threshold';\n  ScaleType.BIN_ORDINAL = 'bin-ordinal'; // Discrete scales\n\n  ScaleType.ORDINAL = 'ordinal';\n  ScaleType.POINT = 'point';\n  ScaleType.BAND = 'band';\n})(ScaleType || (ScaleType = {}));\n/**\n * Index for scale categories -- only scale of the same categories can be merged together.\n * Current implementation is trying to be conservative and avoid merging scale type that might not work together\n */\n\n\nvar SCALE_CATEGORY_INDEX = {\n  linear: 'numeric',\n  log: 'numeric',\n  pow: 'numeric',\n  sqrt: 'numeric',\n  symlog: 'numeric',\n  time: 'time',\n  utc: 'time',\n  ordinal: 'ordinal',\n  'bin-ordinal': 'bin-ordinal',\n  point: 'ordinal-position',\n  band: 'ordinal-position',\n  quantile: 'discretizing',\n  quantize: 'discretizing',\n  threshold: 'discretizing'\n};\nexport var SCALE_TYPES = keys(SCALE_CATEGORY_INDEX);\n/**\n * Whether the two given scale types can be merged together.\n */\n\nexport function scaleCompatible(scaleType1, scaleType2) {\n  var scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];\n  var scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];\n  return scaleCategory1 === scaleCategory2 || scaleCategory1 === 'ordinal-position' && scaleCategory2 === 'time' || scaleCategory2 === 'ordinal-position' && scaleCategory1 === 'time';\n}\n/**\n * Index for scale precedence -- high score = higher priority for merging.\n */\n\nvar SCALE_PRECEDENCE_INDEX = {\n  // numeric\n  linear: 0,\n  log: 1,\n  pow: 1,\n  sqrt: 1,\n  symlog: 1,\n  // time\n  time: 0,\n  utc: 0,\n  // ordinal-position -- these have higher precedence than continuous scales as they support more types of data\n  point: 10,\n  band: 11,\n  // non grouped types\n  ordinal: 0,\n  'bin-ordinal': 0,\n  quantile: 0,\n  quantize: 0,\n  threshold: 0\n};\n/**\n * Return scale categories -- only scale of the same categories can be merged together.\n */\n\nexport function scaleTypePrecedence(scaleType) {\n  return SCALE_PRECEDENCE_INDEX[scaleType];\n}\nexport var CONTINUOUS_TO_CONTINUOUS_SCALES = ['linear', 'log', 'pow', 'sqrt', 'symlog', 'time', 'utc'];\nvar CONTINUOUS_TO_CONTINUOUS_INDEX = toSet(CONTINUOUS_TO_CONTINUOUS_SCALES);\nexport var QUANTITATIVE_SCALES = ['linear', 'log', 'pow', 'sqrt', 'symlog'];\nexport var CONTINUOUS_TO_DISCRETE_SCALES = ['quantile', 'quantize', 'threshold'];\nvar CONTINUOUS_TO_DISCRETE_INDEX = toSet(CONTINUOUS_TO_DISCRETE_SCALES);\nexport var CONTINUOUS_DOMAIN_SCALES = CONTINUOUS_TO_CONTINUOUS_SCALES.concat(['quantile', 'quantize', 'threshold']);\nvar CONTINUOUS_DOMAIN_INDEX = toSet(CONTINUOUS_DOMAIN_SCALES);\nexport var DISCRETE_DOMAIN_SCALES = ['ordinal', 'bin-ordinal', 'point', 'band'];\nvar DISCRETE_DOMAIN_INDEX = toSet(DISCRETE_DOMAIN_SCALES);\nexport var TIME_SCALE_TYPES = ['time', 'utc'];\nexport function hasDiscreteDomain(type) {\n  return type in DISCRETE_DOMAIN_INDEX;\n}\nexport function hasContinuousDomain(type) {\n  return type in CONTINUOUS_DOMAIN_INDEX;\n}\nexport function isContinuousToContinuous(type) {\n  return type in CONTINUOUS_TO_CONTINUOUS_INDEX;\n}\nexport function isContinuousToDiscrete(type) {\n  return type in CONTINUOUS_TO_DISCRETE_INDEX;\n}\nexport var defaultScaleConfig = {\n  pointPadding: 0.5,\n  barBandPaddingInner: 0.1,\n  rectBandPaddingInner: 0,\n  minBandSize: 2,\n  minFontSize: 8,\n  maxFontSize: 40,\n  minOpacity: 0.3,\n  maxOpacity: 0.8,\n  // FIXME: revise if these *can* become ratios of width/height step\n  minSize: 9,\n  minStrokeWidth: 1,\n  maxStrokeWidth: 4,\n  quantileCount: 4,\n  quantizeCount: 4\n};\nexport function isExtendedScheme(scheme) {\n  return !isString(scheme) && !!scheme['name'];\n}\nexport function isSelectionDomain(domain) {\n  var _a;\n\n  return (_a = domain) === null || _a === void 0 ? void 0 : _a['selection'];\n}\nvar SCALE_PROPERTY_INDEX = {\n  type: 1,\n  domain: 1,\n  align: 1,\n  range: 1,\n  scheme: 1,\n  bins: 1,\n  // Other properties\n  reverse: 1,\n  round: 1,\n  // quantitative / time\n  clamp: 1,\n  nice: 1,\n  // quantitative\n  base: 1,\n  exponent: 1,\n  constant: 1,\n  interpolate: 1,\n  zero: 1,\n  // band/point\n  padding: 1,\n  paddingInner: 1,\n  paddingOuter: 1\n};\nexport var SCALE_PROPERTIES = keys(SCALE_PROPERTY_INDEX);\n\nvar type = SCALE_PROPERTY_INDEX.type,\n    domain = SCALE_PROPERTY_INDEX.domain,\n    range = SCALE_PROPERTY_INDEX.range,\n    scheme = SCALE_PROPERTY_INDEX.scheme,\n    NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX = __rest(SCALE_PROPERTY_INDEX, [\"type\", \"domain\", \"range\", \"scheme\"]);\n\nexport var NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);\nexport var SCALE_TYPE_INDEX = generateScaleTypeIndex();\nexport function scaleTypeSupportProperty(scaleType, propName) {\n  switch (propName) {\n    case 'type':\n    case 'domain':\n    case 'reverse':\n    case 'range':\n      return true;\n\n    case 'scheme':\n    case 'interpolate':\n      return !contains(['point', 'band', 'identity'], scaleType);\n\n    case 'bins':\n      return !contains(['point', 'band', 'identity', 'ordinal'], scaleType);\n\n    case 'round':\n      return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n\n    case 'padding':\n      return isContinuousToContinuous(scaleType) || contains(['point', 'band'], scaleType);\n\n    case 'paddingOuter':\n    case 'align':\n      return contains(['point', 'band'], scaleType);\n\n    case 'paddingInner':\n      return scaleType === 'band';\n\n    case 'clamp':\n      return isContinuousToContinuous(scaleType);\n\n    case 'nice':\n      return isContinuousToContinuous(scaleType) || scaleType === 'quantize' || scaleType === 'threshold';\n\n    case 'exponent':\n      return scaleType === 'pow';\n\n    case 'base':\n      return scaleType === 'log';\n\n    case 'constant':\n      return scaleType === 'symlog';\n\n    case 'zero':\n      return hasContinuousDomain(scaleType) && !contains(['log', 'time', 'utc', 'threshold', 'quantile' // quantile depends on distribution so zero does not matter\n      ], scaleType);\n  }\n}\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\n\nexport function channelScalePropertyIncompatability(channel, propName) {\n  switch (propName) {\n    case 'interpolate':\n    case 'scheme':\n      if (!isColorChannel(channel)) {\n        return log.message.cannotUseScalePropertyWithNonColor(channel);\n      }\n\n      return undefined;\n\n    case 'align':\n    case 'type':\n    case 'bins':\n    case 'domain':\n    case 'range':\n    case 'base':\n    case 'exponent':\n    case 'constant':\n    case 'nice':\n    case 'padding':\n    case 'paddingInner':\n    case 'paddingOuter':\n    case 'reverse':\n    case 'round':\n    case 'clamp':\n    case 'zero':\n      return undefined;\n    // GOOD!\n  }\n}\nexport function scaleTypeSupportDataType(specifiedType, fieldDefType) {\n  if (contains([TYPE.ORDINAL, TYPE.NOMINAL], fieldDefType)) {\n    return specifiedType === undefined || hasDiscreteDomain(specifiedType);\n  } else if (fieldDefType === TYPE.TEMPORAL) {\n    return contains([ScaleType.TIME, ScaleType.UTC, undefined], specifiedType);\n  } else if (fieldDefType === TYPE.QUANTITATIVE) {\n    return contains([ScaleType.LOG, ScaleType.POW, ScaleType.SQRT, ScaleType.SYMLOG, ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD, ScaleType.LINEAR, undefined], specifiedType);\n  }\n\n  return true;\n}\nexport function channelSupportScaleType(channel, scaleType) {\n  switch (channel) {\n    case CHANNEL.X:\n    case CHANNEL.Y:\n      return isContinuousToContinuous(scaleType) || contains(['band', 'point'], scaleType);\n\n    case CHANNEL.SIZE: // TODO: size and opacity can support ordinal with more modification\n\n    case CHANNEL.STROKEWIDTH:\n    case CHANNEL.OPACITY:\n    case CHANNEL.FILLOPACITY:\n    case CHANNEL.STROKEOPACITY:\n      // Although it generally doesn't make sense to use band with size and opacity,\n      // it can also work since we use band: 0.5 to get midpoint.\n      return isContinuousToContinuous(scaleType) || isContinuousToDiscrete(scaleType) || contains(['band', 'point'], scaleType);\n\n    case CHANNEL.COLOR:\n    case CHANNEL.FILL:\n    case CHANNEL.STROKE:\n      return scaleType !== 'band';\n    // band does not make sense with color\n\n    case CHANNEL.SHAPE:\n      return scaleType === 'ordinal';\n    // shape = lookup only\n  }\n  /* istanbul ignore next: it should never reach here */\n\n\n  return false;\n}\nexport function getSupportedScaleType(channel, fieldDefType) {\n  return SCALE_TYPE_INDEX[generateScaleTypeIndexKey(channel, fieldDefType)];\n} // generates ScaleTypeIndex where keys are encoding channels and values are list of valid ScaleTypes\n\nfunction generateScaleTypeIndex() {\n  var _a;\n\n  var index = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = CHANNELS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var channel = _step.value;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = keys(TYPE_INDEX)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var fieldDefType = _step2.value;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = SCALE_TYPES[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var scaleType = _step3.value;\n              var key = generateScaleTypeIndexKey(channel, fieldDefType);\n\n              if (channelSupportScaleType(channel, scaleType) && scaleTypeSupportDataType(scaleType, fieldDefType)) {\n                index[key] = (_a = index[key], _a !== null && _a !== void 0 ? _a : []);\n                index[key].push(scaleType);\n              }\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return index;\n}\n\nfunction generateScaleTypeIndexKey(channel, fieldDefType) {\n  return channel + '_' + fieldDefType;\n}","map":null,"metadata":{},"sourceType":"module"}