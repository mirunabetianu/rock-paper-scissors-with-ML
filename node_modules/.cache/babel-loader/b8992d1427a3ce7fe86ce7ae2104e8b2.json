{"ast":null,"code":"import { SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { hasConditionalFieldDef, isFieldDef } from '../../channeldef';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      ignoreRange = _ref.ignoreRange;\n\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var prop = _step.value;\n      parseScaleProperty(model, prop);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\nexport function parseScaleCore(model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n/**\n * Parse scales for all channels of a model.\n */\n\nfunction parseUnitScaleCore(model) {\n  var encoding = model.encoding,\n      mark = model.mark;\n  return SCALE_CHANNELS.reduce(function (scaleComponents, channel) {\n    var fieldDef;\n    var specifiedScale;\n    var channelDef = encoding[channel]; // Don't generate scale for shape of geoshape\n\n    if (isFieldDef(channelDef) && mark === GEOSHAPE && channel === SHAPE && channelDef.type === GEOJSON) {\n      return scaleComponents;\n    }\n\n    if (isFieldDef(channelDef)) {\n      fieldDef = channelDef;\n      specifiedScale = channelDef.scale;\n    } else if (hasConditionalFieldDef(channelDef)) {\n      // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n      fieldDef = channelDef.condition;\n      specifiedScale = channelDef.condition['scale']; // We use ['scale'] since we know that channel here has scale for sure\n    }\n\n    if (fieldDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale = specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : {};\n      var sType = scaleType(specifiedScale, channel, fieldDef, mark);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(channel + '', true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n\n    return scaleComponents;\n  }, {});\n}\n\nvar scaleTypeTieBreaker = tieBreakByComparing(function (st1, st2) {\n  return scaleTypePrecedence(st1) - scaleTypePrecedence(st2);\n});\n\nfunction parseNonUnitScaleCore(model) {\n  var scaleComponents = model.component.scales = {};\n  var scaleTypeWithExplicitIndex = {};\n  var resolve = model.component.resolve; // Parse each child scale and determine if a particular channel can be merged.\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var child = _step2.value;\n      parseScaleCore(child); // Instead of always merging right away -- check if it is compatible to merge first!\n\n      keys(child.component.scales).forEach(function (channel) {\n        var _a; // if resolve is undefined, set default first\n\n\n        resolve.scale[channel] = (_a = resolve.scale[channel], _a !== null && _a !== void 0 ? _a : defaultScaleResolve(channel, model));\n\n        if (resolve.scale[channel] === 'shared') {\n          var explicitScaleType = scaleTypeWithExplicitIndex[channel];\n          var childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n          if (explicitScaleType) {\n            if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n              // merge scale component if type are compatible\n              scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n            } else {\n              // Otherwise, update conflicting channel to be independent\n              resolve.scale[channel] = 'independent'; // Remove from the index so they don't get merged\n\n              delete scaleTypeWithExplicitIndex[channel];\n            }\n          } else {\n            scaleTypeWithExplicitIndex[channel] = childScaleType;\n          }\n        }\n      });\n    };\n\n    for (var _iterator2 = model.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      _loop();\n    } // Merge each channel listed in the index\n\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = keys(scaleTypeWithExplicitIndex)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var channel = _step3.value;\n      // Create new merged scale component\n      var name = model.scaleName(channel, true);\n      var typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n      scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit); // rename each child and mark them as merged\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = model.children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var child = _step4.value;\n          var childScale = child.component.scales[channel];\n\n          if (childScale) {\n            child.renameScale(childScale.get('name'), name);\n            childScale.merged = true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return scaleComponents;\n}","map":null,"metadata":{},"sourceType":"module"}