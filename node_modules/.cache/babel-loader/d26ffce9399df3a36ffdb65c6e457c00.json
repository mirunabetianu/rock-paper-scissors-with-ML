{"ast":null,"code":"import axisConfig from './guides/axis-config';\nimport axisDomain from './guides/axis-domain';\nimport axisGrid from './guides/axis-grid';\nimport axisTicks from './guides/axis-ticks';\nimport axisLabels from './guides/axis-labels';\nimport axisTitle from './guides/axis-title';\nimport guideGroup from './guides/guide-group';\nimport { lookup, tickBand } from './guides/guide-util';\nimport { AxisRole } from './marks/roles';\nimport parseMark from './mark';\nimport { encoder, extendEncode } from './encode/encode-util';\nimport { Skip } from './guides/constants';\nimport { ref, value } from '../util';\nimport { Collect, AxisTicks } from '../transforms';\nexport default function (spec, scope) {\n  var config = axisConfig(spec, scope),\n      encode = spec.encode || {},\n      axisEncode = encode.axis || {},\n      name = axisEncode.name || undefined,\n      interactive = axisEncode.interactive,\n      style = axisEncode.style,\n      _ = lookup(spec, config),\n      band = tickBand(_),\n      datum,\n      dataRef,\n      ticksRef,\n      size,\n      group,\n      children; // single-element data source for axis group\n\n\n  datum = {\n    orient: spec.orient,\n    ticks: !!_('ticks'),\n    labels: !!_('labels'),\n    grid: !!_('grid'),\n    domain: !!_('domain'),\n    title: spec.title != null,\n    translate: _('translate')\n  };\n  dataRef = ref(scope.add(Collect({}, [datum]))); // encoding properties for axis group item\n\n  axisEncode = extendEncode({\n    update: {\n      offset: encoder(_('offset') || 0),\n      position: encoder(value(spec.position, 0)),\n      titlePadding: encoder(_('titlePadding')),\n      minExtent: encoder(_('minExtent')),\n      maxExtent: encoder(_('maxExtent')),\n      range: {\n        signal: \"abs(span(range(\\\"\".concat(spec.scale, \"\\\")))\")\n      }\n    }\n  }, encode.axis, Skip); // data source for axis ticks\n\n  ticksRef = ref(scope.add(AxisTicks({\n    scale: scope.scaleRef(spec.scale),\n    extra: scope.property(band.extra),\n    count: scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // generate axis marks\n\n  children = []; // include axis gridlines if requested\n\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  } // include axis ticks if requested\n\n\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  } // include axis labels if requested\n\n\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  } // include axis domain path if requested\n\n\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  } // include axis title if defined\n\n\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  } // build axis specification\n\n\n  group = guideGroup(AxisRole, style, name, dataRef, interactive, axisEncode, children);\n  if (spec.zindex) group.zindex = spec.zindex; // parse axis specification\n\n  return parseMark(group, scope);\n}","map":null,"metadata":{},"sourceType":"module"}