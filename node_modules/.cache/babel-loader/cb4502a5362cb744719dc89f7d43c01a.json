{"ast":null,"code":"import { Group } from './constants';\nimport { Transform } from 'vega-dataflow';\nimport { Item, GroupItem } from 'vega-scenegraph';\nimport { inherits } from 'vega-util';\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\n\nexport default function Mark(params) {\n  Transform.call(this, null, params);\n}\nvar prototype = inherits(Mark, Transform);\n\nprototype.transform = function (_, pulse) {\n  var mark = this.value; // acquire mark on first invocation, bind context and group\n\n  if (!mark) {\n    mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n    mark.group.context = _.context;\n    if (!_.context.group) _.context.group = mark.group;\n    mark.source = this.source; // point to upstream collector\n\n    mark.clip = _.clip;\n    mark.interactive = _.interactive;\n    this.value = mark;\n  } // initialize entering items\n\n\n  var Init = mark.marktype === Group ? GroupItem : Item;\n  pulse.visit(pulse.ADD, function (item) {\n    Init.call(item, mark);\n  }); // update clipping and/or interactive status\n\n  if (_.modified('clip') || _.modified('interactive')) {\n    mark.clip = _.clip;\n    mark.interactive = !!_.interactive;\n    mark.zdirty = true; // force scenegraph re-eval\n\n    pulse.reflow();\n  } // bind items array to scenegraph mark\n\n\n  mark.items = pulse.source;\n  return pulse;\n};\n\nfunction lookup(_) {\n  var g = _.groups,\n      p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;\n}","map":null,"metadata":{},"sourceType":"module"}