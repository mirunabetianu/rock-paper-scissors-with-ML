{"ast":null,"code":"import { Top, Bottom } from './constants';\nimport { Transform } from 'vega-dataflow';\nimport { Bounds } from 'vega-scenegraph';\nimport { inherits, peek } from 'vega-util';\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\n\nexport default function Overlap(params) {\n  Transform.call(this, null, params);\n}\nvar prototype = inherits(Overlap, Transform);\nvar methods = {\n  parity: function parity(items) {\n    return items.filter(function (item, i) {\n      return i % 2 ? item.opacity = 0 : 1;\n    });\n  },\n  greedy: function greedy(items, sep) {\n    var a;\n    return items.filter(function (b, i) {\n      if (!i || !intersect(a.bounds, b.bounds, sep)) {\n        a = b;\n        return 1;\n      } else {\n        return b.opacity = 0;\n      }\n    });\n  }\n}; // compute bounding box intersection\n// including padding pixels of separation\n\nfunction intersect(a, b, sep) {\n  return sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n}\n\nfunction hasOverlap(items, pad) {\n  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n}\n\nfunction hasBounds(item) {\n  var b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n}\n\nfunction boundTest(scale, orient, tolerance) {\n  var range = scale.range(),\n      b = new Bounds();\n\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n\n  b.expand(tolerance || 1);\n  return function (item) {\n    return b.encloses(item.bounds);\n  };\n} // reset all items to be fully opaque\n\n\nfunction reset(source) {\n  source.forEach(function (item) {\n    return item.opacity = 1;\n  });\n  return source;\n} // add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\n\n\nfunction reflow(pulse, _) {\n  return pulse.reflow(_.modified()).modifies('opacity');\n}\n\nprototype.transform = function (_, pulse) {\n  var reduce = methods[_.method] || methods.parity,\n      source = pulse.materialize(pulse.SOURCE).source,\n      sep = _.separation || 0,\n      items,\n      test,\n      bounds;\n  if (!source || !source.length) return;\n\n  if (!_.method) {\n    // early exit if method is falsy\n    if (_.modified('method')) {\n      reset(source);\n      pulse = reflow(pulse, _);\n    }\n\n    return pulse;\n  }\n\n  if (_.sort) {\n    source = source.slice().sort(_.sort);\n  } // skip labels with no content\n\n\n  source = source.filter(hasBounds);\n  items = reset(source);\n  pulse = reflow(pulse, _);\n\n  if (items.length >= 3 && hasOverlap(items, sep)) {\n    do {\n      items = reduce(items, sep);\n    } while (items.length >= 3 && hasOverlap(items, sep));\n\n    if (items.length < 3 && !peek(source).opacity) {\n      if (items.length > 1) peek(items).opacity = 0;\n      peek(source).opacity = 1;\n    }\n  }\n\n  if (_.boundScale && _.boundTolerance >= 0) {\n    test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n    source.forEach(function (item) {\n      if (!test(item)) item.opacity = 0;\n    });\n  } // re-calculate mark bounds\n\n\n  bounds = items[0].mark.bounds.clear();\n  source.forEach(function (item) {\n    if (item.opacity) bounds.union(item.bounds);\n  });\n  return pulse;\n};","map":null,"metadata":{},"sourceType":"module"}