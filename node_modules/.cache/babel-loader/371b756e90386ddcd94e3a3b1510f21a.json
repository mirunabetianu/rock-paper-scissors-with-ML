{"ast":null,"code":"import _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { __rest } from \"tslib\";\nimport { isObject } from 'vega-util';\nimport { isMarkDef } from '../mark';\nimport { isUnitSpec } from '../spec/unit';\nimport { stack } from '../stack';\nimport { keys, omit, pick } from '../util';\n\nfunction dropLineAndPoint(markDef) {\n  var _point = markDef.point,\n      _line = markDef.line,\n      mark = __rest(markDef, [\"point\", \"line\"]);\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction dropLineAndPointFromConfig(config) {\n  for (var _i = 0, _arr = ['line', 'area', 'rule', 'trail']; _i < _arr.length; _i++) {\n    var mark = _arr[_i];\n\n    if (config[mark]) {\n      config = Object.assign(Object.assign({}, config), _defineProperty({}, mark, omit(config[mark], ['point', 'line'])));\n    }\n  }\n\n  return config;\n}\n\nfunction getPointOverlay(markDef) {\n  var markConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var encoding = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (markDef.point === 'transparent') {\n    return {\n      opacity: 0\n    };\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    } // markDef.point is defined as falsy\n\n\n    return undefined;\n  }\n}\n\nfunction getLineOverlay(markDef) {\n  var markConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    } // markDef.point is defined as falsy\n\n\n    return undefined;\n  }\n}\n\nexport var PathOverlayNormalizer =\n/*#__PURE__*/\nfunction () {\n  function PathOverlayNormalizer() {\n    _classCallCheck(this, PathOverlayNormalizer);\n\n    this.name = 'path-overlay';\n  }\n\n  _createClass(PathOverlayNormalizer, [{\n    key: \"hasMatchingType\",\n    value: function hasMatchingType(spec, config) {\n      if (isUnitSpec(spec)) {\n        var mark = spec.mark,\n            encoding = spec.encoding;\n        var markDef = isMarkDef(mark) ? mark : {\n          type: mark\n        };\n\n        switch (markDef.type) {\n          case 'line':\n          case 'rule':\n          case 'trail':\n            return !!getPointOverlay(markDef, config[markDef.type], encoding);\n\n          case 'area':\n            return (// false / null are also included as we want to remove the properties\n              !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])\n            );\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"run\",\n    value: function run(spec, params, normalize) {\n      var config = params.config;\n\n      var selection = spec.selection,\n          projection = spec.projection,\n          encoding = spec.encoding,\n          mark = spec.mark,\n          outerSpec = __rest(spec, [\"selection\", \"projection\", \"encoding\", \"mark\"]);\n\n      var markDef = isMarkDef(mark) ? mark : {\n        type: mark\n      };\n      var pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n      var lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n      var layer = [Object.assign(Object.assign({}, selection ? {\n        selection: selection\n      } : {}), {\n        // Do not include point / line overlay in the normalize spec\n        mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef), markDef.type === 'area' ? {\n          opacity: 0.7\n        } : {})),\n        // drop shape from encoding as this might be used to trigger point overlay\n        encoding: omit(encoding, ['shape'])\n      })]; // FIXME: determine rules for applying selections.\n      // Need to copy stack config to overlayed layer\n\n      var stackProps = stack(markDef, encoding);\n      var overlayEncoding = encoding;\n\n      if (stackProps) {\n        var stackFieldChannel = stackProps.fieldChannel,\n            offset = stackProps.offset;\n        overlayEncoding = Object.assign(Object.assign({}, encoding), _defineProperty({}, stackFieldChannel, Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset ? {\n          stack: offset\n        } : {})));\n      }\n\n      if (lineOverlay) {\n        layer.push(Object.assign(Object.assign({}, projection ? {\n          projection: projection\n        } : {}), {\n          mark: Object.assign(Object.assign({\n            type: 'line'\n          }, pick(markDef, ['clip', 'interpolate', 'tension', 'tooltip'])), lineOverlay),\n          encoding: overlayEncoding\n        }));\n      }\n\n      if (pointOverlay) {\n        layer.push(Object.assign(Object.assign({}, projection ? {\n          projection: projection\n        } : {}), {\n          mark: Object.assign(Object.assign({\n            type: 'point',\n            opacity: 1,\n            filled: true\n          }, pick(markDef, ['clip', 'tooltip'])), pointOverlay),\n          encoding: overlayEncoding\n        }));\n      }\n\n      return normalize(Object.assign(Object.assign({}, outerSpec), {\n        layer: layer\n      }), Object.assign(Object.assign({}, params), {\n        config: dropLineAndPointFromConfig(config)\n      }));\n    }\n  }]);\n\n  return PathOverlayNormalizer;\n}();","map":null,"metadata":{},"sourceType":"module"}