{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { __rest } from \"tslib\";\nimport { isContinuous, isFieldDef, title } from '../channeldef';\nimport { extractTransformsFromEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { keys, replaceAll, titlecase } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, getCompositeMarkTooltip, makeCompositeAggregatePartFactory } from './common';\nexport var ERRORBAR = 'errorbar';\nvar ERRORBAR_PART_INDEX = {\n  ticks: 1,\n  rule: 1\n};\nexport var ERRORBAR_PARTS = keys(ERRORBAR_PART_INDEX);\nexport var errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);\nexport function normalizeErrorBar(spec, _ref) {\n  var config = _ref.config;\n\n  var _errorBarParams = errorBarParams(spec, ERRORBAR, config),\n      transform = _errorBarParams.transform,\n      continuousAxisChannelDef = _errorBarParams.continuousAxisChannelDef,\n      continuousAxis = _errorBarParams.continuousAxis,\n      encodingWithoutContinuousAxis = _errorBarParams.encodingWithoutContinuousAxis,\n      ticksOrient = _errorBarParams.ticksOrient,\n      markDef = _errorBarParams.markDef,\n      outerSpec = _errorBarParams.outerSpec,\n      tooltipEncoding = _errorBarParams.tooltipEncoding;\n\n  var makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);\n  var tick = {\n    type: 'tick',\n    orient: ticksOrient\n  };\n  return Object.assign(Object.assign({}, outerSpec), {\n    transform: transform,\n    layer: [].concat(_toConsumableArray(makeErrorBarPart({\n      partName: 'ticks',\n      mark: tick,\n      positionPrefix: 'lower',\n      extraEncoding: tooltipEncoding\n    })), _toConsumableArray(makeErrorBarPart({\n      partName: 'ticks',\n      mark: tick,\n      positionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    })), _toConsumableArray(makeErrorBarPart({\n      partName: 'rule',\n      mark: 'rule',\n      positionPrefix: 'lower',\n      endPositionPrefix: 'upper',\n      extraEncoding: tooltipEncoding\n    })))\n  });\n}\n\nfunction errorBarOrientAndInputType(spec, compositeMark) {\n  var encoding = spec.encoding;\n\n  if (errorBarIsInputTypeRaw(encoding)) {\n    return {\n      orient: compositeMarkOrient(spec, compositeMark),\n      inputType: 'raw'\n    };\n  }\n\n  var isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);\n  var isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);\n  var x = encoding.x;\n  var y = encoding.y;\n\n  if (isTypeAggregatedUpperLower) {\n    // type is aggregated-upper-lower\n    if (isTypeAggregatedError) {\n      throw new Error(compositeMark + ' cannot be both type aggregated-upper-lower and aggregated-error');\n    }\n\n    var x2 = encoding.x2;\n    var y2 = encoding.y2;\n\n    if (isFieldDef(x2) && isFieldDef(y2)) {\n      // having both x, x2 and y, y2\n      throw new Error(compositeMark + ' cannot have both x2 and y2');\n    } else if (isFieldDef(x2)) {\n      if (isFieldDef(x) && isContinuous(x)) {\n        // having x, x2 quantitative and field y, y2 are not specified\n        return {\n          orient: 'horizontal',\n          inputType: 'aggregated-upper-lower'\n        };\n      } else {\n        // having x, x2 that are not both quantitative\n        throw new Error('Both x and x2 have to be quantitative in ' + compositeMark);\n      }\n    } else if (isFieldDef(y2)) {\n      // y2 is a FieldDef\n      if (isFieldDef(y) && isContinuous(y)) {\n        // having y, y2 quantitative and field x, x2 are not specified\n        return {\n          orient: 'vertical',\n          inputType: 'aggregated-upper-lower'\n        };\n      } else {\n        // having y, y2 that are not both quantitative\n        throw new Error('Both y and y2 have to be quantitative in ' + compositeMark);\n      }\n    }\n\n    throw new Error('No ranged axis');\n  } else {\n    // type is aggregated-error\n    var xError = encoding.xError;\n    var xError2 = encoding.xError2;\n    var yError = encoding.yError;\n    var yError2 = encoding.yError2;\n\n    if (isFieldDef(xError2) && !isFieldDef(xError)) {\n      // having xError2 without xError\n      throw new Error(compositeMark + ' cannot have xError2 without xError');\n    }\n\n    if (isFieldDef(yError2) && !isFieldDef(yError)) {\n      // having yError2 without yError\n      throw new Error(compositeMark + ' cannot have yError2 without yError');\n    }\n\n    if (isFieldDef(xError) && isFieldDef(yError)) {\n      // having both xError and yError\n      throw new Error(compositeMark + ' cannot have both xError and yError with both are quantiative');\n    } else if (isFieldDef(xError)) {\n      if (isFieldDef(x) && isContinuous(x)) {\n        // having x and xError that are all quantitative\n        return {\n          orient: 'horizontal',\n          inputType: 'aggregated-error'\n        };\n      } else {\n        // having x, xError, and xError2 that are not all quantitative\n        throw new Error('All x, xError, and xError2 (if exist) have to be quantitative');\n      }\n    } else if (isFieldDef(yError)) {\n      if (isFieldDef(y) && isContinuous(y)) {\n        // having y and yError that are all quantitative\n        return {\n          orient: 'vertical',\n          inputType: 'aggregated-error'\n        };\n      } else {\n        // having y, yError, and yError2 that are not all quantitative\n        throw new Error('All y, yError, and yError2 (if exist) have to be quantitative');\n      }\n    }\n\n    throw new Error('No ranged axis');\n  }\n}\n\nfunction errorBarIsInputTypeRaw(encoding) {\n  return (isFieldDef(encoding.x) || isFieldDef(encoding.y)) && !isFieldDef(encoding.x2) && !isFieldDef(encoding.y2) && !isFieldDef(encoding.xError) && !isFieldDef(encoding.xError2) && !isFieldDef(encoding.yError) && !isFieldDef(encoding.yError2);\n}\n\nfunction errorBarIsInputTypeAggregatedUpperLower(encoding) {\n  return isFieldDef(encoding.x2) || isFieldDef(encoding.y2);\n}\n\nfunction errorBarIsInputTypeAggregatedError(encoding) {\n  return isFieldDef(encoding.xError) || isFieldDef(encoding.xError2) || isFieldDef(encoding.yError) || isFieldDef(encoding.yError2);\n}\n\nexport function errorBarParams(spec, compositeMark, config) {\n  var _a; // TODO: use selection\n\n\n  var mark = spec.mark,\n      encoding = spec.encoding,\n      selection = spec.selection,\n      _p = spec.projection,\n      outerSpec = __rest(spec, [\"mark\", \"encoding\", \"selection\", \"projection\"]);\n\n  var markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  }; // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n\n  if (selection) {\n    log.warn(log.message.selectionNotSupported(compositeMark));\n  }\n\n  var _errorBarOrientAndInp = errorBarOrientAndInputType(spec, compositeMark),\n      orient = _errorBarOrientAndInp.orient,\n      inputType = _errorBarOrientAndInp.inputType;\n\n  var _compositeMarkContinu = compositeMarkContinuousAxis(spec, orient, compositeMark),\n      continuousAxisChannelDef = _compositeMarkContinu.continuousAxisChannelDef,\n      continuousAxisChannelDef2 = _compositeMarkContinu.continuousAxisChannelDef2,\n      continuousAxisChannelDefError = _compositeMarkContinu.continuousAxisChannelDefError,\n      continuousAxisChannelDefError2 = _compositeMarkContinu.continuousAxisChannelDefError2,\n      continuousAxis = _compositeMarkContinu.continuousAxis;\n\n  var _errorBarAggregationA = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config),\n      errorBarSpecificAggregate = _errorBarAggregationA.errorBarSpecificAggregate,\n      postAggregateCalculates = _errorBarAggregationA.postAggregateCalculates,\n      tooltipSummary = _errorBarAggregationA.tooltipSummary,\n      tooltipTitleWithFieldName = _errorBarAggregationA.tooltipTitleWithFieldName;\n\n  var _b = continuousAxis,\n      oldContinuousAxisChannelDef = encoding[_b],\n      _c = continuousAxis === 'x' ? 'x2' : 'y2',\n      oldContinuousAxisChannelDef2 = encoding[_c],\n      _d = continuousAxis === 'x' ? 'xError' : 'yError',\n      oldContinuousAxisChannelDefError = encoding[_d],\n      _e = continuousAxis === 'x' ? 'xError2' : 'yError2',\n      oldContinuousAxisChannelDefError2 = encoding[_e],\n      oldEncodingWithoutContinuousAxis = __rest(encoding, [typeof _b === \"symbol\" ? _b : _b + \"\", typeof _c === \"symbol\" ? _c : _c + \"\", typeof _d === \"symbol\" ? _d : _d + \"\", typeof _e === \"symbol\" ? _e : _e + \"\"]);\n\n  var _extractTransformsFro = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config),\n      bins = _extractTransformsFro.bins,\n      timeUnits = _extractTransformsFro.timeUnits,\n      oldAggregate = _extractTransformsFro.aggregate,\n      oldGroupBy = _extractTransformsFro.groupby,\n      encodingWithoutContinuousAxis = _extractTransformsFro.encoding;\n\n  var aggregate = [].concat(_toConsumableArray(oldAggregate), _toConsumableArray(errorBarSpecificAggregate));\n  var groupby = inputType !== 'raw' ? [] : oldGroupBy;\n  var tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);\n  return {\n    transform: [].concat(_toConsumableArray((_a = outerSpec.transform, _a !== null && _a !== void 0 ? _a : [])), _toConsumableArray(bins), _toConsumableArray(timeUnits), _toConsumableArray(aggregate.length === 0 ? [] : [{\n      aggregate: aggregate,\n      groupby: groupby\n    }]), _toConsumableArray(postAggregateCalculates)),\n    groupby: groupby,\n    continuousAxisChannelDef: continuousAxisChannelDef,\n    continuousAxis: continuousAxis,\n    encodingWithoutContinuousAxis: encodingWithoutContinuousAxis,\n    ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n    markDef: markDef,\n    outerSpec: outerSpec,\n    tooltipEncoding: tooltipEncoding\n  };\n}\n\nfunction errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {\n  var errorBarSpecificAggregate = [];\n  var postAggregateCalculates = [];\n  var continuousFieldName = continuousAxisChannelDef.field;\n  var tooltipSummary;\n  var tooltipTitleWithFieldName = false;\n\n  if (inputType === 'raw') {\n    var center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === 'iqr' ? 'median' : 'mean' : config.errorbar.center;\n    var extent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n\n    if (center === 'median' !== (extent === 'iqr')) {\n      log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n    }\n\n    if (extent === 'stderr' || extent === 'stdev') {\n      errorBarSpecificAggregate = [{\n        op: extent,\n        field: continuousFieldName,\n        as: 'extent_' + continuousFieldName\n      }, {\n        op: center,\n        field: continuousFieldName,\n        as: 'center_' + continuousFieldName\n      }];\n      postAggregateCalculates = [{\n        calculate: \"datum[\\\"center_\".concat(continuousFieldName, \"\\\"] + datum[\\\"extent_\").concat(continuousFieldName, \"\\\"]\"),\n        as: 'upper_' + continuousFieldName\n      }, {\n        calculate: \"datum[\\\"center_\".concat(continuousFieldName, \"\\\"] - datum[\\\"extent_\").concat(continuousFieldName, \"\\\"]\"),\n        as: 'lower_' + continuousFieldName\n      }];\n      tooltipSummary = [{\n        fieldPrefix: 'center_',\n        titlePrefix: titlecase(center)\n      }, {\n        fieldPrefix: 'upper_',\n        titlePrefix: getTitlePrefix(center, extent, '+')\n      }, {\n        fieldPrefix: 'lower_',\n        titlePrefix: getTitlePrefix(center, extent, '-')\n      }];\n      tooltipTitleWithFieldName = true;\n    } else {\n      if (markDef.center && markDef.extent) {\n        log.warn(log.message.errorBarCenterIsNotNeeded(markDef.extent, compositeMark));\n      }\n\n      var centerOp;\n      var lowerExtentOp;\n      var upperExtentOp;\n\n      if (extent === 'ci') {\n        centerOp = 'mean';\n        lowerExtentOp = 'ci0';\n        upperExtentOp = 'ci1';\n      } else {\n        centerOp = 'median';\n        lowerExtentOp = 'q1';\n        upperExtentOp = 'q3';\n      }\n\n      errorBarSpecificAggregate = [{\n        op: lowerExtentOp,\n        field: continuousFieldName,\n        as: 'lower_' + continuousFieldName\n      }, {\n        op: upperExtentOp,\n        field: continuousFieldName,\n        as: 'upper_' + continuousFieldName\n      }, {\n        op: centerOp,\n        field: continuousFieldName,\n        as: 'center_' + continuousFieldName\n      }];\n      tooltipSummary = [{\n        fieldPrefix: 'upper_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: upperExtentOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }, {\n        fieldPrefix: 'lower_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: lowerExtentOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }, {\n        fieldPrefix: 'center_',\n        titlePrefix: title({\n          field: continuousFieldName,\n          aggregate: centerOp,\n          type: 'quantitative'\n        }, config, {\n          allowDisabling: false\n        })\n      }];\n    }\n  } else {\n    if (markDef.center || markDef.extent) {\n      log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n    }\n\n    if (inputType === 'aggregated-upper-lower') {\n      tooltipSummary = [];\n      postAggregateCalculates = [{\n        calculate: \"datum[\\\"\".concat(continuousAxisChannelDef2.field, \"\\\"]\"),\n        as: 'upper_' + continuousFieldName\n      }, {\n        calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"]\"),\n        as: 'lower_' + continuousFieldName\n      }];\n    } else if (inputType === 'aggregated-error') {\n      tooltipSummary = [{\n        fieldPrefix: '',\n        titlePrefix: continuousFieldName\n      }];\n      postAggregateCalculates = [{\n        calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"] + datum[\\\"\").concat(continuousAxisChannelDefError.field, \"\\\"]\"),\n        as: 'upper_' + continuousFieldName\n      }];\n\n      if (continuousAxisChannelDefError2) {\n        postAggregateCalculates.push({\n          calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"] + datum[\\\"\").concat(continuousAxisChannelDefError2.field, \"\\\"]\"),\n          as: 'lower_' + continuousFieldName\n        });\n      } else {\n        postAggregateCalculates.push({\n          calculate: \"datum[\\\"\".concat(continuousFieldName, \"\\\"] - datum[\\\"\").concat(continuousAxisChannelDefError.field, \"\\\"]\"),\n          as: 'lower_' + continuousFieldName\n        });\n      }\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = postAggregateCalculates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var postAggregateCalculate = _step.value;\n        tooltipSummary.push({\n          fieldPrefix: postAggregateCalculate.as.substring(0, 6),\n          titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum[\"', ''), '\"]', '')\n        });\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return {\n    postAggregateCalculates: postAggregateCalculates,\n    errorBarSpecificAggregate: errorBarSpecificAggregate,\n    tooltipSummary: tooltipSummary,\n    tooltipTitleWithFieldName: tooltipTitleWithFieldName\n  };\n}\n\nfunction getTitlePrefix(center, extent, operation) {\n  return titlecase(center) + ' ' + operation + ' ' + extent;\n}","map":null,"metadata":{},"sourceType":"module"}