{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { __rest } from \"tslib\";\nimport { isObject, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, SHARED_DOMAIN_OP_INDEX, MULTIDOMAIN_SORT_OP_INDEX as UNIONDOMAIN_SORT_OP_INDEX } from '../../aggregate';\nimport { isBinning, isSelectionExtent, isBinParams } from '../../bin';\nimport { getSecondaryRangeChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBand, valueExpr, vgField } from '../../channeldef';\nimport { MAIN, RAW } from '../../data';\nimport * as log from '../../log';\nimport { hasDiscreteDomain, isSelectionDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortArray, isSortByEncoding, isSortField } from '../../sort';\nimport * as util from '../../util';\nimport { isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { sortArrayIndexField } from '../data/calculate';\nimport { FACET_SCALE_PREFIX } from '../data/optimize';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit, mergeValuesWithExplicit } from '../split';\nexport function parseScaleDomain(model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model) {\n  var localScaleComponents = model.component.scales;\n  util.keys(localScaleComponents).forEach(function (channel) {\n    var domains = parseDomainForChannel(model, channel);\n    var localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.setWithExplicit('domains', domains);\n    parseSelectionDomain(model, channel);\n\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      var facetParent = model;\n\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n\n      var resolve = facetParent.component.resolve.scale[channel];\n\n      if (resolve === 'shared') {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = domains.value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var domain = _step.value;\n\n            // Replace the scale domain with data output from a cloned subtree after the facet.\n            if (isDataRefDomain(domain)) {\n              // use data from cloned subtree (which is the same as data but with a prefix added once)\n              domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction parseNonUnitScaleDomain(model) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = model.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var child = _step2.value;\n      parseScaleDomain(child);\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var localScaleComponents = model.component.scales;\n  util.keys(localScaleComponents).forEach(function (channel) {\n    var domains;\n    var selectionExtent = null;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = model.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var child = _step3.value;\n        var childComponent = child.component.scales[channel];\n\n        if (childComponent) {\n          if (domains === undefined) {\n            domains = childComponent.getWithExplicit('domains');\n          } else {\n            domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit('domains'), 'domains', 'scale', domainsTieBreaker);\n          }\n\n          var se = childComponent.get('selectionExtent');\n\n          if (selectionExtent && se && selectionExtent.selection !== se.selection) {\n            log.warn('The same selection must be used to override scale domains in a layered view.');\n          }\n\n          selectionExtent = se;\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    localScaleComponents[channel].setWithExplicit('domains', domains);\n\n    if (selectionExtent) {\n      localScaleComponents[channel].set('selectionExtent', selectionExtent, true);\n    }\n  });\n}\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\n\n\nfunction normalizeUnaggregatedDomain(domain, fieldDef, scaleType, scaleConfig) {\n  if (domain === 'unaggregated') {\n    var _canUseUnaggregatedDo = canUseUnaggregatedDomain(fieldDef, scaleType),\n        valid = _canUseUnaggregatedDo.valid,\n        reason = _canUseUnaggregatedDo.reason;\n\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    var _canUseUnaggregatedDo2 = canUseUnaggregatedDomain(fieldDef, scaleType),\n        _valid = _canUseUnaggregatedDo2.valid;\n\n    if (_valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model, channel) {\n  var scaleType = model.getScaleComponent(channel).get('type');\n  var domain = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.fieldDef(channel), scaleType, model.config.scale);\n\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), {\n      domain: domain\n    });\n  } // If channel is either X or Y then union them with X2 & Y2 if they exist\n\n\n  if (channel === 'x' && model.channelHasField('x2')) {\n    if (model.channelHasField('x')) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'x'), parseSingleChannelDomain(scaleType, domain, model, 'x2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && model.channelHasField('y2')) {\n    if (model.channelHasField('y')) {\n      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType, domain, model, 'y'), parseSingleChannelDomain(scaleType, domain, model, 'y2'), 'domain', 'scale', domainsTieBreaker);\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal(domain, type, timeUnit) {\n  return domain.map(function (v) {\n    var data = valueExpr(v, {\n      timeUnit: timeUnit,\n      type: type\n    });\n    return {\n      signal: \"{data: \".concat(data, \"}\")\n    };\n  });\n}\n\nfunction parseSingleChannelDomain(scaleType, domain, model, channel) {\n  var fieldDef = model.fieldDef(channel);\n\n  if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) {\n    // explicit value\n    var type = fieldDef.type,\n        timeUnit = fieldDef.timeUnit;\n\n    if (type === 'temporal' || timeUnit) {\n      return makeExplicit(mapDomainToDataSignal(domain, type, timeUnit));\n    }\n\n    return makeExplicit([domain]);\n  }\n\n  var stack = model.stack;\n\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n\n    var data = model.requestDataName(MAIN);\n    return makeImplicit([{\n      data: data,\n      field: model.vgField(channel, {\n        suffix: 'start'\n      })\n    }, {\n      data: data,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  }\n\n  var sort = isScaleChannel(channel) ? domainSort(model, channel, scaleType) : undefined;\n\n  if (domain === 'unaggregated') {\n    var _data = model.requestDataName(MAIN);\n\n    var field = fieldDef.field;\n    return makeImplicit([{\n      data: _data,\n      field: vgField({\n        field: field,\n        aggregate: 'min'\n      })\n    }, {\n      data: _data,\n      field: vgField({\n        field: field,\n        aggregate: 'max'\n      })\n    }]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      } // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n\n\n      return makeImplicit([{\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n        // Use range if we added it and the scale does not support computing a range as a signal.\n        field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {\n          binSuffix: 'range'\n        } : {}),\n        // we have to use a sort object if sort = true to make the sort correct by bin start\n        sort: sort === true || !isObject(sort) ? {\n          field: model.vgField(channel, {}),\n          op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n\n        } : sort\n      }]);\n    } else {\n      // continuous scales\n      var bin = fieldDef.bin;\n\n      if (isBinning(bin)) {\n        var binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([new SignalRefWrapper(function () {\n          var signal = model.getSignalName(binSignal);\n          return \"[\".concat(signal, \".start, \").concat(signal, \".stop]\");\n        })]);\n      } else {\n        return makeImplicit([{\n          data: model.requestDataName(MAIN),\n          field: model.vgField(channel, {})\n        }]);\n      }\n    }\n  } else if (fieldDef.timeUnit && util.contains(['time', 'utc'], scaleType) && hasBand(channel, fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined, model.markDef, model.config)) {\n    var _data2 = model.requestDataName(MAIN);\n\n    return makeImplicit([{\n      data: _data2,\n      field: model.vgField(channel)\n    }, {\n      data: _data2,\n      field: model.vgField(channel, {\n        suffix: 'end'\n      })\n    }]);\n  } else if (sort) {\n    return makeImplicit([{\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n      field: model.vgField(channel),\n      sort: sort\n    }]);\n  } else {\n    return makeImplicit([{\n      data: model.requestDataName(MAIN),\n      field: model.vgField(channel)\n    }]);\n  }\n}\n\nfunction normalizeSortField(sort, isStacked) {\n  var op = sort.op,\n      field = sort.field,\n      order = sort.order;\n  return Object.assign(Object.assign({\n    // Apply default op\n    op: op !== null && op !== void 0 ? op : isStacked ? 'sum' : DEFAULT_SORT_OP\n  }, field ? {\n    field: util.replacePathInField(field)\n  } : {}), order ? {\n    order: order\n  } : {});\n}\n\nfunction parseSelectionDomain(model, channel) {\n  var scale = model.component.scales[channel];\n  var spec = model.specifiedScales[channel].domain;\n  var bin = model.fieldDef(channel).bin;\n  var domain = isSelectionDomain(spec) && spec;\n  var extent = isBinParams(bin) && isSelectionExtent(bin.extent) && bin.extent;\n\n  if (domain || extent) {\n    // As scale parsing occurs before selection parsing, we cannot set\n    // domainRaw directly. So instead, we store the selectionExtent on\n    // the scale component, and then add domainRaw during scale assembly.\n    scale.set('selectionExtent', domain !== null && domain !== void 0 ? domain : extent, true);\n  }\n}\n\nexport function domainSort(model, channel, scaleType) {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  } // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n\n\n  var fieldDef = model.fieldDef(channel);\n  var sort = fieldDef.sort; // if the sort is specified with array, use the derived sort index field\n\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  var isStacked = model.stack !== null; // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n\n  if (isSortField(sort)) {\n    return normalizeSortField(sort, isStacked);\n  } else if (isSortByEncoding(sort)) {\n    var encoding = sort.encoding,\n        order = sort.order;\n    var fieldDefToSortBy = model.fieldDef(encoding);\n    var aggregate = fieldDefToSortBy.aggregate,\n        field = fieldDefToSortBy.field;\n\n    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n      return normalizeSortField({\n        field: vgField(fieldDefToSortBy),\n        order: order\n      }, isStacked);\n    } else if (isAggregateOp(aggregate) || !aggregate) {\n      return normalizeSortField({\n        op: aggregate,\n        field: field,\n        order: order\n      }, isStacked);\n    }\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined\n  /* default =ascending*/\n  ], sort)) {\n    return true;\n  } // sort == null\n\n\n  return undefined;\n}\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\n\nexport function canUseUnaggregatedDomain(fieldDef, scaleType) {\n  var aggregate = fieldDef.aggregate,\n      type = fieldDef.type;\n\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (isString(aggregate) && !SHARED_DOMAIN_OP_INDEX[aggregate]) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {\n    valid: true\n  };\n}\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\n\nfunction domainsTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  } // If equal score, concat the domains so that we union them later.\n\n\n  return {\n    explicit: v1.explicit,\n    value: [].concat(_toConsumableArray(v1.value), _toConsumableArray(v2.value))\n  };\n}\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\n\n\nexport function mergeDomains(domains) {\n  var uniqueDomains = util.unique(domains.map(function (domain) {\n    // ignore sort property when computing the unique domains\n    if (isDataRefDomain(domain)) {\n      var _s = domain.sort,\n          domainWithoutSort = __rest(domain, [\"sort\"]);\n\n      return domainWithoutSort;\n    }\n\n    return domain;\n  }), util.hash);\n  var sorts = util.unique(domains.map(function (d) {\n    if (isDataRefDomain(d)) {\n      var s = d.sort;\n\n      if (s !== undefined && !util.isBoolean(s)) {\n        if ('op' in s && s.op === 'count') {\n          // let's make sure that if op is count, we don't use a field\n          delete s.field;\n        }\n\n        if (s.order === 'ascending') {\n          // drop order: ascending as it is the default\n          delete s.order;\n        }\n      }\n\n      return s;\n    }\n\n    return undefined;\n  }).filter(function (s) {\n    return s !== undefined;\n  }), util.hash);\n\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    var domain = domains[0];\n\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      var _sort = sorts[0];\n\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        _sort = true;\n      }\n\n      return Object.assign(Object.assign({}, domain), {\n        sort: _sort\n      });\n    }\n\n    return domain;\n  } // only keep sort properties that work with unioned domains\n\n\n  var unionDomainSorts = util.unique(sorts.map(function (s) {\n    if (util.isBoolean(s) || !('op' in s) || s.op in UNIONDOMAIN_SORT_OP_INDEX) {\n      return s;\n    }\n\n    log.warn(log.message.domainSortDropped(s));\n    return true;\n  }), util.hash);\n  var sort;\n\n  if (unionDomainSorts.length === 1) {\n    sort = unionDomainSorts[0];\n  } else if (unionDomainSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  var allData = util.unique(domains.map(function (d) {\n    if (isDataRefDomain(d)) {\n      return d.data;\n    }\n\n    return null;\n  }), function (x) {\n    return x;\n  });\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    var _domain = Object.assign({\n      data: allData[0],\n      fields: uniqueDomains.map(function (d) {\n        return d.field;\n      })\n    }, sort ? {\n      sort: sort\n    } : {});\n\n    return _domain;\n  }\n\n  return Object.assign({\n    fields: uniqueDomains\n  }, sort ? {\n    sort: sort\n  } : {});\n}\n/**\n * Return a field if a scale single field.\n * Return `undefined` otherwise.\n *\n */\n\nexport function getFieldFromDomain(domain) {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    var field;\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = domain.fields[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var nonUnionDomain = _step4.value;\n\n        if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n          if (!field) {\n            field = nonUnionDomain.field;\n          } else if (field !== nonUnionDomain.field) {\n            log.warn('Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.');\n            return field;\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    log.warn('Detected faceted independent scales that union domain of identical fields from different source detected. We will assume that this is the same field from a different fork of the same data source. However, if this is not case, the result view size maybe incorrect.');\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn('Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.');\n    var _field = domain.fields[0];\n    return isString(_field) ? _field : undefined;\n  }\n\n  return undefined;\n}\nexport function assembleDomain(model, channel) {\n  var scaleComponent = model.component.scales[channel];\n  var domains = scaleComponent.get('domains').map(function (domain) {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n\n    return domain;\n  }); // domains is an array that has to be merged into a single vega domain\n\n  return mergeDomains(domains);\n}","map":null,"metadata":{},"sourceType":"module"}