{"ast":null,"code":"import parseAutosize from './autosize';\nimport parsePadding from './padding';\nimport parseSignal from './signal';\nimport parseSpec from './spec';\nimport { encoders, extendEncode } from './encode/encode-util';\nimport { GroupMark } from './marks/marktypes';\nimport { FrameRole } from './marks/roles';\nimport { ref, operator } from '../util';\nimport DataScope from '../DataScope';\nimport { Bound, Collect, Encode, Render, Sieve, ViewLayout } from '../transforms';\nimport { array, toSet } from 'vega-util';\nvar defined = toSet(['width', 'height', 'padding', 'autosize']);\nexport default function parseView(spec, scope) {\n  var config = scope.config,\n      op,\n      input,\n      encode,\n      parent,\n      root,\n      signals;\n  scope.background = spec.background || config.background;\n  scope.eventConfig = config.events;\n  root = ref(scope.root = scope.add(operator()));\n  scope.addSignal('width', spec.width || 0);\n  scope.addSignal('height', spec.height || 0);\n  scope.addSignal('padding', parsePadding(spec.padding, config));\n  scope.addSignal('autosize', parseAutosize(spec.autosize, config));\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout); // parse signal definitions, including config entries\n\n  signals = addSignals(scope, spec.signals, config.signals); // Store root group item\n\n  input = scope.add(Collect()); // Encode root group item\n\n  encode = extendEncode({\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    },\n    update: {\n      width: {\n        signal: 'width'\n      },\n      height: {\n        signal: 'height'\n      }\n    }\n  }, spec.encode);\n  encode = scope.add(Encode(encoders(encode, GroupMark, FrameRole, spec.style, scope, {\n    pulse: ref(input)\n  }))); // Perform view layout\n\n  parent = scope.add(ViewLayout({\n    layout: scope.objectProperty(spec.layout),\n    legends: scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark: root,\n    pulse: ref(encode)\n  }));\n  scope.operators.pop(); // Parse remainder of specification\n\n  scope.pushState(ref(encode), ref(parent), null);\n  parseSpec(spec, scope, signals);\n  scope.operators.push(parent); // Bound / render / sieve root item\n\n  op = scope.add(Bound({\n    mark: root,\n    pulse: ref(parent)\n  }));\n  op = scope.add(Render({\n    pulse: ref(op)\n  }));\n  op = scope.add(Sieve({\n    pulse: ref(op)\n  })); // Track metadata for root item\n\n  scope.addData('root', new DataScope(scope, input, input, op));\n  return scope;\n}\n\nfunction addSignals(scope, signals, config) {\n  // signals defined in the spec take priority\n  array(signals).forEach(function (_) {\n    if (!defined[_.name]) parseSignal(_, scope);\n  });\n  if (!config) return signals;\n  var out = array(signals).slice(); // add config signals if not already defined\n\n  array(config).forEach(function (_) {\n    if (!scope.hasOwnSignal(_.name)) {\n      parseSignal(_, scope);\n      out.push(_);\n    }\n  });\n  return out;\n}","map":null,"metadata":{},"sourceType":"module"}