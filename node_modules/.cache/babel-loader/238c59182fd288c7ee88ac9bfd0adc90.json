{"ast":null,"code":"import boundStroke from '../bound/boundStroke';\nimport { intersectRule } from '../util/intersect';\nimport { visit } from '../util/visit';\nimport { pick } from '../util/canvas/pick';\nimport stroke from '../util/canvas/stroke';\nimport { translateItem } from '../util/svg/transform';\n\nfunction attr(emit, item) {\n  emit('transform', translateItem(item));\n  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);\n  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);\n}\n\nfunction bound(bounds, item) {\n  var x1, y1;\n  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);\n}\n\nfunction path(context, item, opacity) {\n  var x1, y1, x2, y2;\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    x1 = item.x || 0;\n    y1 = item.y || 0;\n    x2 = item.x2 != null ? item.x2 : x1;\n    y2 = item.y2 != null ? item.y2 : y1;\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n    return true;\n  }\n\n  return false;\n}\n\nfunction draw(context, scene, bounds) {\n  visit(scene, function (item) {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    var opacity = item.opacity == null ? 1 : item.opacity;\n\n    if (opacity && path(context, item, opacity)) {\n      context.stroke();\n    }\n  });\n}\n\nfunction hit(context, item, x, y) {\n  if (!context.isPointInStroke) return false;\n  return path(context, item, 1) && context.isPointInStroke(x, y);\n}\n\nexport default {\n  type: 'rule',\n  tag: 'line',\n  nested: false,\n  attr: attr,\n  bound: bound,\n  draw: draw,\n  pick: pick(hit),\n  isect: intersectRule\n};","map":null,"metadata":{},"sourceType":"module"}