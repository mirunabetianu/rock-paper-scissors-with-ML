{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { getMarkPropOrConfig } from '../../common';\nimport { fieldInvalidPredicate } from './valueref';\nexport function defined(model) {\n  var config = model.config,\n      markDef = model.markDef;\n  var invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid) {\n    var signal = allFieldsInvalidPredicate(model, {\n      channels: ['x', 'y']\n    });\n\n    if (signal) {\n      return {\n        defined: {\n          signal: signal\n        }\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction allFieldsInvalidPredicate(model, _ref) {\n  var _ref$invalid = _ref.invalid,\n      invalid = _ref$invalid === void 0 ? false : _ref$invalid,\n      channels = _ref.channels;\n  var filterIndex = channels.reduce(function (aggregator, channel) {\n    var scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      var scaleType = scaleComponent.get('type');\n      var field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  var fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    var op = invalid ? '||' : '&&';\n    return fields.map(function (field) {\n      return fieldInvalidPredicate(field, invalid);\n    }).join(\" \".concat(op, \" \"));\n  }\n\n  return undefined;\n}\n\nexport function valueIfDefined(prop, value) {\n  if (value !== undefined) {\n    return _defineProperty({}, prop, {\n      value: value\n    });\n  }\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"module"}