{"ast":null,"code":"import lookup from './lookup';\nimport { ingest, isTuple, Transform, tupleid } from 'vega-dataflow';\nimport { array, error, inherits } from 'vega-util';\nimport { hierarchy } from 'd3-hierarchy';\n/**\n * Nest tuples into a tree structure, grouped by key values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n * @param {boolean} [params.generate=false] - A boolean flag indicating if\n *   non-leaf nodes generated by this transform should be included in the\n *   output. The default (false) includes only the input data (leaf nodes)\n *   in the data stream.\n */\n\nexport default function Nest(params) {\n  Transform.call(this, null, params);\n}\nNest.Definition = {\n  \"type\": \"Nest\",\n  \"metadata\": {\n    \"treesource\": true,\n    \"changes\": true\n  },\n  \"params\": [{\n    \"name\": \"keys\",\n    \"type\": \"field\",\n    \"array\": true\n  }, {\n    \"name\": \"generate\",\n    \"type\": \"boolean\"\n  }]\n};\nvar prototype = inherits(Nest, Transform);\n\nfunction children(n) {\n  return n.values;\n}\n\nprototype.transform = function (_, pulse) {\n  if (!pulse.source) {\n    error('Nest transform requires an upstream data source.');\n  }\n\n  var gen = _.generate,\n      mod = _.modified(),\n      out = pulse.clone(),\n      tree = this.value;\n\n  if (!tree || mod || pulse.changed()) {\n    // collect nodes to remove\n    if (tree) {\n      tree.each(function (node) {\n        if (node.children && isTuple(node.data)) {\n          out.rem.push(node.data);\n        }\n      });\n    } // generate new tree structure\n\n\n    this.value = tree = hierarchy({\n      values: array(_.keys).reduce(function (n, k) {\n        n.key(k);\n        return n;\n      }, nest()).entries(out.source)\n    }, children); // collect nodes to add\n\n    if (gen) {\n      tree.each(function (node) {\n        if (node.children) {\n          node = ingest(node.data);\n          out.add.push(node);\n          out.source.push(node);\n        }\n      });\n    } // build lookup table\n\n\n    lookup(tree, tupleid, tupleid);\n  }\n\n  out.source.root = tree;\n  return out;\n};\n\nfunction nest() {\n  var keys = [],\n      nest;\n\n  function apply(array, depth) {\n    if (depth >= keys.length) {\n      return array;\n    }\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        value,\n        valuesByKey = {},\n        values,\n        result = {};\n\n    while (++i < n) {\n      keyValue = key(value = array[i]) + '';\n\n      if (values = valuesByKey[keyValue]) {\n        values.push(value);\n      } else {\n        valuesByKey[keyValue] = [value];\n      }\n    }\n\n    for (keyValue in valuesByKey) {\n      result[keyValue] = apply(valuesByKey[keyValue], depth);\n    }\n\n    return result;\n  }\n\n  function _entries(map, depth) {\n    if (++depth > keys.length) return map;\n    var array = [],\n        k;\n\n    for (k in map) {\n      array.push({\n        key: k,\n        values: _entries(map[k], depth)\n      });\n    }\n\n    return array;\n  }\n\n  return nest = {\n    entries: function entries(array) {\n      return _entries(apply(array, 0), 0);\n    },\n    key: function key(d) {\n      keys.push(d);\n      return nest;\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}