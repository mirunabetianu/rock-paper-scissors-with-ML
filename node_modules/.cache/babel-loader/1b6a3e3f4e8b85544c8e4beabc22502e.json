{"ast":null,"code":"import partition from './partition';\nimport { ingest, Transform } from 'vega-dataflow';\nimport { regressionLinear, regressionLog, regressionExp, regressionPow, regressionQuad, regressionPoly, sampleCurve } from 'vega-statistics';\nimport { accessorName, error, extent, hasOwnProperty, inherits } from 'vega-util';\nvar Methods = {\n  linear: regressionLinear,\n  log: regressionLog,\n  exp: regressionExp,\n  pow: regressionPow,\n  quad: regressionQuad,\n  poly: regressionPoly\n};\n\nfunction degreesOfFreedom(method, order) {\n  return method === 'poly' ? order : method === 'quad' ? 2 : 1;\n}\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\n\n\nexport default function Regression(params) {\n  Transform.call(this, null, params);\n}\nRegression.Definition = {\n  \"type\": \"Regression\",\n  \"metadata\": {\n    \"generates\": true\n  },\n  \"params\": [{\n    \"name\": \"x\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"y\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"groupby\",\n    \"type\": \"field\",\n    \"array\": true\n  }, {\n    \"name\": \"method\",\n    \"type\": \"string\",\n    \"default\": \"linear\",\n    \"values\": Object.keys(Methods)\n  }, {\n    \"name\": \"order\",\n    \"type\": \"number\",\n    \"default\": 3\n  }, {\n    \"name\": \"extent\",\n    \"type\": \"number\",\n    \"array\": true,\n    \"length\": 2\n  }, {\n    \"name\": \"params\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"array\": true\n  }]\n};\nvar prototype = inherits(Regression, Transform);\n\nprototype.transform = function (_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n  if (!this.value || pulse.changed() || _.modified()) {\n    var source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        method = _.method || 'linear',\n        order = _.order || 3,\n        dof = degreesOfFreedom(method, order),\n        as = _.as || [accessorName(_.x), accessorName(_.y)],\n        fit = Methods[method],\n        values = [];\n    var domain = _.extent;\n\n    if (!hasOwnProperty(Methods, method)) {\n      error('Invalid regression method: ' + method);\n    }\n\n    if (domain != null) {\n      if (method === 'log' && domain[0] <= 0) {\n        pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n        domain = null;\n      }\n    }\n\n    groups.forEach(function (g) {\n      var n = g.length;\n\n      if (n <= dof) {\n        pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n        return;\n      }\n\n      var model = fit(g, _.x, _.y, order);\n\n      if (_.params) {\n        // if parameter vectors requested return those\n        values.push(ingest({\n          keys: g.dims,\n          coef: model.coef,\n          rSquared: model.rSquared\n        }));\n        return;\n      }\n\n      var dom = domain || extent(g, _.x),\n          add = function add(p) {\n        var t = {};\n\n        for (var i = 0; i < names.length; ++i) {\n          t[names[i]] = g.dims[i];\n        }\n\n        t[as[0]] = p[0];\n        t[as[1]] = p[1];\n        values.push(ingest(t));\n      };\n\n      if (method === 'linear') {\n        // for linear regression we only need the end points\n        dom.forEach(function (x) {\n          return add([x, model.predict(x)]);\n        });\n      } else {\n        // otherwise return trend line sample points\n        sampleCurve(model.predict, dom, 25, 200).forEach(add);\n      }\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.add = out.source = values;\n  }\n\n  return out;\n};","map":null,"metadata":{},"sourceType":"module"}