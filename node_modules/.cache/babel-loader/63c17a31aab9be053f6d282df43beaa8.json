{"ast":null,"code":"import { derive, Transform, tupleid } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n/**\n * Relays a data stream between data processing pipelines.\n * If the derive parameter is set, this transform will create derived\n * copies of observed tuples. This provides derived data streams in which\n * modifications to the tuples do not pollute an upstream data source.\n * @param {object} params - The parameters for this operator.\n * @param {number} [params.derive=false] - Boolean flag indicating if\n *   the transform should make derived copies of incoming tuples.\n * @constructor\n */\n\nexport default function Relay(params) {\n  Transform.call(this, null, params);\n}\nvar prototype = inherits(Relay, Transform);\n\nprototype.transform = function (_, pulse) {\n  var out, lut;\n\n  if (this.value) {\n    lut = this.value;\n  } else {\n    out = pulse = pulse.addAll();\n    lut = this.value = {};\n  }\n\n  if (_.derive) {\n    out = pulse.fork(pulse.NO_SOURCE);\n    pulse.visit(pulse.REM, function (t) {\n      var id = tupleid(t);\n      out.rem.push(lut[id]);\n      lut[id] = null;\n    });\n    pulse.visit(pulse.ADD, function (t) {\n      var dt = derive(t);\n      lut[tupleid(t)] = dt;\n      out.add.push(dt);\n    });\n    pulse.visit(pulse.MOD, function (t) {\n      var dt = lut[tupleid(t)],\n          k;\n\n      for (k in t) {\n        dt[k] = t[k]; // down stream writes may overwrite re-derived tuples\n        // conservatively mark all source fields as modified\n\n        out.modifies(k);\n      }\n\n      out.mod.push(dt);\n    });\n  }\n\n  return out;\n};","map":null,"metadata":{},"sourceType":"module"}