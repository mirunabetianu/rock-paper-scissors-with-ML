{"ast":null,"code":"import { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\n\nexport default function ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\nResolveFilter.Definition = {\n  \"type\": \"ResolveFilter\",\n  \"metadata\": {},\n  \"params\": [{\n    \"name\": \"ignore\",\n    \"type\": \"number\",\n    \"required\": true,\n    \"description\": \"A bit mask indicating which filters to ignore.\"\n  }, {\n    \"name\": \"filter\",\n    \"type\": \"object\",\n    \"required\": true,\n    \"description\": \"Per-tuple filter bitmaps from a CrossFilter transform.\"\n  }]\n};\nvar prototype = inherits(ResolveFilter, Transform);\n\nprototype.transform = function (_, pulse) {\n  var ignore = ~(_.ignore || 0),\n      // bit mask where zeros -> dims to ignore\n  bitmap = _.filter,\n      mask = bitmap.mask; // exit early if no relevant filter changes\n\n  if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n  var output = pulse.fork(pulse.ALL),\n      data = bitmap.data(),\n      curr = bitmap.curr(),\n      prev = bitmap.prev(),\n      pass = function pass(k) {\n    return !(curr[k] & ignore) ? data[k] : null;\n  }; // propagate all mod tuples that pass the filter\n\n\n  output.filter(output.MOD, pass); // determine add & rem tuples via filter functions\n  // for efficiency, we do *not* populate new arrays,\n  // instead we add filter functions applied downstream\n\n  if (!(mask & mask - 1)) {\n    // only one filter changed\n    output.filter(output.ADD, pass);\n    output.filter(output.REM, function (k) {\n      return (curr[k] & ignore) === mask ? data[k] : null;\n    });\n  } else {\n    // multiple filters changed\n    output.filter(output.ADD, function (k) {\n      var c = curr[k] & ignore,\n          f = !c && c ^ prev[k] & ignore;\n      return f ? data[k] : null;\n    });\n    output.filter(output.REM, function (k) {\n      var c = curr[k] & ignore,\n          f = c && !(c ^ (c ^ prev[k] & ignore));\n      return f ? data[k] : null;\n    });\n  } // add filter to source data in case of reflow...\n\n\n  return output.filter(output.SOURCE, function (t) {\n    return pass(t._index);\n  });\n};","map":null,"metadata":{},"sourceType":"module"}