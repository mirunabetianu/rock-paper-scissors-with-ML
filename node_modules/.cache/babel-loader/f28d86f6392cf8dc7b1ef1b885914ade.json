{"ast":null,"code":"import { groupkey } from './util/AggregateKeys';\nimport { ValidAggregateOps } from './util/AggregateOps';\nimport SortedList from './util/SortedList';\nimport { ValidWindowOps } from './util/WindowOps';\nimport WindowState from './util/WindowState';\nimport { stableCompare, Transform, tupleid } from 'vega-dataflow';\nimport { constant, inherits } from 'vega-util';\nimport { bisector } from 'd3-array';\n/**\n * Perform window calculations and write results to the input stream.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.\n * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors\n *   for data fields to use as inputs to window operations.\n * @param {Array<*>} [params.params] - An array of parameter values for window operations.\n * @param {Array<string>} [params.as] - An array of output field names for window operations.\n * @param {Array<number>} [params.frame] - Window frame definition as two-element array.\n * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row\n *   number alone, ignoring peers with identical sort values. If false (default),\n *   the window boundaries will be adjusted to include peer values.\n */\n\nexport default function Window(params) {\n  Transform.call(this, {}, params);\n  this._mlen = 0;\n  this._mods = [];\n}\nWindow.Definition = {\n  \"type\": \"Window\",\n  \"metadata\": {\n    \"modifies\": true\n  },\n  \"params\": [{\n    \"name\": \"sort\",\n    \"type\": \"compare\"\n  }, {\n    \"name\": \"groupby\",\n    \"type\": \"field\",\n    \"array\": true\n  }, {\n    \"name\": \"ops\",\n    \"type\": \"enum\",\n    \"array\": true,\n    \"values\": ValidWindowOps.concat(ValidAggregateOps)\n  }, {\n    \"name\": \"params\",\n    \"type\": \"number\",\n    \"null\": true,\n    \"array\": true\n  }, {\n    \"name\": \"fields\",\n    \"type\": \"field\",\n    \"null\": true,\n    \"array\": true\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"null\": true,\n    \"array\": true\n  }, {\n    \"name\": \"frame\",\n    \"type\": \"number\",\n    \"null\": true,\n    \"array\": true,\n    \"length\": 2,\n    \"default\": [null, 0]\n  }, {\n    \"name\": \"ignorePeers\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }]\n};\nvar prototype = inherits(Window, Transform);\n\nprototype.transform = function (_, pulse) {\n  var self = this,\n      state = self.state,\n      mod = _.modified(),\n      cmp = stableCompare(_.sort),\n      i,\n      n;\n\n  this.stamp = pulse.stamp; // initialize window state\n\n  if (!state || mod) {\n    state = self.state = new WindowState(_);\n  } // retrieve group for a tuple\n\n\n  var key = groupkey(_.groupby);\n\n  function group(t) {\n    return self.group(key(t));\n  } // partition input tuples\n\n\n  if (mod || pulse.modified(state.inputs)) {\n    self.value = {};\n    pulse.visit(pulse.SOURCE, function (t) {\n      group(t).add(t);\n    });\n  } else {\n    pulse.visit(pulse.REM, function (t) {\n      group(t).remove(t);\n    });\n    pulse.visit(pulse.ADD, function (t) {\n      group(t).add(t);\n    });\n  } // perform window calculations for each modified partition\n\n\n  for (i = 0, n = self._mlen; i < n; ++i) {\n    processPartition(self._mods[i], state, cmp, _);\n  }\n\n  self._mlen = 0;\n  self._mods = []; // TODO don't reflow everything?\n\n  return pulse.reflow(mod).modifies(state.outputs);\n};\n\nprototype.group = function (key) {\n  var self = this,\n      group = self.value[key];\n\n  if (!group) {\n    group = self.value[key] = SortedList(tupleid);\n    group.stamp = -1;\n  }\n\n  if (group.stamp < self.stamp) {\n    group.stamp = self.stamp;\n    self._mods[self._mlen++] = group;\n  }\n\n  return group;\n};\n\nfunction processPartition(list, state, cmp, _) {\n  var sort = _.sort,\n      range = sort && !_.ignorePeers,\n      frame = _.frame || [null, 0],\n      data = list.data(cmp),\n      // use cmp for stable sort\n  n = data.length,\n      i = 0,\n      b = range ? bisector(sort) : null,\n      w = {\n    i0: 0,\n    i1: 0,\n    p0: 0,\n    p1: 0,\n    index: 0,\n    data: data,\n    compare: sort || constant(-1)\n  };\n\n  for (state.init(); i < n; ++i) {\n    setWindow(w, frame, i, n);\n    if (range) adjustRange(w, b);\n    state.update(w, data[i]);\n  }\n}\n\nfunction setWindow(w, f, i, n) {\n  w.p0 = w.i0;\n  w.p1 = w.i1;\n  w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));\n  w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);\n  w.index = i;\n} // if frame type is 'range', adjust window for peer values\n\n\nfunction adjustRange(w, bisect) {\n  var r0 = w.i0,\n      r1 = w.i1 - 1,\n      c = w.compare,\n      d = w.data,\n      n = d.length - 1;\n  if (r0 > 0 && !c(d[r0], d[r0 - 1])) w.i0 = bisect.left(d, d[r0]);\n  if (r1 < n && !c(d[r1], d[r1 + 1])) w.i1 = bisect.right(d, d[r1]);\n}","map":null,"metadata":{},"sourceType":"module"}