{"ast":null,"code":"import { CallExpression, parse } from 'vega-expression';\nimport { codeGenerator, codegenParams, SignalPrefix } from 'vega-functions';\nimport { error, hasOwnProperty, isString, stringValue } from 'vega-util';\nexport default function (expr, scope, preamble) {\n  var params = {},\n      ast,\n      gen; // parse the expression to an abstract syntax tree (ast)\n\n  try {\n    expr = isString(expr) ? expr : stringValue(expr) + '';\n    ast = parse(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  } // analyze ast function calls for dependencies\n\n\n  ast.visit(function visitor(node) {\n    if (node.type !== CallExpression) return;\n    var name = node.callee.name,\n        visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  }); // perform code generation\n\n  gen = codeGenerator(ast); // collect signal dependencies\n\n  gen.globals.forEach(function (name) {\n    var signalName = SignalPrefix + name;\n\n    if (!hasOwnProperty(params, signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  }); // return generated expression code and dependencies\n\n  return {\n    $expr: preamble ? preamble + 'return(' + gen.code + ');' : gen.code,\n    $fields: gen.fields,\n    $params: params\n  };\n}","map":null,"metadata":{},"sourceType":"module"}