{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { __rest } from \"tslib\";\nimport { array, stringValue } from 'vega-util';\nimport { STORE, TUPLE, unitName } from '.';\nimport { X, Y } from '../../channel';\nimport { warn } from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys } from '../../util';\nimport { assembleInit } from './assemble';\nimport { TUPLE_FIELDS } from './transforms/project';\nimport scales from './transforms/scales';\nexport var BRUSH = '_brush';\nexport var SCALE_TRIGGER = '_scale_trigger';\nvar interval = {\n  signals: function signals(model, selCmpt) {\n    var name = selCmpt.name;\n    var fieldsSg = name + TUPLE_FIELDS;\n    var hasScales = scales.has(selCmpt);\n    var signals = [];\n    var dataSignals = [];\n    var scaleTriggers = [];\n\n    if (selCmpt.translate && !hasScales) {\n      var filterExpr = \"!event.item || event.item.mark.name !== \".concat(stringValue(name + BRUSH));\n      events(selCmpt, function (on, evt) {\n        var _a;\n\n        var filters = array((_a = evt.between[0].filter, _a !== null && _a !== void 0 ? _a : evt.between[0].filter = []));\n\n        if (filters.indexOf(filterExpr) < 0) {\n          filters.push(filterExpr);\n        }\n\n        return on;\n      });\n    }\n\n    selCmpt.project.items.forEach(function (proj, i) {\n      var channel = proj.channel;\n\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n\n      var init = selCmpt.init ? selCmpt.init[i] : null;\n      var cs = channelSignals(model, selCmpt, proj, init);\n      var dname = proj.signals.data;\n      var vname = proj.signals.visual;\n      var scaleName = stringValue(model.scaleName(channel));\n      var scaleType = model.getScaleComponent(channel).get('type');\n      var toNum = hasContinuousDomain(scaleType) ? '+' : '';\n      signals.push.apply(signals, _toConsumableArray(cs));\n      dataSignals.push(dname);\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr: \"(!isArray(\".concat(dname, \") || \") + \"(\".concat(toNum, \"invert(\").concat(scaleName, \", \").concat(vname, \")[0] === \").concat(toNum).concat(dname, \"[0] && \") + \"\".concat(toNum, \"invert(\").concat(scaleName, \", \").concat(vname, \")[1] === \").concat(toNum).concat(dname, \"[1]))\")\n      });\n    }); // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n\n    if (!hasScales) {\n      signals.push({\n        name: name + SCALE_TRIGGER,\n        value: {},\n        on: [{\n          events: scaleTriggers.map(function (t) {\n            return {\n              scale: t.scaleName\n            };\n          }),\n          update: scaleTriggers.map(function (t) {\n            return t.expr;\n          }).join(' && ') + \" ? \".concat(name + SCALE_TRIGGER, \" : {}\")\n        }]\n      });\n    } // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n\n\n    var init = selCmpt.init;\n    var update = \"unit: \".concat(unitName(model), \", fields: \").concat(fieldsSg, \", values\");\n    return signals.concat(Object.assign(Object.assign({\n      name: name + TUPLE\n    }, init ? {\n      init: \"{\".concat(update, \": \").concat(assembleInit(init), \"}\")\n    } : {}), {\n      on: [{\n        events: [{\n          signal: dataSignals.join(' || ')\n        }],\n        update: dataSignals.join(' && ') + \" ? {\".concat(update, \": [\").concat(dataSignals, \"]} : null\")\n      }]\n    }));\n  },\n  modifyExpr: function modifyExpr(model, selCmpt) {\n    var tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'true' : \"{unit: \".concat(unitName(model), \"}\"));\n  },\n  marks: function marks(model, selCmpt, _marks) {\n    var name = selCmpt.name;\n    var _selCmpt$project$hasC = selCmpt.project.hasChannel,\n        x = _selCmpt$project$hasC.x,\n        y = _selCmpt$project$hasC.y;\n    var xvname = x && x.signals.visual;\n    var yvname = y && y.signals.visual;\n    var store = \"data(\".concat(stringValue(selCmpt.name + STORE), \")\"); // Do not add a brush if we're binding to scales.\n\n    if (scales.has(selCmpt)) {\n      return _marks;\n    }\n\n    var update = {\n      x: x !== undefined ? {\n        signal: \"\".concat(xvname, \"[0]\")\n      } : {\n        value: 0\n      },\n      y: y !== undefined ? {\n        signal: \"\".concat(yvname, \"[0]\")\n      } : {\n        value: 0\n      },\n      x2: x !== undefined ? {\n        signal: \"\".concat(xvname, \"[1]\")\n      } : {\n        field: {\n          group: 'width'\n        }\n      },\n      y2: y !== undefined ? {\n        signal: \"\".concat(yvname, \"[1]\")\n      } : {\n        field: {\n          group: 'height'\n        }\n      }\n    }; // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n\n    if (selCmpt.resolve === 'global') {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = keys(update)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          update[key] = [Object.assign({\n            test: \"\".concat(store, \".length && \").concat(store, \"[0].unit === \").concat(unitName(model))\n          }, update[key]), {\n            value: 0\n          }];\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n\n\n    var _a = selCmpt.mark,\n        fill = _a.fill,\n        fillOpacity = _a.fillOpacity,\n        stroke = __rest(_a, [\"fill\", \"fillOpacity\"]);\n\n    var vgStroke = keys(stroke).reduce(function (def, k) {\n      def[k] = [{\n        test: [x !== undefined && \"\".concat(xvname, \"[0] !== \").concat(xvname, \"[1]\"), y !== undefined && \"\".concat(yvname, \"[0] !== \").concat(yvname, \"[1]\")].filter(function (t) {\n          return t;\n        }).join(' && '),\n        value: stroke[k]\n      }, {\n        value: null\n      }];\n      return def;\n    }, {});\n    return [{\n      name: name + BRUSH + '_bg',\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {\n            value: fill\n          },\n          fillOpacity: {\n            value: fillOpacity\n          }\n        },\n        update: update\n      }\n    }].concat(_toConsumableArray(_marks), [{\n      name: name + BRUSH,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {\n            value: 'transparent'\n          }\n        },\n        update: Object.assign(Object.assign({}, update), vgStroke)\n      }\n    }]);\n  }\n};\nexport default interval;\n/**\n * Returns the visual and data signals for an interval selection.\n */\n\nfunction channelSignals(model, selCmpt, proj, init) {\n  var channel = proj.channel;\n  var vname = proj.signals.visual;\n  var dname = proj.signals.data;\n  var hasScales = scales.has(selCmpt);\n  var scaleName = stringValue(model.scaleName(channel));\n  var scale = model.getScaleComponent(channel);\n  var scaleType = scale ? scale.get('type') : undefined;\n\n  var scaled = function scaled(str) {\n    return \"scale(\".concat(scaleName, \", \").concat(str, \")\");\n  };\n\n  var size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  var coord = \"\".concat(channel, \"(unit)\");\n  var on = events(selCmpt, function (def, evt) {\n    return [].concat(_toConsumableArray(def), [{\n      events: evt.between[0],\n      update: \"[\".concat(coord, \", \").concat(coord, \"]\")\n    }, {\n      events: evt,\n      update: \"[\".concat(vname, \"[0], clamp(\").concat(coord, \", 0, \").concat(size, \")]\")\n    } // Brush End\n    ]);\n  }); // React to pan/zooms of continuous scales. Non-continuous scales\n  // (band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n\n  on.push({\n    events: {\n      signal: selCmpt.name + SCALE_TRIGGER\n    },\n    update: hasContinuousDomain(scaleType) ? \"[\".concat(scaled(\"\".concat(dname, \"[0]\")), \", \").concat(scaled(\"\".concat(dname, \"[1]\")), \"]\") : \"[0, 0]\"\n  });\n  return hasScales ? [{\n    name: dname,\n    on: []\n  }] : [Object.assign(Object.assign({\n    name: vname\n  }, init ? {\n    init: assembleInit(init, true, scaled)\n  } : {\n    value: []\n  }), {\n    on: on\n  }), Object.assign(Object.assign({\n    name: dname\n  }, init ? {\n    init: assembleInit(init)\n  } : {}), {\n    on: [{\n      events: {\n        signal: vname\n      },\n      update: \"\".concat(vname, \"[0] === \").concat(vname, \"[1] ? null : invert(\").concat(scaleName, \", \").concat(vname, \")\")\n    }]\n  })];\n}\n\nfunction events(selCmpt, cb) {\n  return selCmpt.events.reduce(function (on, evt) {\n    if (!evt.between) {\n      warn(\"\".concat(evt, \" is not an ordered event stream for interval selections.\"));\n      return on;\n    }\n\n    return cb(on, evt);\n  }, []);\n}","map":null,"metadata":{},"sourceType":"module"}