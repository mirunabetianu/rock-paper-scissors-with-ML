{"ast":null,"code":"import _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { isAggregateOp } from '../../aggregate';\nimport { vgField } from '../../channeldef';\nimport { duplicate, hash as _hash } from '../../util';\nimport { unique } from './../../util';\nimport { DataFlowNode } from './dataflow';\n/**\n * A class for the window transform nodes\n */\n\nexport var WindowTransformNode =\n/*#__PURE__*/\nfunction (_DataFlowNode) {\n  _inherits(WindowTransformNode, _DataFlowNode);\n\n  function WindowTransformNode(parent, transform) {\n    var _this;\n\n    _classCallCheck(this, WindowTransformNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WindowTransformNode).call(this, parent));\n    _this.transform = transform;\n    return _this;\n  }\n\n  _createClass(WindowTransformNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new WindowTransformNode(null, duplicate(this.transform));\n    }\n  }, {\n    key: \"addDimensions\",\n    value: function addDimensions(fields) {\n      this.transform.groupby = unique(this.transform.groupby.concat(fields), function (d) {\n        return d;\n      });\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var _a, _b;\n\n      var out = new Set();\n      (_a = this.transform.groupby, _a !== null && _a !== void 0 ? _a : []).forEach(function (f) {\n        return out.add(f);\n      });\n      (_b = this.transform.sort, _b !== null && _b !== void 0 ? _b : []).forEach(function (m) {\n        return out.add(m.field);\n      });\n      this.transform.window.map(function (w) {\n        return w.field;\n      }).filter(function (f) {\n        return f !== undefined;\n      }).forEach(function (f) {\n        return out.add(f);\n      });\n      return out;\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(this.transform.window.map(this.getDefaultName));\n    }\n  }, {\n    key: \"getDefaultName\",\n    value: function getDefaultName(windowFieldDef) {\n      var _a;\n\n      return _a = windowFieldDef.as, _a !== null && _a !== void 0 ? _a : vgField(windowFieldDef);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"WindowTransform \".concat(_hash(this.transform));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _a;\n\n      var fields = [];\n      var ops = [];\n      var as = [];\n      var params = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.transform.window[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var window = _step.value;\n          ops.push(window.op);\n          as.push(this.getDefaultName(window));\n          params.push(window.param === undefined ? null : window.param);\n          fields.push(window.field === undefined ? null : window.field);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var frame = this.transform.frame;\n      var groupby = this.transform.groupby;\n\n      if (frame && frame[0] === null && frame[1] === null && ops.every(function (o) {\n        return isAggregateOp(o);\n      })) {\n        // when the window does not rely on any particular window ops or frame, switch to a simpler and more efficient joinaggregate\n        return Object.assign({\n          type: 'joinaggregate',\n          as: as,\n          ops: ops,\n          fields: fields\n        }, groupby !== undefined ? {\n          groupby: groupby\n        } : {});\n      }\n\n      var sortFields = [];\n      var sortOrder = [];\n\n      if (this.transform.sort !== undefined) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.transform.sort[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var sortField = _step2.value;\n            sortFields.push(sortField.field);\n            sortOrder.push((_a = sortField.order, _a !== null && _a !== void 0 ? _a : 'ascending'));\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      var sort = {\n        field: sortFields,\n        order: sortOrder\n      };\n      var ignorePeers = this.transform.ignorePeers;\n      return Object.assign(Object.assign(Object.assign({\n        type: 'window',\n        params: params,\n        as: as,\n        ops: ops,\n        fields: fields,\n        sort: sort\n      }, ignorePeers !== undefined ? {\n        ignorePeers: ignorePeers\n      } : {}), groupby !== undefined ? {\n        groupby: groupby\n      } : {}), frame !== undefined ? {\n        frame: frame\n      } : {});\n    }\n  }]);\n\n  return WindowTransformNode;\n}(DataFlowNode);","map":null,"metadata":{},"sourceType":"module"}