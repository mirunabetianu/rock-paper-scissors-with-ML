{"ast":null,"code":"import { Transform } from 'vega-dataflow';\nimport { accessorFields, array, error, hasOwnProperty, inherits, isFunction } from 'vega-util';\nimport { forceSimulation, forceCenter, forceCollide, forceManyBody, forceLink, forceX, forceY } from 'd3-force';\nvar ForceMap = {\n  center: forceCenter,\n  collide: forceCollide,\n  nbody: forceManyBody,\n  link: forceLink,\n  x: forceX,\n  y: forceY\n};\nvar Forces = 'forces',\n    ForceParams = ['alpha', 'alphaMin', 'alphaTarget', 'velocityDecay', 'forces'],\n    ForceConfig = ['static', 'iterations'],\n    ForceOutput = ['x', 'y', 'vx', 'vy'];\n/**\n * Force simulation layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<object>} params.forces - The forces to apply.\n */\n\nexport default function Force(params) {\n  Transform.call(this, null, params);\n}\nForce.Definition = {\n  \"type\": \"Force\",\n  \"metadata\": {\n    \"modifies\": true\n  },\n  \"params\": [{\n    \"name\": \"static\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }, {\n    \"name\": \"restart\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }, {\n    \"name\": \"iterations\",\n    \"type\": \"number\",\n    \"default\": 300\n  }, {\n    \"name\": \"alpha\",\n    \"type\": \"number\",\n    \"default\": 1\n  }, {\n    \"name\": \"alphaMin\",\n    \"type\": \"number\",\n    \"default\": 0.001\n  }, {\n    \"name\": \"alphaTarget\",\n    \"type\": \"number\",\n    \"default\": 0\n  }, {\n    \"name\": \"velocityDecay\",\n    \"type\": \"number\",\n    \"default\": 0.4\n  }, {\n    \"name\": \"forces\",\n    \"type\": \"param\",\n    \"array\": true,\n    \"params\": [{\n      \"key\": {\n        \"force\": \"center\"\n      },\n      \"params\": [{\n        \"name\": \"x\",\n        \"type\": \"number\",\n        \"default\": 0\n      }, {\n        \"name\": \"y\",\n        \"type\": \"number\",\n        \"default\": 0\n      }]\n    }, {\n      \"key\": {\n        \"force\": \"collide\"\n      },\n      \"params\": [{\n        \"name\": \"radius\",\n        \"type\": \"number\",\n        \"expr\": true\n      }, {\n        \"name\": \"strength\",\n        \"type\": \"number\",\n        \"default\": 0.7\n      }, {\n        \"name\": \"iterations\",\n        \"type\": \"number\",\n        \"default\": 1\n      }]\n    }, {\n      \"key\": {\n        \"force\": \"nbody\"\n      },\n      \"params\": [{\n        \"name\": \"strength\",\n        \"type\": \"number\",\n        \"default\": -30\n      }, {\n        \"name\": \"theta\",\n        \"type\": \"number\",\n        \"default\": 0.9\n      }, {\n        \"name\": \"distanceMin\",\n        \"type\": \"number\",\n        \"default\": 1\n      }, {\n        \"name\": \"distanceMax\",\n        \"type\": \"number\"\n      }]\n    }, {\n      \"key\": {\n        \"force\": \"link\"\n      },\n      \"params\": [{\n        \"name\": \"links\",\n        \"type\": \"data\"\n      }, {\n        \"name\": \"id\",\n        \"type\": \"field\"\n      }, {\n        \"name\": \"distance\",\n        \"type\": \"number\",\n        \"default\": 30,\n        \"expr\": true\n      }, {\n        \"name\": \"strength\",\n        \"type\": \"number\",\n        \"expr\": true\n      }, {\n        \"name\": \"iterations\",\n        \"type\": \"number\",\n        \"default\": 1\n      }]\n    }, {\n      \"key\": {\n        \"force\": \"x\"\n      },\n      \"params\": [{\n        \"name\": \"strength\",\n        \"type\": \"number\",\n        \"default\": 0.1\n      }, {\n        \"name\": \"x\",\n        \"type\": \"field\"\n      }]\n    }, {\n      \"key\": {\n        \"force\": \"y\"\n      },\n      \"params\": [{\n        \"name\": \"strength\",\n        \"type\": \"number\",\n        \"default\": 0.1\n      }, {\n        \"name\": \"y\",\n        \"type\": \"field\"\n      }]\n    }]\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"array\": true,\n    \"modify\": false,\n    \"default\": ForceOutput\n  }]\n};\nvar prototype = inherits(Force, Transform);\n\nprototype.transform = function (_, pulse) {\n  var sim = this.value,\n      change = pulse.changed(pulse.ADD_REM),\n      params = _.modified(ForceParams),\n      iters = _.iterations || 300; // configure simulation\n\n\n  if (!sim) {\n    this.value = sim = simulation(pulse.source, _);\n    sim.on('tick', rerun(pulse.dataflow, this));\n\n    if (!_.static) {\n      change = true;\n      sim.tick(); // ensure we run on init\n    }\n\n    pulse.modifies('index');\n  } else {\n    if (change) {\n      pulse.modifies('index');\n      sim.nodes(pulse.source);\n    }\n\n    if (params || pulse.changed(pulse.MOD)) {\n      setup(sim, _, 0, pulse);\n    }\n  } // run simulation\n\n\n  if (params || change || _.modified(ForceConfig) || pulse.changed() && _.restart) {\n    sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));\n\n    if (_.static) {\n      for (sim.stop(); --iters >= 0;) {\n        sim.tick();\n      }\n    } else {\n      if (sim.stopped()) sim.restart();\n      if (!change) return pulse.StopPropagation; // defer to sim ticks\n    }\n  }\n\n  return this.finish(_, pulse);\n};\n\nprototype.finish = function (_, pulse) {\n  var dataflow = pulse.dataflow; // inspect dependencies, touch link source data\n\n  for (var args = this._argops, j = 0, m = args.length, arg; j < m; ++j) {\n    arg = args[j];\n\n    if (arg.name !== Forces || arg.op._argval.force !== 'link') {\n      continue;\n    }\n\n    for (var ops = arg.op._argops, i = 0, n = ops.length, op; i < n; ++i) {\n      if (ops[i].name === 'links' && (op = ops[i].op.source)) {\n        dataflow.pulse(op, dataflow.changeset().reflow());\n        break;\n      }\n    }\n  } // reflow all nodes\n\n\n  return pulse.reflow(_.modified()).modifies(ForceOutput);\n};\n\nfunction rerun(df, op) {\n  return function () {\n    df.touch(op).run();\n  };\n}\n\nfunction simulation(nodes, _) {\n  var sim = forceSimulation(nodes),\n      stopped = false,\n      stop = sim.stop,\n      restart = sim.restart;\n\n  sim.stopped = function () {\n    return stopped;\n  };\n\n  sim.restart = function () {\n    stopped = false;\n    return restart();\n  };\n\n  sim.stop = function () {\n    stopped = true;\n    return stop();\n  };\n\n  return setup(sim, _, true).on('end', function () {\n    stopped = true;\n  });\n}\n\nfunction setup(sim, _, init, pulse) {\n  var f = array(_.forces),\n      i,\n      n,\n      p,\n      name;\n\n  for (i = 0, n = ForceParams.length; i < n; ++i) {\n    p = ForceParams[i];\n    if (p !== Forces && _.modified(p)) sim[p](_[p]);\n  }\n\n  for (i = 0, n = f.length; i < n; ++i) {\n    name = Forces + i;\n    p = init || _.modified(Forces, i) ? getForce(f[i]) : pulse && modified(f[i], pulse) ? sim.force(name) : null;\n    if (p) sim.force(name, p);\n  }\n\n  for (n = sim.numForces || 0; i < n; ++i) {\n    sim.force(Forces + i, null); // remove\n  }\n\n  sim.numForces = f.length;\n  return sim;\n}\n\nfunction modified(f, pulse) {\n  var k, v;\n\n  for (k in f) {\n    if (isFunction(v = f[k]) && pulse.modified(accessorFields(v))) return 1;\n  }\n\n  return 0;\n}\n\nfunction getForce(_) {\n  var f, p;\n\n  if (!hasOwnProperty(ForceMap, _.force)) {\n    error('Unrecognized force: ' + _.force);\n  }\n\n  f = ForceMap[_.force]();\n\n  for (p in _) {\n    if (isFunction(f[p])) setForceParam(f[p], _[p], _);\n  }\n\n  return f;\n}\n\nfunction setForceParam(f, v, _) {\n  f(isFunction(v) ? function (d) {\n    return v(d, _);\n  } : v);\n}","map":null,"metadata":{},"sourceType":"module"}