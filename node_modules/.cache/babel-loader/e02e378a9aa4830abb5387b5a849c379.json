{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { __rest } from \"tslib\";\nimport { isString } from 'vega-util';\nimport { binToString, isBinning, isSelectionExtent } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash as _hash, keys, replacePathInField, unique, vals, varName } from '../../util';\nimport { binFormatExpression } from '../common';\nimport { isUnitModel } from '../model';\nimport { parseSelectionBinExtent } from '../selection/parse';\nimport { DataFlowNode } from './dataflow';\n\nfunction rangeFormula(model, fieldDef, channel, config) {\n  var _a, _b;\n\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n    var guide = isUnitModel(model) ? (_b = (_a = model.axis(channel), _a !== null && _a !== void 0 ? _a : model.legend(channel)), _b !== null && _b !== void 0 ? _b : {}) : {};\n    var startField = vgField(fieldDef, {\n      expr: 'datum'\n    });\n    var endField = vgField(fieldDef, {\n      expr: 'datum',\n      binSuffix: 'end'\n    });\n    return {\n      formulaAs: vgField(fieldDef, {\n        binSuffix: 'range',\n        forAs: true\n      }),\n      formula: binFormatExpression(startField, endField, guide.format, config)\n    };\n  }\n\n  return {};\n}\n\nfunction binKey(bin, field) {\n  return \"\".concat(binToString(bin), \"_\").concat(field);\n}\n\nfunction getSignalsFromModel(model, key) {\n  return {\n    signal: model.getName(\"\".concat(key, \"_bins\")),\n    extentSignal: model.getName(\"\".concat(key, \"_extent\"))\n  };\n}\n\nexport function getBinSignalName(model, field, bin) {\n  var _a;\n\n  var normalizedBin = (_a = normalizeBin(bin, undefined), _a !== null && _a !== void 0 ? _a : {});\n  var key = binKey(normalizedBin, field);\n  return model.getName(\"\".concat(key, \"_bins\"));\n}\n\nfunction isBinTransform(t) {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t, bin, model) {\n  var as;\n  var span;\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, \"\".concat(t.as, \"_end\")] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {\n      forAs: true\n    }), vgField(t, {\n      binSuffix: 'end',\n      forAs: true\n    })];\n  }\n\n  var normalizedBin = Object.assign({}, normalizeBin(bin, undefined));\n  var key = binKey(normalizedBin, t.field);\n\n  var _getSignalsFromModel = getSignalsFromModel(model, key),\n      signal = _getSignalsFromModel.signal,\n      extentSignal = _getSignalsFromModel.extentSignal;\n\n  if (isSelectionExtent(normalizedBin.extent)) {\n    var ext = normalizedBin.extent;\n    var selName = ext.selection;\n    span = parseSelectionBinExtent(model.getSelectionComponent(varName(selName), selName), ext);\n    delete normalizedBin.extent; // Vega-Lite selection extent map to Vega's span property.\n  }\n\n  var binComponent = Object.assign(Object.assign(Object.assign({\n    bin: normalizedBin,\n    field: t.field,\n    as: [as]\n  }, signal ? {\n    signal: signal\n  } : {}), extentSignal ? {\n    extentSignal: extentSignal\n  } : {}), span ? {\n    span: span\n  } : {});\n  return {\n    key: key,\n    binComponent: binComponent\n  };\n}\n\nexport var BinNode =\n/*#__PURE__*/\nfunction (_DataFlowNode) {\n  _inherits(BinNode, _DataFlowNode);\n\n  function BinNode(parent, bins) {\n    var _this;\n\n    _classCallCheck(this, BinNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BinNode).call(this, parent));\n    _this.bins = bins;\n    return _this;\n  }\n\n  _createClass(BinNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new BinNode(null, duplicate(this.bins));\n    }\n  }, {\n    key: \"merge\",\n\n    /**\n     * Merge bin nodes. This method either integrates the bin config from the other node\n     * or if this node already has a bin config, renames the corresponding signal in the model.\n     */\n    value: function merge(other, renameSignal) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = keys(other.bins)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n\n          if (key in this.bins) {\n            renameSignal(other.bins[key].signal, this.bins[key].signal); // Ensure that we don't have duplicate names for signal pairs\n\n            this.bins[key].as = unique([].concat(_toConsumableArray(this.bins[key].as), _toConsumableArray(other.bins[key].as)), _hash);\n          } else {\n            this.bins[key] = other.bins[key];\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = other.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var child = _step2.value;\n          other.removeChild(child);\n          child.parent = this;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      other.remove();\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(vals(this.bins).map(function (c) {\n        return c.as;\n      }).flat(2));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(vals(this.bins).map(function (c) {\n        return c.field;\n      }));\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Bin \".concat(_hash(this.bins));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return vals(this.bins).flatMap(function (bin) {\n        var transform = [];\n\n        var _bin$as = _toArray(bin.as),\n            binAs = _bin$as[0],\n            remainingAs = _bin$as.slice(1);\n\n        var _a = bin.bin,\n            extent = _a.extent,\n            params = __rest(_a, [\"extent\"]);\n\n        var binTrans = Object.assign(Object.assign(Object.assign({\n          type: 'bin',\n          field: replacePathInField(bin.field),\n          as: binAs,\n          signal: bin.signal\n        }, !isSelectionExtent(extent) ? {\n          extent: extent\n        } : {\n          extent: null\n        }), bin.span ? {\n          span: {\n            signal: \"span(\".concat(bin.span, \")\")\n          }\n        } : {}), params);\n\n        if (!extent && bin.extentSignal) {\n          transform.push({\n            type: 'extent',\n            field: replacePathInField(bin.field),\n            signal: bin.extentSignal\n          });\n          binTrans.extent = {\n            signal: bin.extentSignal\n          };\n        }\n\n        transform.push(binTrans);\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = remainingAs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var as = _step3.value;\n\n            for (var i = 0; i < 2; i++) {\n              transform.push({\n                type: 'formula',\n                expr: vgField({\n                  field: binAs[i]\n                }, {\n                  expr: 'datum'\n                }),\n                as: as[i]\n              });\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        if (bin.formula) {\n          transform.push({\n            type: 'formula',\n            expr: bin.formula,\n            as: bin.formulaAs\n          });\n        }\n\n        return transform;\n      });\n    }\n  }], [{\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var bins = model.reduceFieldDef(function (binComponentIndex, fieldDef, channel) {\n        if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n          var _createBinComponent = createBinComponent(fieldDef, fieldDef.bin, model),\n              key = _createBinComponent.key,\n              binComponent = _createBinComponent.binComponent;\n\n          binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));\n        }\n\n        return binComponentIndex;\n      }, {});\n\n      if (keys(bins).length === 0) {\n        return null;\n      }\n\n      return new BinNode(parent, bins);\n    }\n    /**\n     * Creates a bin node from BinTransform.\n     * The optional parameter should provide\n     */\n\n  }, {\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, t, model) {\n      var _createBinComponent2 = createBinComponent(t, t.bin, model),\n          key = _createBinComponent2.key,\n          binComponent = _createBinComponent2.binComponent;\n\n      return new BinNode(parent, _defineProperty({}, key, binComponent));\n    }\n  }]);\n\n  return BinNode;\n}(DataFlowNode);","map":null,"metadata":{},"sourceType":"module"}