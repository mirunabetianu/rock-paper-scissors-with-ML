{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar _regeneratorRuntime = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nvar dom_1 = require(\"../util/dom\");\n\nvar utils_1 = require(\"../util/utils\");\n\nvar render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a scatter plot\n *\n * ```js\n * const series1 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 - (Math.random() * 50))\n *   .map((y, x) => ({ x, y, }));\n *\n * const series2 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 - (Math.random() * 150))\n *   .map((y, x) => ({ x, y, }));\n *\n * const series = ['First', 'Second'];\n * const data = { values: [series1, series2], series }\n *\n * const surface = { name: 'Scatterplot', tab: 'Charts' };\n * tfvis.render.scatterplot(surface, data);\n * ```\n *\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\n\nfunction scatterplot(container, data) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var _values, _series, values, drawArea, options, embedOpts, xDomain, yDomain, spec;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _values = data.values;\n            _series = data.series == null ? [] : data.series; // Nest data if necessary before further processing\n\n            _values = Array.isArray(_values[0]) ? _values : [_values];\n            values = [];\n\n            _values.forEach(function (seriesData, i) {\n              var seriesName = _series[i] != null ? _series[i] : \"Series \".concat(i + 1);\n              var seriesVals = seriesData.map(function (v) {\n                return Object.assign({}, v, {\n                  series: seriesName\n                });\n              });\n              values.push.apply(values, _toConsumableArray(seriesVals));\n            });\n\n            if (opts.seriesColors != null) {\n              utils_1.assert(opts.seriesColors.length === _values.length, 'Must have an equal number of series colors as there are data series');\n            }\n\n            drawArea = render_utils_1.getDrawArea(container);\n            options = Object.assign({}, defaultOpts, opts);\n            embedOpts = {\n              actions: false,\n              mode: 'vega-lite',\n              defaultStyle: false\n            };\n\n            xDomain = function xDomain() {\n              if (options.zoomToFit) {\n                return {\n                  'zero': false\n                };\n              } else if (options.xAxisDomain != null) {\n                return {\n                  'domain': options.xAxisDomain\n                };\n              }\n\n              return undefined;\n            };\n\n            yDomain = function yDomain() {\n              if (options.zoomToFit) {\n                return {\n                  'zero': false\n                };\n              } else if (options.yAxisDomain != null) {\n                return {\n                  'domain': options.yAxisDomain\n                };\n              }\n\n              return undefined;\n            };\n\n            spec = {\n              'width': options.width || dom_1.getDefaultWidth(drawArea),\n              'height': options.height || dom_1.getDefaultHeight(drawArea),\n              'padding': 0,\n              'autosize': {\n                'type': 'fit',\n                'contains': 'padding',\n                'resize': true\n              },\n              'config': {\n                'axis': {\n                  'labelFontSize': options.fontSize,\n                  'titleFontSize': options.fontSize\n                },\n                'text': {\n                  'fontSize': options.fontSize\n                },\n                'legend': {\n                  'labelFontSize': options.fontSize,\n                  'titleFontSize': options.fontSize\n                }\n              },\n              'data': {\n                'values': values\n              },\n              'mark': {\n                'type': 'point',\n                'clip': true,\n                'tooltip': {\n                  'content': 'data'\n                }\n              },\n              'encoding': {\n                'x': {\n                  'field': 'x',\n                  'type': options.xType,\n                  'title': options.xLabel,\n                  'scale': xDomain()\n                },\n                'y': {\n                  'field': 'y',\n                  'type': options.yType,\n                  'title': options.yLabel,\n                  'scale': yDomain()\n                },\n                'color': {\n                  'field': 'series',\n                  'type': 'nominal',\n                  'scale': {\n                    'range': options.seriesColors\n                  }\n                },\n                'shape': {\n                  'field': 'series',\n                  'type': 'nominal'\n                }\n              }\n            };\n            _context.next = 14;\n            return vega_embed_1.default(drawArea, spec, embedOpts);\n\n          case 14:\n            return _context.abrupt(\"return\", Promise.resolve());\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.scatterplot = scatterplot;\nvar defaultOpts = {\n  xLabel: 'x',\n  yLabel: 'y',\n  xType: 'quantitative',\n  yType: 'quantitative',\n  zoomToFit: false,\n  fontSize: 11\n};","map":null,"metadata":{},"sourceType":"script"}