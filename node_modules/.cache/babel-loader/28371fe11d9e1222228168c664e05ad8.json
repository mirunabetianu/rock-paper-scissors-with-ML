{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { isArray, isBoolean, isNumber, isString } from 'vega-util';\nimport { isAggregateOp, isArgmaxDef, isArgminDef, isCountingAggregateOp } from './aggregate';\nimport { autoMaxBins, binToString, isBinned, isBinning } from './bin';\nimport { isScaleChannel, isSecondaryRangeChannel, POSITION_SCALE_CHANNELS, rangeType } from './channel';\nimport { getMarkConfig } from './compile/common';\nimport { dateTimeExpr, isDateTime } from './datetime';\nimport * as log from './log';\nimport { isRectBasedMark } from './mark';\nimport { isSortByChannel } from './sort';\nimport { isFacetFieldDef } from './spec/facet';\nimport { getLocalTimeUnit, getTimeUnitParts, isLocalSingleTimeUnit, isUtcSingleTimeUnit, normalizeTimeUnit } from './timeunit';\nimport { getFullName, QUANTITATIVE } from './type';\nimport { contains, flatAccessWithDatum, getFirstDefined, internalField, replacePathInField, titlecase } from './util';\nexport function isConditionalSelection(c) {\n  return c['selection'];\n}\nexport function isRepeatRef(field) {\n  return field && !isString(field) && 'repeat' in field;\n}\nexport function toFieldDefBase(fieldDef) {\n  var field = fieldDef.field,\n      timeUnit = fieldDef.timeUnit,\n      bin = fieldDef.bin,\n      aggregate = fieldDef.aggregate;\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, timeUnit ? {\n    timeUnit: timeUnit\n  } : {}), bin ? {\n    bin: bin\n  } : {}), aggregate ? {\n    aggregate: aggregate\n  } : {}), {\n    field: field\n  });\n}\nexport function isSortableFieldDef(fieldDef) {\n  return isTypedFieldDef(fieldDef) && !!fieldDef['sort'];\n}\nexport function getBand(channel, fieldDef, fieldDef2, mark, config) {\n  var _ref = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {},\n      isMidPoint = _ref.isMidPoint;\n\n  var timeUnit = fieldDef.timeUnit,\n      bin = fieldDef.bin;\n\n  if (contains(['x', 'y'], channel)) {\n    if (isPositionFieldDef(fieldDef) && fieldDef.band !== undefined) {\n      return fieldDef.band;\n    } else if (timeUnit && !fieldDef2) {\n      if (isMidPoint) {\n        return getMarkConfig('timeUnitBandPosition', mark, config);\n      } else {\n        return isRectBasedMark(mark.type) ? getMarkConfig('timeUnitBand', mark, config) : 0;\n      }\n    } else if (isBinning(bin)) {\n      return isRectBasedMark(mark.type) && !isMidPoint ? 1 : 0.5;\n    }\n  }\n\n  return undefined;\n}\nexport function hasBand(channel, fieldDef, fieldDef2, mark, config) {\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === 'temporal') {\n    return !!getBand(channel, fieldDef, fieldDef2, mark, config);\n  }\n\n  return false;\n}\nexport function isConditionalDef(channelDef) {\n  return !!channelDef && !!channelDef.condition;\n}\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\n\nexport function hasConditionalFieldDef(channelDef) {\n  return !!channelDef && !!channelDef.condition && !isArray(channelDef.condition) && isFieldDef(channelDef.condition);\n}\nexport function hasConditionalValueDef(channelDef) {\n  return !!channelDef && !!channelDef.condition && (isArray(channelDef.condition) || isValueDef(channelDef.condition));\n}\nexport function isFieldDef(channelDef) {\n  return !!channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexport function isTypedFieldDef(channelDef) {\n  return !!channelDef && (!!channelDef['field'] && !!channelDef['type'] || channelDef['aggregate'] === 'count');\n}\nexport function isStringFieldDef(channelDef) {\n  return isFieldDef(channelDef) && isString(channelDef.field);\n}\nexport function isValueDef(channelDef) {\n  return channelDef && 'value' in channelDef && channelDef['value'] !== undefined;\n}\nexport function isScaleFieldDef(channelDef) {\n  return !!channelDef && (!!channelDef['scale'] || !!channelDef['sort']);\n}\nexport function isPositionFieldDef(channelDef) {\n  return !!channelDef && (!!channelDef['axis'] || !!channelDef['stack'] || !!channelDef['impute'] || channelDef['band'] !== undefined);\n}\nexport function isMarkPropFieldDef(channelDef) {\n  return !!channelDef && !!channelDef['legend'];\n}\nexport function isTextFieldDef(channelDef) {\n  return !!channelDef && !!channelDef['format'];\n}\n\nfunction isOpFieldDef(fieldDef) {\n  return !!fieldDef['op'];\n}\n/**\n * Get a Vega field reference from a Vega-Lite field def.\n */\n\n\nexport function vgField(fieldDef) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a, _b, _c;\n\n  var field = fieldDef.field;\n  var prefix = opt.prefix;\n  var suffix = opt.suffix;\n  var argAccessor = ''; // for accessing argmin/argmax field at the end without getting escaped\n\n  if (isCount(fieldDef)) {\n    field = internalField('count');\n  } else {\n    var fn;\n\n    if (!opt.nofn) {\n      if (isOpFieldDef(fieldDef)) {\n        fn = fieldDef.op;\n      } else {\n        var bin = fieldDef.bin,\n            aggregate = fieldDef.aggregate,\n            timeUnit = fieldDef.timeUnit;\n\n        if (isBinning(bin)) {\n          fn = binToString(bin);\n          suffix = (_a = opt.binSuffix, _a !== null && _a !== void 0 ? _a : '') + (_b = opt.suffix, _b !== null && _b !== void 0 ? _b : '');\n        } else if (aggregate) {\n          if (isArgmaxDef(aggregate)) {\n            argAccessor = \".\".concat(field);\n            field = \"argmax_\".concat(aggregate.argmax);\n          } else if (isArgminDef(aggregate)) {\n            argAccessor = \".\".concat(field);\n            field = \"argmin_\".concat(aggregate.argmin);\n          } else {\n            fn = String(aggregate);\n          }\n        } else if (timeUnit) {\n          fn = String(timeUnit);\n          suffix = (!contains(['range', 'mid'], opt.binSuffix) && opt.binSuffix || '') + (_c = opt.suffix, _c !== null && _c !== void 0 ? _c : '');\n        }\n      }\n    }\n\n    if (fn) {\n      field = field ? \"\".concat(fn, \"_\").concat(field) : fn;\n    }\n  }\n\n  if (suffix) {\n    field = \"\".concat(field, \"_\").concat(suffix);\n  }\n\n  if (prefix) {\n    field = \"\".concat(prefix, \"_\").concat(field);\n  }\n\n  if (opt.forAs) {\n    return field;\n  } else if (opt.expr) {\n    // Expression to access flattened field. No need to escape dots.\n    return flatAccessWithDatum(field, opt.expr) + argAccessor;\n  } else {\n    // We flattened all fields so paths should have become dot.\n    return replacePathInField(field) + argAccessor;\n  }\n}\nexport function isDiscrete(fieldDef) {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n    case 'geojson':\n      return true;\n\n    case 'quantitative':\n      return !!fieldDef.bin;\n\n    case 'temporal':\n      return false;\n  }\n\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\nexport function isContinuous(fieldDef) {\n  return !isDiscrete(fieldDef);\n}\nexport function isCount(fieldDef) {\n  return fieldDef.aggregate === 'count';\n}\nexport function verbalTitleFormatter(fieldDef, config) {\n  var field = fieldDef.field,\n      bin = fieldDef.bin,\n      timeUnit = fieldDef.timeUnit,\n      aggregate = fieldDef.aggregate;\n\n  if (aggregate === 'count') {\n    return config.countTitle;\n  } else if (isBinning(bin)) {\n    return \"\".concat(field, \" (binned)\");\n  } else if (timeUnit) {\n    var units = getTimeUnitParts(timeUnit).join('-');\n    return \"\".concat(field, \" (\").concat(units, \")\");\n  } else if (aggregate) {\n    if (isArgmaxDef(aggregate)) {\n      return \"\".concat(field, \" for max \").concat(aggregate.argmax);\n    } else if (isArgminDef(aggregate)) {\n      return \"\".concat(field, \" for min \").concat(aggregate.argmin);\n    } else {\n      return \"\".concat(titlecase(aggregate), \" of \").concat(field);\n    }\n  }\n\n  return field;\n}\nexport function functionalTitleFormatter(fieldDef) {\n  var aggregate = fieldDef.aggregate,\n      bin = fieldDef.bin,\n      timeUnit = fieldDef.timeUnit,\n      field = fieldDef.field;\n\n  if (isArgmaxDef(aggregate)) {\n    return \"\".concat(field, \" for argmax(\").concat(aggregate.argmax, \")\");\n  } else if (isArgminDef(aggregate)) {\n    return \"\".concat(field, \" for argmin(\").concat(aggregate.argmin, \")\");\n  }\n\n  var fn = aggregate || timeUnit || isBinning(bin) && 'bin';\n\n  if (fn) {\n    return fn.toUpperCase() + '(' + field + ')';\n  } else {\n    return field;\n  }\n}\nexport var defaultTitleFormatter = function defaultTitleFormatter(fieldDef, config) {\n  switch (config.fieldTitle) {\n    case 'plain':\n      return fieldDef.field;\n\n    case 'functional':\n      return functionalTitleFormatter(fieldDef);\n\n    default:\n      return verbalTitleFormatter(fieldDef, config);\n  }\n};\nvar titleFormatter = defaultTitleFormatter;\nexport function setTitleFormatter(formatter) {\n  titleFormatter = formatter;\n}\nexport function resetTitleFormatter() {\n  setTitleFormatter(defaultTitleFormatter);\n}\nexport function title(fieldDef, config, _ref2) {\n  var allowDisabling = _ref2.allowDisabling,\n      _ref2$includeDefault = _ref2.includeDefault,\n      includeDefault = _ref2$includeDefault === void 0 ? true : _ref2$includeDefault;\n\n  var _a, _b;\n\n  var guide = (_a = getGuide(fieldDef), _a !== null && _a !== void 0 ? _a : {});\n  var guideTitle = guide.title;\n  var def = includeDefault ? defaultTitle(fieldDef, config) : undefined;\n\n  if (allowDisabling) {\n    return getFirstDefined(guideTitle, fieldDef.title, def);\n  } else {\n    return _b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title, _b !== null && _b !== void 0 ? _b : def;\n  }\n}\nexport function getGuide(fieldDef) {\n  if (isPositionFieldDef(fieldDef) && fieldDef.axis) {\n    return fieldDef.axis;\n  } else if (isMarkPropFieldDef(fieldDef) && fieldDef.legend) {\n    return fieldDef.legend;\n  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {\n    return fieldDef.header;\n  }\n\n  return undefined;\n}\nexport function defaultTitle(fieldDef, config) {\n  return titleFormatter(fieldDef, config);\n}\nexport function format(fieldDef) {\n  var _a;\n\n  if (isTextFieldDef(fieldDef) && fieldDef.format) {\n    return fieldDef.format;\n  } else {\n    var guide = (_a = getGuide(fieldDef), _a !== null && _a !== void 0 ? _a : {});\n    return guide.format;\n  }\n}\nexport function defaultType(fieldDef, channel) {\n  if (fieldDef.timeUnit) {\n    return 'temporal';\n  }\n\n  if (isBinning(fieldDef.bin)) {\n    return 'quantitative';\n  }\n\n  switch (rangeType(channel)) {\n    case 'continuous':\n      return 'quantitative';\n\n    case 'discrete':\n      return 'nominal';\n\n    case 'flexible':\n      // color\n      return 'nominal';\n\n    default:\n      return 'quantitative';\n  }\n}\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\n\nexport function getFieldDef(channelDef) {\n  if (isFieldDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldDef(channelDef)) {\n    return channelDef.condition;\n  }\n\n  return undefined;\n}\nexport function getTypedFieldDef(channelDef) {\n  if (isFieldDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldDef(channelDef)) {\n    return channelDef.condition;\n  }\n\n  return undefined;\n}\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\n\nexport function normalize(channelDef, channel) {\n  if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {\n    var primitiveType = isString(channelDef) ? 'string' : isNumber(channelDef) ? 'number' : 'boolean';\n    log.warn(log.message.primitiveChannelDef(channel, primitiveType, channelDef));\n    return {\n      value: channelDef\n    };\n  } // If a fieldDef contains a field, we need type.\n\n\n  if (isFieldDef(channelDef)) {\n    return normalizeFieldDef(channelDef, channel);\n  } else if (hasConditionalFieldDef(channelDef)) {\n    return Object.assign(Object.assign({}, channelDef), {\n      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n      condition: normalizeFieldDef(channelDef.condition, channel)\n    });\n  }\n\n  return channelDef;\n}\nexport function normalizeFieldDef(fd, channel) {\n  var aggregate = fd.aggregate,\n      timeUnit = fd.timeUnit,\n      bin = fd.bin,\n      field = fd.field;\n  var fieldDef = Object.assign({}, fd); // Drop invalid aggregate\n\n  if (aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {\n    log.warn(log.message.invalidAggregate(aggregate));\n    delete fieldDef.aggregate;\n  } // Normalize Time Unit\n\n\n  if (timeUnit) {\n    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);\n  }\n\n  if (field) {\n    fieldDef.field = \"\".concat(field);\n  } // Normalize bin\n\n\n  if (isBinning(bin)) {\n    fieldDef.bin = normalizeBin(bin, channel);\n  }\n\n  if (isBinned(bin) && !contains(POSITION_SCALE_CHANNELS, channel)) {\n    log.warn(\"Channel \".concat(channel, \" should not be used with \\\"binned\\\" bin\"));\n  } // Normalize Type\n\n\n  if (isTypedFieldDef(fieldDef)) {\n    var type = fieldDef.type;\n    var fullType = getFullName(type);\n\n    if (type !== fullType) {\n      // convert short type to full type\n      fieldDef.type = fullType;\n    }\n\n    if (type !== 'quantitative') {\n      if (isCountingAggregateOp(aggregate)) {\n        log.warn(log.message.invalidFieldTypeForCountAggregate(type, aggregate));\n        fieldDef.type = 'quantitative';\n      }\n    }\n  } else if (!isSecondaryRangeChannel(channel)) {\n    // If type is empty / invalid, then augment with default type\n    var newType = defaultType(fieldDef, channel);\n    log.warn(log.message.missingFieldType(channel, newType));\n    fieldDef['type'] = newType;\n  }\n\n  if (isTypedFieldDef(fieldDef)) {\n    var _channelCompatibility = channelCompatibility(fieldDef, channel),\n        compatible = _channelCompatibility.compatible,\n        warning = _channelCompatibility.warning;\n\n    if (!compatible) {\n      log.warn(warning);\n    }\n  }\n\n  if (isSortableFieldDef(fieldDef) && isString(fieldDef.sort)) {\n    var sort = fieldDef.sort;\n\n    if (isSortByChannel(sort)) {\n      return Object.assign(Object.assign({}, fieldDef), {\n        sort: {\n          encoding: sort\n        }\n      });\n    }\n\n    var sub = sort.substr(1);\n\n    if (sort.charAt(0) === '-' && isSortByChannel(sub)) {\n      return Object.assign(Object.assign({}, fieldDef), {\n        sort: {\n          encoding: sub,\n          order: 'descending'\n        }\n      });\n    }\n  }\n\n  return fieldDef;\n}\nexport function normalizeBin(bin, channel) {\n  if (isBoolean(bin)) {\n    return {\n      maxbins: autoMaxBins(channel)\n    };\n  } else if (bin === 'binned') {\n    return {\n      binned: true\n    };\n  } else if (!bin.maxbins && !bin.step) {\n    return Object.assign(Object.assign({}, bin), {\n      maxbins: autoMaxBins(channel)\n    });\n  } else {\n    return bin;\n  }\n}\nvar COMPATIBLE = {\n  compatible: true\n};\nexport function channelCompatibility(fieldDef, channel) {\n  var type = fieldDef.type;\n\n  if (type === 'geojson' && channel !== 'shape') {\n    return {\n      compatible: false,\n      warning: \"Channel \".concat(channel, \" should not be used with a geojson data.\")\n    };\n  }\n\n  switch (channel) {\n    case 'row':\n    case 'column':\n    case 'facet':\n      if (isContinuous(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.facetChannelShouldBeDiscrete(channel)\n        };\n      }\n\n      return COMPATIBLE;\n\n    case 'x':\n    case 'y':\n    case 'color':\n    case 'fill':\n    case 'stroke':\n    case 'text':\n    case 'detail':\n    case 'key':\n    case 'tooltip':\n    case 'href':\n    case 'url':\n      return COMPATIBLE;\n\n    case 'longitude':\n    case 'longitude2':\n    case 'latitude':\n    case 'latitude2':\n      if (type !== QUANTITATIVE) {\n        return {\n          compatible: false,\n          warning: \"Channel \".concat(channel, \" should be used with a quantitative field only, not \").concat(fieldDef.type, \" field.\")\n        };\n      }\n\n      return COMPATIBLE;\n\n    case 'opacity':\n    case 'fillOpacity':\n    case 'strokeOpacity':\n    case 'strokeWidth':\n    case 'size':\n    case 'x2':\n    case 'y2':\n      if (type === 'nominal' && !fieldDef['sort']) {\n        return {\n          compatible: false,\n          warning: \"Channel \".concat(channel, \" should not be used with an unsorted discrete field.\")\n        };\n      }\n\n      return COMPATIBLE;\n\n    case 'shape':\n      if (!contains(['ordinal', 'nominal', 'geojson'], fieldDef.type)) {\n        return {\n          compatible: false,\n          warning: 'Shape channel should be used with only either discrete or geojson data.'\n        };\n      }\n\n      return COMPATIBLE;\n\n    case 'order':\n      if (fieldDef.type === 'nominal' && !('sort' in fieldDef)) {\n        return {\n          compatible: false,\n          warning: \"Channel order is inappropriate for nominal field, which has no inherent order.\"\n        };\n      }\n\n      return COMPATIBLE;\n  }\n\n  throw new Error('channelCompatability not implemented for channel ' + channel);\n}\n/**\n * Check if the field def uses a time format or does not use any format but is temporal\n * (this does not cover field defs that are temporal but use a number format).\n */\n\nexport function isTimeFormatFieldDef(fieldDef) {\n  var guide = getGuide(fieldDef);\n  var formatType = guide && guide.formatType || isTextFieldDef(fieldDef) && fieldDef.formatType;\n  return formatType === 'time' || !formatType && isTimeFieldDef(fieldDef);\n}\n/**\n * Check if field def has tye `temporal`. If you want to also cover field defs that use a time format, use `isTimeFormatFieldDef`.\n */\n\nexport function isTimeFieldDef(fieldDef) {\n  return fieldDef.type === 'temporal' || !!fieldDef.timeUnit;\n}\n/**\n * Getting a value associated with a fielddef.\n * Convert the value to Vega expression if applicable (for datetime object, or string if the field def is temporal or has timeUnit)\n */\n\nexport function valueExpr(v, _ref3) {\n  var timeUnit = _ref3.timeUnit,\n      type = _ref3.type,\n      time = _ref3.time,\n      undefinedIfExprNotRequired = _ref3.undefinedIfExprNotRequired;\n  var expr;\n\n  if (isDateTime(v)) {\n    expr = dateTimeExpr(v, true);\n  } else if (isString(v) || isNumber(v)) {\n    if (timeUnit || type === 'temporal') {\n      if (isLocalSingleTimeUnit(timeUnit)) {\n        expr = dateTimeExpr(_defineProperty({}, timeUnit, v), true);\n      } else if (isUtcSingleTimeUnit(timeUnit)) {\n        // FIXME is this really correct?\n        expr = valueExpr(v, {\n          timeUnit: getLocalTimeUnit(timeUnit)\n        });\n      } else {\n        // just pass the string to date function (which will call JS Date.parse())\n        expr = \"datetime(\".concat(JSON.stringify(v), \")\");\n      }\n    }\n  }\n\n  if (expr) {\n    return time ? \"time(\".concat(expr, \")\") : expr;\n  } // number or boolean or normal string\n\n\n  return undefinedIfExprNotRequired ? undefined : JSON.stringify(v);\n}\n/**\n * Standardize value array -- convert each value to Vega expression if applicable\n */\n\nexport function valueArray(fieldDef, values) {\n  var timeUnit = fieldDef.timeUnit,\n      type = fieldDef.type;\n  return values.map(function (v) {\n    var expr = valueExpr(v, {\n      timeUnit: timeUnit,\n      type: type,\n      undefinedIfExprNotRequired: true\n    }); // return signal for the expression if we need an expression\n\n    if (expr !== undefined) {\n      return {\n        signal: expr\n      };\n    } // otherwise just return the original value\n\n\n    return v;\n  });\n}\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\n\nexport function binRequiresRange(fieldDef, channel) {\n  if (!isBinning(fieldDef.bin)) {\n    console.warn('Only use this method with binned field defs');\n    return false;\n  } // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n  // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n\n\n  return isScaleChannel(channel) && contains(['ordinal', 'nominal'], fieldDef.type);\n}","map":null,"metadata":{},"sourceType":"module"}