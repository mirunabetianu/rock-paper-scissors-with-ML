{"ast":null,"code":"import _slicedToArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport ols from './ols';\nimport { points } from './points';\nimport { median } from 'd3-array';\nvar maxiters = 2,\n    epsilon = 1e-12; // Adapted from science.js by Jason Davies\n// Source: https://github.com/jasondavies/science.js/blob/master/src/stats/loess.js\n// License: https://github.com/jasondavies/science.js/blob/master/LICENSE\n\nexport default function (data, x, y, bandwidth) {\n  var _points = points(data, x, y, true),\n      _points2 = _slicedToArray(_points, 4),\n      xv = _points2[0],\n      yv = _points2[1],\n      ux = _points2[2],\n      uy = _points2[3],\n      n = xv.length,\n      bw = Math.max(2, ~~(bandwidth * n)),\n      yhat = new Float64Array(n),\n      residuals = new Float64Array(n),\n      robustWeights = new Float64Array(n).fill(1);\n\n  for (var iter = -1; ++iter <= maxiters;) {\n    var interval = [0, bw - 1];\n\n    for (var i = 0; i < n; ++i) {\n      var dx = xv[i],\n          i0 = interval[0],\n          i1 = interval[1],\n          edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;\n      var W = 0,\n          X = 0,\n          Y = 0,\n          XY = 0,\n          X2 = 0,\n          denom = 1 / Math.abs(xv[edge] - dx || 1); // avoid singularity!\n\n      for (var k = i0; k <= i1; ++k) {\n        var xk = xv[k],\n            yk = yv[k],\n            w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],\n            xkw = xk * w;\n        W += w;\n        X += xkw;\n        Y += yk * w;\n        XY += yk * xkw;\n        X2 += xk * xkw;\n      } // linear regression fit\n\n\n      var _ols = ols(X / W, Y / W, XY / W, X2 / W),\n          _ols2 = _slicedToArray(_ols, 2),\n          a = _ols2[0],\n          b = _ols2[1];\n\n      yhat[i] = a + b * dx;\n      residuals[i] = Math.abs(yv[i] - yhat[i]);\n      updateInterval(xv, i + 1, interval);\n    }\n\n    if (iter === maxiters) {\n      break;\n    }\n\n    var medianResidual = median(residuals);\n    if (Math.abs(medianResidual) < epsilon) break;\n\n    for (var _i = 0, arg, _w; _i < n; ++_i) {\n      arg = residuals[_i] / (6 * medianResidual); // default to epsilon (rather than zero) for large deviations\n      // keeping weights tiny but non-zero prevents singularites\n\n      robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;\n    }\n  }\n\n  return output(xv, yhat, ux, uy);\n} // weighting kernel for local regression\n\nfunction tricube(x) {\n  return (x = 1 - x * x * x) * x * x;\n} // advance sliding window interval of nearest neighbors\n\n\nfunction updateInterval(xv, i, interval) {\n  var val = xv[i],\n      left = interval[0],\n      right = interval[1] + 1;\n  if (right >= xv.length) return; // step right if distance to new right edge is <= distance to old left edge\n  // step when distance is equal to ensure movement over duplicate x values\n\n  while (i > left && xv[right] - val <= val - xv[left]) {\n    interval[0] = ++left;\n    interval[1] = right;\n    ++right;\n  }\n} // generate smoothed output points\n// average points with repeated x values\n\n\nfunction output(xv, yhat, ux, uy) {\n  var n = xv.length,\n      out = [];\n  var i = 0,\n      cnt = 0,\n      prev = [],\n      v;\n\n  for (; i < n; ++i) {\n    v = xv[i] + ux;\n\n    if (prev[0] === v) {\n      // average output values via online update\n      prev[1] += (yhat[i] - prev[1]) / ++cnt;\n    } else {\n      // add new output point\n      cnt = 0;\n      prev[1] += uy;\n      prev = [v, yhat[i]];\n      out.push(prev);\n    }\n  }\n\n  prev[1] += uy;\n  return out;\n}","map":null,"metadata":{},"sourceType":"module"}