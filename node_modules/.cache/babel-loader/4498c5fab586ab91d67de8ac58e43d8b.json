{"ast":null,"code":"import { isBinning } from '../../bin';\nimport { X, Y } from '../../channel';\nimport { isDiscrete, valueArray } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { NOMINAL, ORDINAL } from '../../type';\nimport { contains, normalizeAngle } from '../../util';\nimport { getAxisConfig } from './config'; // TODO: we need to refactor this method after we take care of config refactoring\n\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\n\nexport function defaultGrid(scaleType, fieldDef) {\n  return !hasDiscreteDomain(scaleType) && !isBinning(fieldDef.bin);\n}\nexport function gridScale(model, channel) {\n  var gridChannel = channel === 'x' ? 'y' : 'x';\n\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n\n  return undefined;\n}\nexport function labelAngle(model, specifiedAxis, channel, fieldDef) {\n  // try axis value\n  if (specifiedAxis.labelAngle !== undefined) {\n    return normalizeAngle(specifiedAxis.labelAngle);\n  } else {\n    // try axis config value\n    var angle = getAxisConfig('labelAngle', model.config, channel, orient(channel), model.getScaleComponent(channel).get('type'));\n\n    if (angle !== undefined) {\n      return normalizeAngle(angle);\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldDef.type)) {\n        return 270;\n      } // no default\n\n\n      return undefined;\n    }\n  }\n}\nexport function defaultLabelBaseline(angle, axisOrient) {\n  if (angle !== undefined) {\n    angle = normalizeAngle(angle);\n\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle <= 45 || 315 <= angle) {\n        return axisOrient === 'top' ? 'bottom' : 'top';\n      } else if (135 <= angle && angle <= 225) {\n        return axisOrient === 'top' ? 'top' : 'bottom';\n      } else {\n        return 'middle';\n      }\n    } else {\n      if (angle <= 45 || 315 <= angle || 135 <= angle && angle <= 225) {\n        return 'middle';\n      } else if (45 <= angle && angle <= 135) {\n        return axisOrient === 'left' ? 'top' : 'bottom';\n      } else {\n        return axisOrient === 'left' ? 'bottom' : 'top';\n      }\n    }\n  }\n\n  return undefined;\n}\nexport function defaultLabelAlign(angle, axisOrient) {\n  if (angle !== undefined) {\n    angle = normalizeAngle(angle);\n\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle % 180 === 0) {\n        return 'center';\n      } else if (0 < angle && angle < 180) {\n        return axisOrient === 'top' ? 'right' : 'left';\n      } else {\n        return axisOrient === 'top' ? 'left' : 'right';\n      }\n    } else {\n      if ((angle + 90) % 180 === 0) {\n        return 'center';\n      } else if (90 <= angle && angle < 270) {\n        return axisOrient === 'left' ? 'left' : 'right';\n      } else {\n        return axisOrient === 'left' ? 'right' : 'left';\n      }\n    }\n  }\n\n  return undefined;\n}\nexport function defaultLabelFlush(fieldDef, channel) {\n  if (channel === 'x' && contains(['quantitative', 'temporal'], fieldDef.type)) {\n    return true;\n  }\n\n  return undefined;\n}\nexport function defaultLabelOverlap(fieldDef, scaleType) {\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (fieldDef.type !== 'nominal') {\n    if (scaleType === 'log') {\n      return 'greedy';\n    }\n\n    return true;\n  }\n\n  return undefined;\n}\nexport function orient(channel) {\n  switch (channel) {\n    case X:\n      return 'bottom';\n\n    case Y:\n      return 'left';\n  }\n  /* istanbul ignore next: This should never happen. */\n\n\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\nexport function defaultTickCount(_ref) {\n  var fieldDef = _ref.fieldDef,\n      scaleType = _ref.scaleType,\n      size = _ref.size;\n\n  if (!hasDiscreteDomain(scaleType) && scaleType !== 'log' && !contains(['month', 'hours', 'day', 'quarter'], fieldDef.timeUnit)) {\n    if (isBinning(fieldDef.bin)) {\n      // for binned data, we don't want more ticks than maxbins\n      return {\n        signal: \"ceil(\".concat(size.signal, \"/10)\")\n      };\n    }\n\n    return {\n      signal: \"ceil(\".concat(size.signal, \"/40)\")\n    };\n  }\n\n  return undefined;\n}\nexport function values(specifiedAxis, model, fieldDef) {\n  var vals = specifiedAxis.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n\n  return undefined;\n}\nexport function defaultZindex(mark, fieldDef) {\n  if (mark === 'rect' && isDiscrete(fieldDef)) {\n    return 1;\n  }\n\n  return 0;\n}","map":null,"metadata":{},"sourceType":"module"}