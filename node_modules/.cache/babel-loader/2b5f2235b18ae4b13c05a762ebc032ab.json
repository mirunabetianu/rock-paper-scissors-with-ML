{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '..';\nimport { isScaleChannel, X, Y } from '../../../channel';\nimport * as log from '../../../log';\nimport { hasContinuousDomain } from '../../../scale';\nimport { isLayerModel } from '../../model';\nvar scaleBindings = {\n  has: function has(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n  parse: function parse(model, selCmpt) {\n    var bound = selCmpt.scales = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = selCmpt.project.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var proj = _step.value;\n        var channel = proj.channel;\n\n        if (!isScaleChannel(channel)) {\n          continue;\n        }\n\n        var scale = model.getScaleComponent(channel);\n        var scaleType = scale ? scale.get('type') : undefined;\n\n        if (!scale || !hasContinuousDomain(scaleType)) {\n          log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n          continue;\n        }\n\n        var extent = {\n          selection: selCmpt.name,\n          field: proj.field\n        };\n        scale.set('selectionExtent', extent, true);\n        bound.push(proj); // Bind both x/y for diag plot of repeated views.\n\n        if (model.repeater && model.repeater.row === model.repeater.column) {\n          var scale2 = model.getScaleComponent(channel === X ? Y : X);\n          scale2.set('selectionExtent', extent, true);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  },\n  topLevelSignals: function topLevelSignals(model, selCmpt, signals) {\n    var bound = selCmpt.scales.filter(function (proj) {\n      return signals.filter(function (s) {\n        return s.name === proj.signals.data;\n      }).length === 0;\n    }); // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n\n    if (!model.parent || isTopLevelLayer(model) || bound.length === 0) {\n      return signals;\n    } // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n\n\n    var namedSg = signals.filter(function (s) {\n      return s.name === selCmpt.name;\n    })[0];\n    var update = namedSg.update;\n\n    if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n      namedSg.update = \"{\".concat(bound.map(function (proj) {\n        return \"\".concat(stringValue(proj.field), \": \").concat(proj.signals.data);\n      }).join(', '), \"}\");\n    } else {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = bound[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var proj = _step2.value;\n          var mapping = \"\".concat(stringValue(proj.field), \": \").concat(proj.signals.data);\n\n          if (update.indexOf(mapping) < 0) {\n            update = \"\".concat(update.substring(0, update.length - 1), \", \").concat(mapping, \"}\");\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      namedSg.update = update;\n    }\n\n    return signals.concat(bound.map(function (proj) {\n      return {\n        name: proj.signals.data\n      };\n    }));\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var proj = _step3.value;\n\n          var signal = _signals.filter(function (s) {\n            return s.name === proj.signals.data;\n          })[0];\n\n          signal.push = 'outer';\n          delete signal.value;\n          delete signal.update;\n        };\n\n        for (var _iterator3 = selCmpt.scales[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          _loop();\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n\n    return _signals;\n  }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n  var scale = stringValue(model.scaleName(channel));\n  return \"domain(\".concat(scale, \")\");\n}\n\nfunction isTopLevelLayer(model) {\n  var _a;\n\n  return model.parent && isLayerModel(model.parent) && (_a = !model.parent.parent, _a !== null && _a !== void 0 ? _a : isTopLevelLayer(model.parent.parent));\n}","map":null,"metadata":{},"sourceType":"module"}