{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { extractTransformsFromEncoding } from './encoding';\nimport { SpecMapper } from './spec/map';\n\nvar TransformExtractMapper =\n/*#__PURE__*/\nfunction (_SpecMapper) {\n  _inherits(TransformExtractMapper, _SpecMapper);\n\n  function TransformExtractMapper() {\n    _classCallCheck(this, TransformExtractMapper);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TransformExtractMapper).apply(this, arguments));\n  }\n\n  _createClass(TransformExtractMapper, [{\n    key: \"mapUnit\",\n    value: function mapUnit(spec, _ref) {\n      var config = _ref.config;\n\n      if (spec.encoding) {\n        var oldEncoding = spec.encoding,\n            oldTransforms = spec.transform;\n\n        var _extractTransformsFro = extractTransformsFromEncoding(oldEncoding, config),\n            bins = _extractTransformsFro.bins,\n            timeUnits = _extractTransformsFro.timeUnits,\n            aggregate = _extractTransformsFro.aggregate,\n            groupby = _extractTransformsFro.groupby,\n            encoding = _extractTransformsFro.encoding;\n\n        var transform = [].concat(_toConsumableArray(oldTransforms ? oldTransforms : []), _toConsumableArray(bins), _toConsumableArray(timeUnits), _toConsumableArray(aggregate.length === 0 ? [] : [{\n          aggregate: aggregate,\n          groupby: groupby\n        }]));\n        return Object.assign(Object.assign(Object.assign({}, spec), transform.length > 0 ? {\n          transform: transform\n        } : {}), {\n          encoding: encoding\n        });\n      } else {\n        return spec;\n      }\n    }\n  }]);\n\n  return TransformExtractMapper;\n}(SpecMapper);\n\nvar extractor = new TransformExtractMapper();\n/**\n * Modifies spec extracting transformations from encoding and moving them to the transforms array\n */\n\nexport function extractTransforms(spec, config) {\n  return extractor.map(spec, {\n    config: config\n  });\n}","map":null,"metadata":{},"sourceType":"module"}