{"ast":null,"code":"import { array, isArray, isObject, isString, stringValue } from 'vega-util';\nimport { isBinned } from '../../../bin';\nimport { getMainRangeChannel } from '../../../channel';\nimport { format, getFieldDef, hasConditionalFieldDef, isFieldDef, isTypedFieldDef, title, vgField } from '../../../channeldef';\nimport { forEach } from '../../../encoding';\nimport { getFirstDefined } from '../../../util';\nimport { binFormatExpression, getMarkConfig } from '../../common';\nimport { wrapCondition } from './conditional';\nimport { textRef } from './text';\nexport function tooltip(model) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var encoding = model.encoding,\n      markDef = model.markDef,\n      config = model.config;\n  var channelDef = encoding.tooltip;\n\n  if (isArray(channelDef)) {\n    return {\n      tooltip: tooltipRefForEncoding({\n        tooltip: channelDef\n      }, config, opt)\n    };\n  } else {\n    return wrapCondition(model, channelDef, 'tooltip', function (cDef) {\n      // use valueRef based on channelDef first\n      var tooltipRefFromChannelDef = textRef(cDef, model.config, opt.reactiveGeom ? 'datum.datum' : 'datum');\n\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      } // If tooltipDef does not exist, then use value from markDef or config\n\n\n      var markTooltip = getFirstDefined(markDef.tooltip, getMarkConfig('tooltip', markDef, config));\n\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (markTooltip.content === 'encoding') {\n          return tooltipRefForEncoding(encoding, config, opt);\n        } else {\n          return {\n            signal: 'datum'\n          };\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\nexport function tooltipRefForEncoding(encoding, config) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      reactiveGeom = _ref.reactiveGeom;\n\n  var keyValues = [];\n  var usedKey = {};\n  var toSkip = {};\n  var expr = reactiveGeom ? 'datum.datum' : 'datum';\n  var tooltipTuples = [];\n\n  function add(fDef, channel) {\n    var mainChannel = getMainRangeChannel(channel);\n    var fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n\n    });\n    var key = array(title(fieldDef, config, {\n      allowDisabling: false\n    })).join(', ');\n    var value = textRef(fieldDef, config, expr).signal;\n\n    if (channel === 'x' || channel === 'y') {\n      var channel2 = channel === 'x' ? 'x2' : 'y2';\n      var fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        var startField = vgField(fieldDef, {\n          expr: expr\n        });\n        var endField = vgField(fieldDef2, {\n          expr: expr\n        });\n        value = binFormatExpression(startField, endField, format(fieldDef), config);\n        toSkip[channel2] = true;\n      }\n    }\n\n    tooltipTuples.push({\n      channel: channel,\n      key: key,\n      value: value\n    });\n  }\n\n  forEach(encoding, function (channelDef, channel) {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n\n  for (var _i = 0, _tooltipTuples = tooltipTuples; _i < _tooltipTuples.length; _i++) {\n    var _tooltipTuples$_i = _tooltipTuples[_i],\n        channel = _tooltipTuples$_i.channel,\n        key = _tooltipTuples$_i.key,\n        value = _tooltipTuples$_i.value;\n\n    if (!toSkip[channel] && !usedKey[key]) {\n      keyValues.push(\"\".concat(stringValue(key), \": \").concat(value));\n      usedKey[key] = true;\n    }\n  }\n\n  return keyValues.length > 0 ? {\n    signal: \"{\".concat(keyValues.join(', '), \"}\")\n  } : undefined;\n}","map":null,"metadata":{},"sourceType":"module"}