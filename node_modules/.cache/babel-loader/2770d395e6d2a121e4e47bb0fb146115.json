{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { isNumber } from 'vega-util';\nimport { isBinned, isBinning } from '../../../bin';\nimport { X, X2, Y2 } from '../../../channel';\nimport { getBand, getTypedFieldDef, isFieldDef, isPositionFieldDef, isValueDef } from '../../../channeldef';\nimport { DEFAULT_STEP, getViewConfigDiscreteStep } from '../../../config';\nimport * as log from '../../../log';\nimport { hasDiscreteDomain, ScaleType } from '../../../scale';\nimport { getFirstDefined } from '../../../util';\nimport { isVgRangeStep } from '../../../vega.schema';\nimport { getMarkConfig } from '../../common';\nimport { nonPosition } from './nonposition';\nimport { alignedPositionChannel } from './position-align';\nimport { pointPosition } from './position-point';\nimport { rangePosition } from './position-range';\nimport * as ref from './valueref';\nexport function rectPosition(model, channel, mark) {\n  var _a, _b, _c, _d;\n\n  var config = model.config,\n      encoding = model.encoding,\n      markDef = model.markDef;\n  var channel2 = channel === 'x' ? 'x2' : 'y2';\n  var sizeChannel = channel === 'x' ? 'width' : 'height';\n  var fieldDef = encoding[channel];\n  var fieldDef2 = encoding[channel2];\n  var scale = model.getScaleComponent(channel);\n  var scaleType = scale ? scale.get('type') : undefined;\n  var scaleName = model.scaleName(channel);\n  var orient = markDef.orient;\n  var hasSizeDef = (_d = (_c = (_b = (_a = encoding[sizeChannel], _a !== null && _a !== void 0 ? _a : encoding.size), _b !== null && _b !== void 0 ? _b : markDef[sizeChannel]), _c !== null && _c !== void 0 ? _c : markDef.size), _d !== null && _d !== void 0 ? _d : getMarkConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  }));\n  var isBarBand = channel === 'x' ? orient === 'vertical' : orient === 'horizontal'; // x, x2, and width -- we must specify two of these in all conditions\n\n  if (isFieldDef(fieldDef) && (isBinning(fieldDef.bin) || isBinned(fieldDef.bin) || fieldDef.timeUnit && !fieldDef2) && !hasSizeDef && !hasDiscreteDomain(scaleType)) {\n    var band = getBand(channel, fieldDef, undefined, markDef, config);\n    return rectBinPosition({\n      fieldDef: fieldDef,\n      fieldDef2: fieldDef2,\n      channel: channel,\n      markDef: markDef,\n      scaleName: scaleName,\n      band: band,\n      spacing: getFirstDefined(markDef.binSpacing, config[mark].binSpacing),\n      reverse: scale.get('reverse')\n    });\n  } else if ((isFieldDef(fieldDef) && hasDiscreteDomain(scaleType) || isBarBand) && !fieldDef2) {\n    // vertical\n    if (isFieldDef(fieldDef) && scaleType === ScaleType.BAND) {\n      var _band = isPositionFieldDef(fieldDef) ? fieldDef.band : undefined;\n\n      return rectBandPosition(fieldDef, channel, model, defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config, _band));\n    } // sized bin, normal point-ordinal axis, quantitative x-axis, or no x\n\n\n    return centeredPointPositionWithSize(channel, model, defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config));\n  } else {\n    return rangePosition(channel, model, {\n      defaultPos: 'zeroOrMax',\n      defaultPos2: 'zeroOrMin'\n    });\n  }\n}\n\nfunction centeredPointPositionWithSize(channel, model, sizeRef) {\n  var centerChannel = channel === 'x' ? 'xc' : 'yc';\n  var sizeChannel = channel === 'x' ? 'width' : 'height';\n  return Object.assign(Object.assign({}, pointPosition(channel, model, {\n    defaultPos: 'mid',\n    vgChannel: centerChannel\n  })), nonPosition('size', model, {\n    defaultRef: sizeRef,\n    vgChannel: sizeChannel\n  }));\n}\n\nfunction defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config, band) {\n  var markPropOrConfig = getFirstDefined(markDef[sizeChannel], markDef.size, // TODO: deal with sizeChannel config\n  getMarkConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  }));\n\n  if (markPropOrConfig !== undefined) {\n    return {\n      value: markPropOrConfig\n    };\n  }\n\n  if (scale) {\n    var scaleType = scale.get('type');\n\n    if (scaleType === 'point' || scaleType === 'band') {\n      if (config[mark].discreteBandSize !== undefined) {\n        return {\n          value: config[mark].discreteBandSize\n        };\n      }\n\n      if (scaleType === ScaleType.POINT) {\n        var scaleRange = scale.get('range');\n\n        if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n          return {\n            value: scaleRange.step - 2\n          };\n        }\n\n        return {\n          value: DEFAULT_STEP - 2\n        };\n      } else {\n        // BAND\n        return bandRef(scaleName, band);\n      }\n    } else {\n      // continuous scale\n      return {\n        value: config[mark].continuousBandSize\n      };\n    }\n  } // No Scale\n\n\n  var step = getViewConfigDiscreteStep(config.view, sizeChannel);\n  var value = getFirstDefined( // No scale is like discrete bar (with one item)\n  config[mark].discreteBandSize, step - 2);\n  return {\n    value: value\n  };\n}\n\nfunction bandRef(scaleName) {\n  var band = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\nfunction rectBandPosition(fieldDef, channel, model, sizeRef) {\n  var _ref;\n\n  var _a;\n\n  var scaleName = model.scaleName(channel);\n  var sizeChannel = channel === 'x' ? 'width' : 'height';\n  var markDef = model.markDef,\n      encoding = model.encoding,\n      config = model.config;\n  var vgChannel = alignedPositionChannel(channel, markDef, config);\n\n  var centeredBandPositionMixins = _defineProperty({}, vgChannel, ref.fieldRef(fieldDef, scaleName, {}, {\n    band: 0.5\n  }));\n\n  if (encoding.size || markDef.size !== null && markDef.size !== undefined) {\n    var orient = markDef.orient;\n\n    if (orient) {\n      if (getTypedFieldDef(encoding.size) || isValueDef(encoding.size)) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), nonPosition('size', model, {\n          vgChannel: sizeChannel\n        }));\n      } else if (markDef.size !== undefined) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), _defineProperty({}, sizeChannel, {\n          value: markDef.size\n        }));\n      }\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(markDef.type));\n    }\n  }\n\n  if (((_a = sizeRef) === null || _a === void 0 ? void 0 : _a.value) !== undefined) {\n    return Object.assign(Object.assign({}, centeredBandPositionMixins), _defineProperty({}, sizeChannel, sizeRef));\n  }\n\n  var _fieldDef$band = fieldDef.band,\n      band = _fieldDef$band === void 0 ? 1 : _fieldDef$band;\n  return _ref = {}, _defineProperty(_ref, channel, ref.fieldRef(fieldDef, scaleName, {\n    binSuffix: 'range'\n  }, {\n    band: (1 - band) / 2\n  })), _defineProperty(_ref, sizeChannel, sizeRef !== null && sizeRef !== void 0 ? sizeRef : bandRef(scaleName, band)), _ref;\n}\n\nexport function rectBinPosition(_ref2) {\n  var fieldDef = _ref2.fieldDef,\n      fieldDef2 = _ref2.fieldDef2,\n      channel = _ref2.channel,\n      band = _ref2.band,\n      scaleName = _ref2.scaleName,\n      markDef = _ref2.markDef,\n      _ref2$spacing = _ref2.spacing,\n      spacing = _ref2$spacing === void 0 ? 0 : _ref2$spacing,\n      reverse = _ref2.reverse;\n  var binSpacing = {\n    x: reverse ? spacing : 0,\n    x2: reverse ? 0 : spacing,\n    y: reverse ? 0 : spacing,\n    y2: reverse ? spacing : 0\n  };\n  var channel2 = channel === X ? X2 : Y2;\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    var _ref3;\n\n    return _ref3 = {}, _defineProperty(_ref3, channel2, rectBinRef({\n      channel: channel,\n      fieldDef: fieldDef,\n      scaleName: scaleName,\n      markDef: markDef,\n      band: (1 - band) / 2,\n      offset: binSpacing[\"\".concat(channel, \"2\")]\n    })), _defineProperty(_ref3, channel, rectBinRef({\n      channel: channel,\n      fieldDef: fieldDef,\n      scaleName: scaleName,\n      markDef: markDef,\n      band: 1 - (1 - band) / 2,\n      offset: binSpacing[channel]\n    })), _ref3;\n  } else if (isBinned(fieldDef.bin) && isFieldDef(fieldDef2)) {\n    var _ref4;\n\n    return _ref4 = {}, _defineProperty(_ref4, channel2, ref.fieldRef(fieldDef, scaleName, {}, {\n      offset: binSpacing[\"\".concat(channel, \"2\")]\n    })), _defineProperty(_ref4, channel, ref.fieldRef(fieldDef2, scaleName, {}, {\n      offset: binSpacing[channel]\n    })), _ref4;\n  } else {\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n  }\n}\n/**\n * Value Ref for binned fields\n */\n\nexport function rectBinRef(_ref5) {\n  var channel = _ref5.channel,\n      fieldDef = _ref5.fieldDef,\n      scaleName = _ref5.scaleName,\n      markDef = _ref5.markDef,\n      band = _ref5.band,\n      offset = _ref5.offset;\n  var r = ref.interpolatedSignalRef({\n    scaleName: scaleName,\n    fieldDef: fieldDef,\n    band: band,\n    offset: offset\n  });\n  return ref.wrapPositionInvalidTest({\n    fieldDef: fieldDef,\n    channel: channel,\n    markDef: markDef,\n    ref: r\n  });\n}","map":null,"metadata":{},"sourceType":"module"}