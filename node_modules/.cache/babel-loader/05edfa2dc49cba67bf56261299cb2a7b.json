{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { array } from 'vega-util';\nimport { SCALE_CHANNELS } from '../../../channel';\nimport { isPathMark } from '../../../mark';\nimport { hasContinuousDomain } from '../../../scale';\nimport { keys } from '../../../util';\nimport { VG_MARK_CONFIGS } from '../../../vega.schema';\nimport { getMarkPropOrConfig } from '../../common';\nimport { color } from './color';\nimport { nonPosition } from './nonposition';\nimport { text } from './text';\nimport { tooltip } from './tooltip';\nimport { fieldInvalidPredicate } from './valueref';\nexport { color } from './color';\nexport { wrapCondition } from './conditional';\nexport { nonPosition } from './nonposition';\nexport { pointPosition } from './position-point';\nexport { pointOrRangePosition, rangePosition } from './position-range';\nexport { rectPosition } from './position-rect';\nexport { text } from './text';\nexport { tooltip } from './tooltip';\nexport function baseEncodeEntry(model, ignore) {\n  var _ref = ignore.color === 'include' ? color(model) : {},\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === void 0 ? undefined : _ref$fill,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === void 0 ? undefined : _ref$stroke;\n\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), tooltip(model)), text(model, 'href'));\n} // TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\n\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n  var config = model.config,\n      mark = model.mark,\n      markDef = model.markDef;\n  var invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    var test = allFieldsInvalidPredicate(model, {\n      invalid: true,\n      channels: SCALE_CHANNELS\n    });\n\n    if (test) {\n      return _defineProperty({}, channel, [// prepend the invalid case\n      // TODO: support custom value\n      {\n        test: test,\n        value: null\n      }].concat(_toConsumableArray(array(valueRef))));\n    }\n  }\n\n  return valueRef ? _defineProperty({}, channel, valueRef) : {};\n}\n\nfunction markDefProperties(mark, ignore) {\n  return VG_MARK_CONFIGS.reduce(function (m, prop) {\n    if (mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = {\n        value: mark[prop]\n      };\n    }\n\n    return m;\n  }, {});\n}\n\nfunction allFieldsInvalidPredicate(model, _ref4) {\n  var _ref4$invalid = _ref4.invalid,\n      invalid = _ref4$invalid === void 0 ? false : _ref4$invalid,\n      channels = _ref4.channels;\n  var filterIndex = channels.reduce(function (aggregator, channel) {\n    var scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      var scaleType = scaleComponent.get('type');\n      var field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  var fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    var op = invalid ? '||' : '&&';\n    return fields.map(function (field) {\n      return fieldInvalidPredicate(field, invalid);\n    }).join(\" \".concat(op, \" \"));\n  }\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"module"}