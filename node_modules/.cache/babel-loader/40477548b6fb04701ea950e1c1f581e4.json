{"ast":null,"code":"import { GuideLabelStyle, Skip, Symbols, Gradient, Discrete, LegendScales } from './guides/constants';\nimport legendGradient from './guides/legend-gradient';\nimport legendGradientDiscrete from './guides/legend-gradient-discrete';\nimport legendGradientLabels from './guides/legend-gradient-labels';\nimport { default as legendSymbolGroups, legendSymbolLayout } from './guides/legend-symbol-groups';\nimport legendTitle from './guides/legend-title';\nimport guideGroup from './guides/guide-group';\nimport { getEncoding, getStyle, lookup } from './guides/guide-util';\nimport parseExpression from './expression';\nimport parseMark from './mark';\nimport { LegendRole, LegendEntryRole } from './marks/roles';\nimport { addEncoders, extendEncode } from './encode/encode-util';\nimport { ref, deref } from '../util';\nimport { Collect, LegendEntries } from '../transforms';\nimport { isContinuous, isDiscretizing } from 'vega-scale';\nimport { error } from 'vega-util';\nexport default function (spec, scope) {\n  var config = scope.config.legend,\n      encode = spec.encode || {},\n      legendEncode = encode.legend || {},\n      name = legendEncode.name || undefined,\n      interactive = legendEncode.interactive,\n      style = legendEncode.style,\n      _ = lookup(spec, config),\n      entryEncode,\n      entryLayout,\n      params,\n      children,\n      type,\n      datum,\n      dataRef,\n      entryRef,\n      group; // resolve 'canonical' scale name\n\n\n  var scale = LegendScales.reduce(function (a, b) {\n    return a || spec[b];\n  }, 0);\n  if (!scale) error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n  type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n  datum = {\n    title: spec.title != null,\n    type: type,\n    vgrad: type !== 'symbol' && _.isVertical()\n  };\n  dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend group\n\n  legendEncode = extendEncode(buildLegendEncode(_, config), legendEncode, Skip); // encoding properties for legend entry sub-group\n\n  entryEncode = {\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    }\n  }; // data source for legend values\n\n  entryRef = ref(scope.add(LegendEntries(params = {\n    type: type,\n    scale: scope.scaleRef(scale),\n    count: scope.objectProperty(_('tickCount')),\n    limit: scope.property(_('symbolLimit')),\n    values: scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  }))); // continuous gradient legend\n\n  if (type === Gradient) {\n    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n    params.count = params.count || scope.signalRef(\"max(2,2*floor((\".concat(deref(_.gradientLength()), \")/100))\"));\n  } // discrete gradient legend\n  else if (type === Discrete) {\n      children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n    } // symbol legend\n    else {\n        // determine legend symbol group layout\n        entryLayout = legendSymbolLayout(spec, config);\n        children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n        params.size = sizeExpression(spec, scope, children[0].marks);\n      } // generate legend marks\n\n\n  children = [guideGroup(LegendEntryRole, null, null, dataRef, interactive, entryEncode, children, entryLayout)]; // include legend title if defined\n\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  } // build legend specification\n\n\n  group = guideGroup(LegendRole, style, name, dataRef, interactive, legendEncode, children);\n  if (spec.zindex) group.zindex = spec.zindex; // parse legend specification\n\n  return parseMark(group, scope);\n}\n\nfunction legendType(spec, scaleType) {\n  var type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient : isDiscretizing(scaleType) ? Discrete : Symbols;\n  }\n\n  return type !== Gradient ? type : isDiscretizing(scaleType) ? Discrete : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce(function (count, type) {\n    return count + (spec[type] ? 1 : 0);\n  }, 0);\n}\n\nfunction buildLegendEncode(_, config) {\n  var encode = {\n    enter: {},\n    update: {}\n  };\n  addEncoders(encode, {\n    orient: _('orient'),\n    offset: _('offset'),\n    padding: _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill: _('fillColor'),\n    stroke: _('strokeColor'),\n    strokeWidth: config.strokeWidth,\n    strokeDash: config.strokeDash,\n    x: _('legendX'),\n    y: _('legendY')\n  });\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  var size = deref(getChannel('size', spec, marks)),\n      strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n      fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n  return parseExpression(\"max(ceil(sqrt(\".concat(size, \")+\").concat(strokeWidth, \"),\").concat(fontSize, \")\"), scope);\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name] ? \"scale(\\\"\".concat(spec[name], \"\\\",datum)\") : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}","map":null,"metadata":{},"sourceType":"module"}