{"ast":null,"code":"import { getState, setState } from './state';\nimport { canonicalType, isCollect } from './util';\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\n\nexport default function (df, transforms, functions) {\n  return new Context(df, transforms, functions);\n}\n\nfunction Context(df, transforms, functions) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction ContextFork(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.functions = ctx.functions;\n  this.events = ctx.events;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = ContextFork.prototype = {\n  fork: function fork() {\n    var ctx = new ContextFork(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n  get: function get(id) {\n    return this.nodes[id];\n  },\n  set: function set(id, node) {\n    return this.nodes[id] = node;\n  },\n  add: function add(spec, op) {\n    var ctx = this,\n        df = ctx.dataflow,\n        data;\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && (data = spec.value)) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      var p = ctx.get(spec.parent.$ref);\n\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(function () {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      for (var name in spec.data) {\n        data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(function (role) {\n          data[role] = op;\n        });\n      }\n    }\n  },\n  resolve: function resolve() {\n    (this.unresolved || []).forEach(function (fn) {\n      fn();\n    });\n    delete this.unresolved;\n    return this;\n  },\n  operator: function operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n  transform: function transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n  stream: function stream(spec, _stream) {\n    this.set(spec.id, _stream);\n  },\n  update: function update(spec, stream, target, _update, params) {\n    this.dataflow.on(stream, target, _update, params, spec.options);\n  },\n  getState: getState,\n  setState: setState\n};","map":null,"metadata":{},"sourceType":"module"}