{"ast":null,"code":"import Renderer from './Renderer';\nimport Bounds from './Bounds';\nimport marks from './marks/index';\nimport { domClear } from './util/dom';\nimport clip from './util/canvas/clip';\nimport resize from './util/canvas/resize';\nimport { canvas } from 'vega-canvas';\nimport { inherits } from 'vega-util';\nexport default function CanvasRenderer(loader) {\n  Renderer.call(this, loader);\n  this._redraw = false;\n  this._dirty = new Bounds();\n}\nvar prototype = inherits(CanvasRenderer, Renderer),\n    base = Renderer.prototype,\n    tempBounds = new Bounds();\n\nprototype.initialize = function (el, width, height, origin, scaleFactor, options) {\n  this._options = options;\n  this._canvas = canvas(1, 1, options && options.type); // instantiate a small canvas\n\n  if (el) {\n    domClear(el, 0).appendChild(this._canvas);\n\n    this._canvas.setAttribute('class', 'marks');\n  } // this method will invoke resize to size the canvas appropriately\n\n\n  return base.initialize.call(this, el, width, height, origin, scaleFactor);\n};\n\nprototype.resize = function (width, height, origin, scaleFactor) {\n  base.resize.call(this, width, height, origin, scaleFactor);\n  resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options && this._options.context);\n  this._redraw = true;\n  return this;\n};\n\nprototype.canvas = function () {\n  return this._canvas;\n};\n\nprototype.context = function () {\n  return this._canvas ? this._canvas.getContext('2d') : null;\n};\n\nprototype.dirty = function (item) {\n  var b = translate(item.bounds, item.mark.group);\n\n  this._dirty.union(b);\n};\n\nfunction clipToBounds(g, b, origin) {\n  // expand bounds by 1 pixel, then round to pixel boundaries\n  b.expand(1).round(); // to avoid artifacts translate if origin has fractional pixels\n\n  b.translate(-(origin[0] % 1), -(origin[1] % 1)); // set clipping path\n\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n  return b;\n}\n\nfunction viewBounds(origin, width, height) {\n  return tempBounds.set(0, 0, width, height).translate(-origin[0], -origin[1]);\n}\n\nfunction translate(bounds, group) {\n  if (group == null) return bounds;\n  var b = tempBounds.clear().union(bounds);\n\n  for (; group != null; group = group.mark.group) {\n    b.translate(group.x || 0, group.y || 0);\n  }\n\n  return b;\n}\n\nprototype._render = function (scene) {\n  var g = this.context(),\n      o = this._origin,\n      w = this._width,\n      h = this._height,\n      b = this._dirty; // setup\n\n  g.save();\n\n  if (this._redraw || b.empty()) {\n    this._redraw = false;\n    b = viewBounds(o, w, h).expand(1);\n  } else {\n    b = clipToBounds(g, b.intersect(viewBounds(o, w, h)), o, w, h);\n  }\n\n  this.clear(-o[0], -o[1], w, h); // render\n\n  this.draw(g, scene, b); // takedown\n\n  g.restore();\n\n  this._dirty.clear();\n\n  return this;\n};\n\nprototype.draw = function (ctx, scene, bounds) {\n  var mark = marks[scene.marktype];\n  if (scene.clip) clip(ctx, scene);\n  mark.draw.call(this, ctx, scene, bounds);\n  if (scene.clip) ctx.restore();\n};\n\nprototype.clear = function (x, y, w, h) {\n  var g = this.context();\n  g.clearRect(x, y, w, h);\n\n  if (this._bgcolor != null) {\n    g.fillStyle = this._bgcolor;\n    g.fillRect(x, y, w, h);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}