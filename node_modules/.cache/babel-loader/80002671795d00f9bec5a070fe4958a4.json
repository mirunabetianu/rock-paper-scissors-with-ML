{"ast":null,"code":"import _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as log from '../log';\nimport { deepEqual, duplicate, getFirstDefined, keys } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n\nexport var Split =\n/*#__PURE__*/\nfunction () {\n  function Split() {\n    var explicit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var implicit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Split);\n\n    this.explicit = explicit;\n    this.implicit = implicit;\n  }\n\n  _createClass(Split, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Split(duplicate(this.explicit), duplicate(this.implicit));\n    }\n  }, {\n    key: \"combine\",\n    value: function combine() {\n      // FIXME remove \"as any\".\n      // Add \"as any\" to avoid an error \"Spread types may only be created from object types\".\n      return Object.assign(Object.assign({}, this.explicit), this.implicit);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      // Explicit has higher precedence\n      return getFirstDefined(this.explicit[key], this.implicit[key]);\n    }\n  }, {\n    key: \"getWithExplicit\",\n    value: function getWithExplicit(key) {\n      // Explicit has higher precedence\n      if (this.explicit[key] !== undefined) {\n        return {\n          explicit: true,\n          value: this.explicit[key]\n        };\n      } else if (this.implicit[key] !== undefined) {\n        return {\n          explicit: false,\n          value: this.implicit[key]\n        };\n      }\n\n      return {\n        explicit: false,\n        value: undefined\n      };\n    }\n  }, {\n    key: \"setWithExplicit\",\n    value: function setWithExplicit(key, value) {\n      if (value.value !== undefined) {\n        this.set(key, value.value, value.explicit);\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value, explicit) {\n      delete this[explicit ? 'implicit' : 'explicit'][key];\n      this[explicit ? 'explicit' : 'implicit'][key] = value;\n      return this;\n    }\n  }, {\n    key: \"copyKeyFromSplit\",\n    value: function copyKeyFromSplit(key, s) {\n      // Explicit has higher precedence\n      if (s.explicit[key] !== undefined) {\n        this.set(key, s.explicit[key], true);\n      } else if (s.implicit[key] !== undefined) {\n        this.set(key, s.implicit[key], false);\n      }\n    }\n  }, {\n    key: \"copyKeyFromObject\",\n    value: function copyKeyFromObject(key, s) {\n      // Explicit has higher precedence\n      if (s[key] !== undefined) {\n        this.set(key, s[key], true);\n      }\n    }\n    /**\n     * Merge split object into this split object. Properties from the other split\n     * overwrite properties from this split.\n     */\n\n  }, {\n    key: \"copyAll\",\n    value: function copyAll(other) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = keys(other.combine())[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          var val = other.getWithExplicit(key);\n          this.setWithExplicit(key, val);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Split;\n}();\nexport function makeExplicit(value) {\n  return {\n    explicit: true,\n    value: value\n  };\n}\nexport function makeImplicit(value) {\n  return {\n    explicit: false,\n    value: value\n  };\n}\nexport function tieBreakByComparing(compare) {\n  return function (v1, v2, property, propertyOf) {\n    var diff = compare(v1.value, v2.value);\n\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n\n    return defaultTieBreaker(v1, v2, property, propertyOf);\n  };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  } // If equal score, prefer v1.\n\n\n  return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf) {\n  var tieBreaker = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultTieBreaker;\n\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (deepEqual(v1.value, v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}