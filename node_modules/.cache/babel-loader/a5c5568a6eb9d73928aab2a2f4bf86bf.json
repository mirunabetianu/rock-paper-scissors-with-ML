{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar _regeneratorRuntime = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\n\nvar utils_1 = require(\"./utils\");\n/**\n * Returns summary statistics for an array of numbers\n *\n * @param input\n */\n\n\nfunction arrayStats(input) {\n  if (!Array.isArray(input)) {\n    throw new Error('input must be an array');\n  }\n\n  if (input.length === 0) {\n    return {\n      numVals: 0,\n      numNans: 0,\n      numZeros: 0,\n      max: undefined,\n      min: undefined\n    };\n  }\n\n  var numVals = input.length;\n  var max = -Infinity;\n  var min = Infinity;\n  var numZeros = 0;\n  var numNans = 0;\n  var numInfs = 0;\n\n  for (var i = 0; i < numVals; i++) {\n    var curr = input[i];\n\n    if (curr > max) {\n      max = curr;\n    }\n\n    if (curr < min) {\n      min = curr;\n    }\n\n    if (curr === 0) {\n      numZeros += 1;\n    }\n\n    if (isNaN(curr)) {\n      numNans += 1;\n    } else if (!isFinite(curr)) {\n      // Make sure NaNs are not double counted as Infs\n      numInfs += 1;\n    }\n  }\n\n  var result = {\n    numVals: numVals,\n    numZeros: numZeros,\n    numNans: numNans,\n    max: max,\n    min: min,\n    numInfs: numInfs\n  }; // Handle all NaN input\n\n  if (result.max === -Infinity) {\n    result.max = NaN;\n  }\n\n  if (result.min === Infinity) {\n    result.min = NaN;\n  }\n\n  return result;\n}\n\nexports.arrayStats = arrayStats;\n/**\n * Returns summary statistics for a numeric tensor. *\n *\n * @param input\n */\n\nfunction tensorStats(input) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var _tfjs_1$tidy, _tfjs_1$tidy2, min, max, numZeros;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // TODO. Benchmark this and consider having one of the *stats functions\n            // delegate to the other.\n            _tfjs_1$tidy = tfjs_1.tidy(function () {\n              var zero = tfjs_1.scalar(0, input.dtype);\n              var min = input.min();\n              var max = input.max();\n              var numZeros = input.equal(zero).sum();\n              return [min, max, numZeros];\n            }), _tfjs_1$tidy2 = _slicedToArray(_tfjs_1$tidy, 3), min = _tfjs_1$tidy2[0], max = _tfjs_1$tidy2[1], numZeros = _tfjs_1$tidy2[2];\n            return _context.abrupt(\"return\", Promise.all([input.data(), min.data(), max.data(), numZeros.data()]).then(function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 4),\n                  tensorVal = _ref2[0],\n                  minVal = _ref2[1],\n                  maxVal = _ref2[2],\n                  numZerosVal = _ref2[3];\n\n              // We currently need to count NaNs on CPU.\n              var numVals = tensorVal.length;\n              var numNans = 0;\n              var numInfs = 0;\n\n              for (var i = 0; i < numVals; i++) {\n                var curr = tensorVal[i];\n\n                if (isNaN(curr)) {\n                  numNans += 1;\n                } else if (!isFinite(curr)) {\n                  // Make sure NaNs are not double counted as Infs\n                  numInfs += 1;\n                }\n              }\n\n              var trueMin = minVal[0];\n              var trueMax = maxVal[0];\n\n              if (numNans === numVals) {\n                // on gpu the min and max won't be accurate if all values are NaN\n                trueMin = NaN;\n                trueMax = NaN;\n              }\n\n              var stats = {\n                numVals: numVals,\n                numZeros: numZerosVal[0],\n                numNans: numNans,\n                min: trueMin,\n                max: trueMax,\n                numInfs: numInfs\n              };\n              return stats;\n            }));\n\n          case 2:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.tensorStats = tensorStats;\n/**\n * Computes a confusion matrix from predictions and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([1, 2, 4]);\n * const predictions = tf.tensor1d([2, 2, 4]);\n * const result = await tfvis.metrics.confusionMatrix(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n * @param weights 1d tensor that is the same size as predictions.\n *  If weights is passed in then each prediction contributes its corresponding\n *  weight to the total value of the confusion matrix cell.\n *\n */\n\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nfunction confusionMatrix(labels, predictions, numClasses, weights) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2() {\n    var labelsInt, predictionsInt, weightsPromise;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            utils_1.assert(labels.rank === 1, 'labels must be a 1D tensor');\n            utils_1.assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n            utils_1.assert(labels.size === predictions.size, 'labels and predictions must be the same length');\n\n            if (weights != null) {\n              utils_1.assert(weights.size === predictions.size, 'labels and predictions must be the same length');\n            } // Cast to int in case the caller didn't\n\n\n            labelsInt = labels.cast('int32');\n            predictionsInt = predictions.cast('int32');\n\n            if (numClasses == null) {\n              numClasses = tfjs_1.tidy(function () {\n                var max = tfjs_1.maximum(labelsInt.max(), predictionsInt.max()).cast('int32');\n                return max.dataSync()[0] + 1;\n              });\n            }\n\n            weightsPromise = Promise.resolve(null);\n\n            if (weights != null) {\n              weightsPromise = weights.data();\n            }\n\n            return _context2.abrupt(\"return\", Promise.all([labelsInt.data(), predictionsInt.data(), weightsPromise]).then(function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 3),\n                  labelsArray = _ref4[0],\n                  predsArray = _ref4[1],\n                  weightsArray = _ref4[2];\n\n              var result = Array(numClasses).fill(0); // Initialize the matrix\n\n              for (var i = 0; i < numClasses; i++) {\n                result[i] = Array(numClasses).fill(0);\n              }\n\n              for (var _i = 0; _i < labelsArray.length; _i++) {\n                var label = labelsArray[_i];\n                var pred = predsArray[_i];\n\n                if (weightsArray != null) {\n                  result[label][pred] += weightsArray[_i];\n                } else {\n                  result[label][pred] += 1;\n                }\n              }\n\n              return result;\n            }));\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n\nexports.confusionMatrix = confusionMatrix;\n/**\n * Computes how often predictions matches labels\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.accuracy(labels, predictions);\n * console.log(result)\n * ```\n *\n * @param labels tensor of true values\n * @param predictions tensor of predicted values\n */\n\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nfunction accuracy(labels, predictions) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3() {\n    var eq, mean, acc;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            utils_1.assertShapesMatch(labels.shape, predictions.shape, 'Error computing accuracy.');\n            eq = labels.equal(predictions);\n            mean = eq.mean();\n            _context3.next = 5;\n            return mean.data();\n\n          case 5:\n            acc = _context3.sent[0];\n            tfjs_1.dispose([eq, mean]);\n            return _context3.abrupt(\"return\", acc);\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n}\n\nexports.accuracy = accuracy;\n/**\n * Computes per class accuracy between prediction and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.perClassAccuracy(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * Returns an array of objects that each have an an `accuracy` and a `count`\n * property for each class.\n *\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n */\n\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nfunction perClassAccuracy(labels, predictions, numClasses) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4() {\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            utils_1.assert(labels.rank === 1, 'labels must be a 1D tensor');\n            utils_1.assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n            utils_1.assert(labels.size === predictions.size, 'labels and predictions must be the same length');\n\n            if (numClasses == null) {\n              numClasses = tfjs_1.tidy(function () {\n                return tfjs_1.maximum(labels.max(), predictions.max()).dataSync()[0] + 1;\n              });\n            }\n\n            return _context4.abrupt(\"return\", Promise.all([labels.data(), predictions.data()]).then(function (_ref5) {\n              var _ref6 = _slicedToArray(_ref5, 2),\n                  labelsArray = _ref6[0],\n                  predsArray = _ref6[1];\n\n              // Per class total counts\n              var counts = Array(numClasses).fill(0); // Per class accuracy\n\n              var accuracy = Array(numClasses).fill(0);\n\n              for (var i = 0; i < labelsArray.length; i++) {\n                var label = labelsArray[i];\n                var pred = predsArray[i];\n                counts[label] += 1;\n\n                if (label === pred) {\n                  accuracy[label] += 1;\n                }\n              }\n\n              var results = [];\n\n              for (var _i2 = 0; _i2 < counts.length; _i2++) {\n                results.push({\n                  count: counts[_i2],\n                  accuracy: counts[_i2] === 0 ? 0 : accuracy[_i2] / counts[_i2]\n                });\n              }\n\n              return results;\n            }));\n\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\n\nexports.perClassAccuracy = perClassAccuracy;","map":null,"metadata":{},"sourceType":"script"}