{"ast":null,"code":"import Handler from './Handler';\nimport Marks from './marks/index';\nimport { Events, HrefEvent, TooltipShowEvent, TooltipHideEvent } from './util/events';\nimport point from './util/point';\nimport { domFind } from './util/dom';\nimport { inherits } from 'vega-util';\nexport default function CanvasHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  this._down = null;\n  this._touch = null;\n  this._first = true;\n}\nvar prototype = inherits(CanvasHandler, Handler);\n\nprototype.initialize = function (el, origin, obj) {\n  // add event listeners\n  var canvas = this._canvas = el && domFind(el, 'canvas');\n\n  if (canvas) {\n    var that = this;\n    this.events.forEach(function (type) {\n      canvas.addEventListener(type, function (evt) {\n        if (prototype[type]) {\n          prototype[type].call(that, evt);\n        } else {\n          that.fire(type, evt);\n        }\n      });\n    });\n  }\n\n  return Handler.prototype.initialize.call(this, el, origin, obj);\n}; // return the backing canvas instance\n\n\nprototype.canvas = function () {\n  return this._canvas;\n}; // retrieve the current canvas context\n\n\nprototype.context = function () {\n  return this._canvas.getContext('2d');\n}; // supported events\n\n\nprototype.events = Events; // to keep old versions of firefox happy\n\nprototype.DOMMouseScroll = function (evt) {\n  this.fire('mousewheel', evt);\n};\n\nfunction move(moveEvent, overEvent, outEvent) {\n  return function (evt) {\n    var a = this._active,\n        p = this.pickEvent(evt);\n\n    if (p === a) {\n      // active item and picked item are the same\n      this.fire(moveEvent, evt); // fire move\n    } else {\n      // active item and picked item are different\n      if (!a || !a.exit) {\n        // fire out for prior active item\n        // suppress if active item was removed from scene\n        this.fire(outEvent, evt);\n      }\n\n      this._active = p; // set new active item\n\n      this.fire(overEvent, evt); // fire over for new active item\n\n      this.fire(moveEvent, evt); // fire move for new active item\n    }\n  };\n}\n\nfunction inactive(type) {\n  return function (evt) {\n    this.fire(type, evt);\n    this._active = null;\n  };\n}\n\nprototype.mousemove = move('mousemove', 'mouseover', 'mouseout');\nprototype.dragover = move('dragover', 'dragenter', 'dragleave');\nprototype.mouseout = inactive('mouseout');\nprototype.dragleave = inactive('dragleave');\n\nprototype.mousedown = function (evt) {\n  this._down = this._active;\n  this.fire('mousedown', evt);\n};\n\nprototype.click = function (evt) {\n  if (this._down === this._active) {\n    this.fire('click', evt);\n    this._down = null;\n  }\n};\n\nprototype.touchstart = function (evt) {\n  this._touch = this.pickEvent(evt.changedTouches[0]);\n\n  if (this._first) {\n    this._active = this._touch;\n    this._first = false;\n  }\n\n  this.fire('touchstart', evt, true);\n};\n\nprototype.touchmove = function (evt) {\n  this.fire('touchmove', evt, true);\n};\n\nprototype.touchend = function (evt) {\n  this.fire('touchend', evt, true);\n  this._touch = null;\n}; // fire an event\n\n\nprototype.fire = function (type, evt, touch) {\n  var a = touch ? this._touch : this._active,\n      h = this._handlers[type],\n      i,\n      len; // set event type relative to scenegraph items\n\n  evt.vegaType = type; // handle hyperlinks and tooltips first\n\n  if (type === HrefEvent && a && a.href) {\n    this.handleHref(evt, a, a.href);\n  } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\n    this.handleTooltip(evt, a, type !== TooltipHideEvent);\n  } // invoke all registered handlers\n\n\n  if (h) {\n    for (i = 0, len = h.length; i < len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n}; // add an event handler\n\n\nprototype.on = function (type, handler) {\n  var name = this.eventName(type),\n      h = this._handlers,\n      i = this._handlerIndex(h[name], type, handler);\n\n  if (i < 0) {\n    (h[name] || (h[name] = [])).push({\n      type: type,\n      handler: handler\n    });\n  }\n\n  return this;\n}; // remove an event handler\n\n\nprototype.off = function (type, handler) {\n  var name = this.eventName(type),\n      h = this._handlers[name],\n      i = this._handlerIndex(h, type, handler);\n\n  if (i >= 0) {\n    h.splice(i, 1);\n  }\n\n  return this;\n};\n\nprototype.pickEvent = function (evt) {\n  var p = point(evt, this._canvas),\n      o = this._origin;\n  return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\n}; // find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\n\n\nprototype.pick = function (scene, x, y, gx, gy) {\n  var g = this.context(),\n      mark = Marks[scene.marktype];\n  return mark.pick.call(this, g, scene, x, y, gx, gy);\n};","map":null,"metadata":{},"sourceType":"module"}