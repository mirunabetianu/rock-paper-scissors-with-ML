{"ast":null,"code":"export var RawCode = 'RawCode';\nexport var Literal = 'Literal';\nexport var Property = 'Property';\nexport var Identifier = 'Identifier';\nexport var ArrayExpression = 'ArrayExpression';\nexport var BinaryExpression = 'BinaryExpression';\nexport var CallExpression = 'CallExpression';\nexport var ConditionalExpression = 'ConditionalExpression';\nexport var LogicalExpression = 'LogicalExpression';\nexport var MemberExpression = 'MemberExpression';\nexport var ObjectExpression = 'ObjectExpression';\nexport var UnaryExpression = 'UnaryExpression';\nexport default function ASTNode(type) {\n  this.type = type;\n}\n\nASTNode.prototype.visit = function (visitor) {\n  var node = this,\n      c,\n      i,\n      n;\n  if (visitor(node)) return 1;\n\n  for (c = children(node), i = 0, n = c.length; i < n; ++i) {\n    if (c[i].visit(visitor)) return 1;\n  }\n};\n\nfunction children(node) {\n  switch (node.type) {\n    case ArrayExpression:\n      return node.elements;\n\n    case BinaryExpression:\n    case LogicalExpression:\n      return [node.left, node.right];\n\n    case CallExpression:\n      var args = node.arguments.slice();\n      args.unshift(node.callee);\n      return args;\n\n    case ConditionalExpression:\n      return [node.test, node.consequent, node.alternate];\n\n    case MemberExpression:\n      return [node.object, node.property];\n\n    case ObjectExpression:\n      return node.properties;\n\n    case Property:\n      return [node.key, node.value];\n\n    case UnaryExpression:\n      return [node.argument];\n\n    case Identifier:\n    case Literal:\n    case RawCode:\n    default:\n      return [];\n  }\n}","map":null,"metadata":{},"sourceType":"module"}