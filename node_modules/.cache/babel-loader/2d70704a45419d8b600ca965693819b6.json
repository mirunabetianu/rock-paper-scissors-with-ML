{"ast":null,"code":"import DataScope from './DataScope';\nimport { aggrField, Ascending, compareRef, Entry, isExpr, isSignal, fieldRef, keyRef, operator, ref } from './util';\nimport parseExpression from './parsers/expression';\nimport { Compare, Expression, Field, Key, Projection, Proxy, Scale, Sieve } from './transforms';\nimport { array, error, extend, hasOwnProperty, isArray, isString, isObject, peek, stringValue } from 'vega-util';\nexport default function Scope(config) {\n  this.config = config;\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.background = null;\n  this.eventConfig = null;\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.legends = scope.legends;\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nvar prototype = Scope.prototype = Subscope.prototype; // ----\n\nprototype.fork = function () {\n  return new Subscope(this);\n};\n\nprototype.isSubscope = function () {\n  return this._subid > 0;\n};\n\nprototype.toRuntime = function () {\n  this.finish();\n  return {\n    background: this.background,\n    operators: this.operators,\n    streams: this.streams,\n    updates: this.updates,\n    bindings: this.bindings,\n    eventConfig: this.eventConfig\n  };\n};\n\nprototype.id = function () {\n  return (this._subid ? this._subid + ':' : 0) + this._id++;\n};\n\nprototype.add = function (op) {\n  this.operators.push(op);\n  op.id = this.id(); // if pre-registration references exist, resolve them now\n\n  if (op.refs) {\n    op.refs.forEach(function (ref) {\n      ref.$ref = op.id;\n    });\n    op.refs = null;\n  }\n\n  return op;\n};\n\nprototype.proxy = function (op) {\n  var vref = op instanceof Entry ? ref(op) : op;\n  return this.add(Proxy({\n    value: vref\n  }));\n};\n\nprototype.addStream = function (stream) {\n  this.streams.push(stream);\n  stream.id = this.id();\n  return stream;\n};\n\nprototype.addUpdate = function (update) {\n  this.updates.push(update);\n  return update;\n}; // Apply metadata\n\n\nprototype.finish = function () {\n  var name, ds; // annotate root\n\n  if (this.root) this.root.root = true; // annotate signals\n\n  for (name in this.signals) {\n    this.signals[name].signal = name;\n  } // annotate scales\n\n\n  for (name in this.scales) {\n    this.scales[name].scale = name;\n  } // annotate data sets\n\n\n  function annotate(op, name, type) {\n    var data, list;\n\n    if (op) {\n      data = op.data || (op.data = {});\n      list = data[name] || (data[name] = []);\n      list.push(type);\n    }\n  }\n\n  for (name in this.data) {\n    ds = this.data[name];\n    annotate(ds.input, name, 'input');\n    annotate(ds.output, name, 'output');\n    annotate(ds.values, name, 'values');\n\n    for (var field in ds.index) {\n      annotate(ds.index[field], name, 'index:' + field);\n    }\n  }\n\n  return this;\n}; // ----\n\n\nprototype.pushState = function (encode, parent, lookup) {\n  this._encode.push(ref(this.add(Sieve({\n    pulse: encode\n  }))));\n\n  this._parent.push(parent);\n\n  this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n\n  this._markpath.push(-1);\n};\n\nprototype.popState = function () {\n  this._encode.pop();\n\n  this._parent.pop();\n\n  this._lookup.pop();\n\n  this._markpath.pop();\n};\n\nprototype.parent = function () {\n  return peek(this._parent);\n};\n\nprototype.encode = function () {\n  return peek(this._encode);\n};\n\nprototype.lookup = function () {\n  return peek(this._lookup);\n};\n\nprototype.markpath = function () {\n  var p = this._markpath;\n  return ++p[p.length - 1];\n}; // ----\n\n\nprototype.fieldRef = function (field, name) {\n  if (isString(field)) return fieldRef(field, name);\n\n  if (!field.signal) {\n    error('Unsupported field reference: ' + stringValue(field));\n  }\n\n  var s = field.signal,\n      f = this.field[s],\n      params;\n\n  if (!f) {\n    params = {\n      name: this.signalRef(s)\n    };\n    if (name) params.as = name;\n    this.field[s] = f = ref(this.add(Field(params)));\n  }\n\n  return f;\n};\n\nprototype.compareRef = function (cmp) {\n  function check(_) {\n    if (isSignal(_)) {\n      signal = true;\n      return scope.signalRef(_.signal);\n    } else if (isExpr(_)) {\n      signal = true;\n      return scope.exprRef(_.expr);\n    } else {\n      return _;\n    }\n  }\n\n  var scope = this,\n      signal = false,\n      fields = array(cmp.field).map(check),\n      orders = array(cmp.order).map(check);\n  return signal ? ref(this.add(Compare({\n    fields: fields,\n    orders: orders\n  }))) : compareRef(fields, orders);\n};\n\nprototype.keyRef = function (fields, flat) {\n  function check(_) {\n    if (isSignal(_)) {\n      signal = true;\n      return ref(sig[_.signal]);\n    } else {\n      return _;\n    }\n  }\n\n  var sig = this.signals,\n      signal = false;\n  fields = array(fields).map(check);\n  return signal ? ref(this.add(Key({\n    fields: fields,\n    flat: flat\n  }))) : keyRef(fields, flat);\n};\n\nprototype.sortRef = function (sort) {\n  if (!sort) return sort; // including id ensures stable sorting\n\n  var a = aggrField(sort.op, sort.field),\n      o = sort.order || Ascending;\n  return o.signal ? ref(this.add(Compare({\n    fields: a,\n    orders: this.signalRef(o.signal)\n  }))) : compareRef(a, o);\n}; // ----\n\n\nprototype.event = function (source, type) {\n  var key = source + ':' + type;\n\n  if (!this.events[key]) {\n    var id = this.id();\n    this.streams.push({\n      id: id,\n      source: source,\n      type: type\n    });\n    this.events[key] = id;\n  }\n\n  return this.events[key];\n}; // ----\n\n\nprototype.hasOwnSignal = function (name) {\n  return hasOwnProperty(this.signals, name);\n};\n\nprototype.addSignal = function (name, value) {\n  if (this.hasOwnSignal(name)) {\n    error('Duplicate signal name: ' + stringValue(name));\n  }\n\n  var op = value instanceof Entry ? value : this.add(operator(value));\n  return this.signals[name] = op;\n};\n\nprototype.getSignal = function (name) {\n  if (!this.signals[name]) {\n    error('Unrecognized signal name: ' + stringValue(name));\n  }\n\n  return this.signals[name];\n};\n\nprototype.signalRef = function (s) {\n  if (this.signals[s]) {\n    return ref(this.signals[s]);\n  } else if (!hasOwnProperty(this.lambdas, s)) {\n    this.lambdas[s] = this.add(operator(null));\n  }\n\n  return ref(this.lambdas[s]);\n};\n\nprototype.parseLambdas = function () {\n  var code = Object.keys(this.lambdas);\n\n  for (var i = 0, n = code.length; i < n; ++i) {\n    var s = code[i],\n        e = parseExpression(s, this),\n        op = this.lambdas[s];\n    op.params = e.$params;\n    op.update = e.$expr;\n  }\n};\n\nprototype.property = function (spec) {\n  return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n};\n\nprototype.objectProperty = function (spec) {\n  return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  var code = '[',\n      i = 0,\n      n = array.length,\n      value;\n\n  for (; i < n; ++i) {\n    value = array[i];\n    code += (i > 0 ? ',' : '') + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  var code = '{',\n      i = 0,\n      key,\n      value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '') + stringValue(key) + ':' + (isObject(value) ? value.signal || propertyLambda(value) : stringValue(value));\n  }\n\n  return code + '}';\n}\n\nprototype.exprRef = function (code, name) {\n  var params = {\n    expr: parseExpression(code, this)\n  };\n  if (name) params.expr.$name = name;\n  return ref(this.add(Expression(params)));\n};\n\nprototype.addBinding = function (name, bind) {\n  if (!this.bindings) {\n    error('Nested signals do not support binding: ' + stringValue(name));\n  }\n\n  this.bindings.push(extend({\n    signal: name\n  }, bind));\n}; // ----\n\n\nprototype.addScaleProj = function (name, transform) {\n  if (hasOwnProperty(this.scales, name)) {\n    error('Duplicate scale or projection name: ' + stringValue(name));\n  }\n\n  this.scales[name] = this.add(transform);\n};\n\nprototype.addScale = function (name, params) {\n  this.addScaleProj(name, Scale(params));\n};\n\nprototype.addProjection = function (name, params) {\n  this.addScaleProj(name, Projection(params));\n};\n\nprototype.getScale = function (name) {\n  if (!this.scales[name]) {\n    error('Unrecognized scale name: ' + stringValue(name));\n  }\n\n  return this.scales[name];\n};\n\nprototype.projectionRef = prototype.scaleRef = function (name) {\n  return ref(this.getScale(name));\n};\n\nprototype.projectionType = prototype.scaleType = function (name) {\n  return this.getScale(name).params.type;\n}; // ----\n\n\nprototype.addData = function (name, dataScope) {\n  if (hasOwnProperty(this.data, name)) {\n    error('Duplicate data set name: ' + stringValue(name));\n  }\n\n  return this.data[name] = dataScope;\n};\n\nprototype.getData = function (name) {\n  if (!this.data[name]) {\n    error('Undefined data set name: ' + stringValue(name));\n  }\n\n  return this.data[name];\n};\n\nprototype.addDataPipeline = function (name, entries) {\n  if (hasOwnProperty(this.data, name)) {\n    error('Duplicate data set name: ' + stringValue(name));\n  }\n\n  return this.addData(name, DataScope.fromEntries(this, entries));\n};","map":null,"metadata":{},"sourceType":"module"}