{"ast":null,"code":"import { selector as parseSelector } from 'vega-event-selector';\nimport { stringValue } from 'vega-util';\nimport { X, Y } from '../../../channel';\nimport { BRUSH as INTERVAL_BRUSH } from '../interval';\nimport { default as scalesCompiler, domain } from './scales';\nvar ANCHOR = '_zoom_anchor';\nvar DELTA = '_zoom_delta';\nvar zoom = {\n  has: function has(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.zoom;\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var name = selCmpt.name;\n    var hasScales = scalesCompiler.has(selCmpt);\n    var delta = name + DELTA;\n    var _selCmpt$project$hasC = selCmpt.project.hasChannel,\n        x = _selCmpt$project$hasC.x,\n        y = _selCmpt$project$hasC.y;\n    var sx = stringValue(model.scaleName(X));\n    var sy = stringValue(model.scaleName(Y));\n    var events = parseSelector(selCmpt.zoom, 'scope');\n\n    if (!hasScales) {\n      events = events.map(function (e) {\n        return e.markname = name + INTERVAL_BRUSH, e;\n      });\n    }\n\n    _signals.push({\n      name: name + ANCHOR,\n      on: [{\n        events: events,\n        update: !hasScales ? \"{x: x(unit), y: y(unit)}\" : '{' + [sx ? \"x: invert(\".concat(sx, \", x(unit))\") : '', sy ? \"y: invert(\".concat(sy, \", y(unit))\") : ''].filter(function (expr) {\n          return !!expr;\n        }).join(', ') + '}'\n      }]\n    }, {\n      name: delta,\n      on: [{\n        events: events,\n        force: true,\n        update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'\n      }]\n    });\n\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', _signals);\n    }\n\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', _signals);\n    }\n\n    return _signals;\n  }\n};\nexport default zoom;\n\nfunction onDelta(model, selCmpt, proj, size, signals) {\n  var _a;\n\n  var name = selCmpt.name;\n  var channel = proj.channel;\n  var hasScales = scalesCompiler.has(selCmpt);\n  var signal = signals.filter(function (s) {\n    return s.name === proj.signals[hasScales ? 'data' : 'visual'];\n  })[0];\n  var sizeSg = model.getSizeSignalRef(size).signal;\n  var scaleCmpt = model.getScaleComponent(channel);\n  var scaleType = scaleCmpt.get('type');\n  var base = hasScales ? domain(model, channel) : signal.name;\n  var delta = name + DELTA;\n  var anchor = \"\".concat(name).concat(ANCHOR, \".\").concat(channel);\n  var zoomFn = !hasScales ? 'zoomLinear' : scaleType === 'log' ? 'zoomLog' : scaleType === 'pow' ? 'zoomPow' : 'zoomLinear';\n  var update = \"\".concat(zoomFn, \"(\").concat(base, \", \").concat(anchor, \", \").concat(delta) + (hasScales && scaleType === 'pow' ? \", \".concat((_a = scaleCmpt.get('exponent'), _a !== null && _a !== void 0 ? _a : 1)) : '') + ')';\n  signal.on.push({\n    events: {\n      signal: delta\n    },\n    update: hasScales ? update : \"clampRange(\".concat(update, \", 0, \").concat(sizeSg, \")\")\n  });\n}","map":null,"metadata":{},"sourceType":"module"}