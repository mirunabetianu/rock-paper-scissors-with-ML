{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { isArray } from 'vega-util';\nimport { isFieldDef, isValueDef, vgField } from '../../channeldef';\nimport { MAIN } from '../../data';\nimport { isAggregate, pathGroupingFields } from '../../encoding';\nimport { AREA, BAR, isPathMark, LINE, TRAIL } from '../../mark';\nimport { isSortByEncoding, isSortField } from '../../sort';\nimport { contains, getFirstDefined, isNullOrFalse, keys, omit, pick } from '../../util';\nimport { VG_CORNERRADIUS_CHANNELS } from '../../vega.schema';\nimport { getMarkConfig, getStyles, sortParams } from '../common';\nimport { area } from './area';\nimport { bar } from './bar';\nimport { geoshape } from './geoshape';\nimport { image } from './image';\nimport { line, trail } from './line';\nimport { circle, point, square } from './point';\nimport { rect } from './rect';\nimport { rule } from './rule';\nimport { text } from './text';\nimport { tick } from './tick';\nvar markCompiler = {\n  area: area,\n  bar: bar,\n  circle: circle,\n  geoshape: geoshape,\n  image: image,\n  line: line,\n  point: point,\n  rect: rect,\n  rule: rule,\n  square: square,\n  text: text,\n  tick: tick,\n  trail: trail\n};\nexport function parseMarkGroups(model) {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    return parsePathMark(model);\n  } else if (contains([BAR], model.mark)) {\n    return getStackGroups(model);\n  } else {\n    return getMarkGroups(model);\n  }\n}\nvar FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model) {\n  var details = pathGroupingFields(model.mark, model.encoding);\n  var pathMarks = getMarkGroups(model, {\n    // If has subfacet for line/area group, need to use faceted data from below.\n    fromPrefix: details.length > 0 ? FACETED_PATH_PREFIX : ''\n  });\n\n  if (details.length > 0) {\n    // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n    return [{\n      name: model.getName('pathgroup'),\n      type: 'group',\n      from: {\n        facet: {\n          name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n          data: model.requestDataName(MAIN),\n          groupby: details\n        }\n      },\n      encode: {\n        update: {\n          width: {\n            field: {\n              group: 'width'\n            }\n          },\n          height: {\n            field: {\n              group: 'height'\n            }\n          }\n        }\n      },\n      marks: pathMarks\n    }];\n  } else {\n    return pathMarks;\n  }\n}\n\nvar STACK_GROUP_PREFIX = 'stack_group_';\n/**\n * We need to put stacked bars into groups in order to enable cornerRadius for stacks.\n * If stack is used and the model doesn't have size encoding, we put the mark into groups,\n * and apply cornerRadius properties at the group.\n */\n\nfunction getStackGroups(model) {\n  var _a; // Don't use nested groups when cornerRadius is not specified, or specified as 0\n\n\n  var hasCornerRadius = VG_CORNERRADIUS_CHANNELS.some(function (prop) {\n    return model.markDef[prop] || getMarkConfig(prop, model.markDef, model.config);\n  }); // Activate groups if stack is used and the model doesn't have size encoding\n\n  if (model.stack && !model.fieldDef('size') && hasCornerRadius) {\n    // Generate the mark\n    var _getMarkGroups = getMarkGroups(model, {\n      fromPrefix: STACK_GROUP_PREFIX\n    }),\n        _getMarkGroups2 = _slicedToArray(_getMarkGroups, 1),\n        mark = _getMarkGroups2[0]; // Get the scale for the stacked field\n\n\n    var fieldScale = model.scaleName(model.stack.fieldChannel);\n\n    var stackField = function stackField() {\n      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return model.vgField(model.stack.fieldChannel, opt);\n    }; // Find the min/max of the pixel value on the stacked direction\n\n\n    var stackFieldGroup = function stackFieldGroup(func, expr) {\n      var vgFieldMinMax = [stackField({\n        prefix: 'min',\n        suffix: 'start',\n        expr: expr\n      }), stackField({\n        prefix: 'max',\n        suffix: 'start',\n        expr: expr\n      }), stackField({\n        prefix: 'min',\n        suffix: 'end',\n        expr: expr\n      }), stackField({\n        prefix: 'max',\n        suffix: 'end',\n        expr: expr\n      })];\n      return \"\".concat(func, \"(\").concat(vgFieldMinMax.map(function (field) {\n        return \"scale('\".concat(fieldScale, \"',\").concat(field, \")\");\n      }).join(','), \")\");\n    };\n\n    var groupUpdate;\n    var innerGroupUpdate; // Build the encoding for group and an inner group\n\n    if (model.stack.fieldChannel === 'x') {\n      // Move cornerRadius, y/yc/y2/height properties to group\n      // Group x/x2 should be the min/max of the marks within\n      groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['y', 'yc', 'y2', 'height'].concat(_toConsumableArray(VG_CORNERRADIUS_CHANNELS)))), {\n        x: {\n          signal: stackFieldGroup('min', 'datum')\n        },\n        x2: {\n          signal: stackFieldGroup('max', 'datum')\n        },\n        clip: {\n          value: true\n        }\n      }); // Inner group should revert the x translation, and pass height through\n\n      innerGroupUpdate = {\n        x: {\n          field: {\n            group: 'x'\n          },\n          mult: -1\n        },\n        height: {\n          field: {\n            group: 'height'\n          }\n        }\n      }; // The marks should use the same height as group, without y/yc/y2 properties (because it's already done by group)\n      // This is why size encoding is not supported yet\n\n      mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['y', 'yc', 'y2'])), {\n        height: {\n          field: {\n            group: 'height'\n          }\n        }\n      });\n    } else {\n      groupUpdate = Object.assign(Object.assign({}, pick(mark.encode.update, ['x', 'xc', 'x2', 'width'])), {\n        y: {\n          signal: stackFieldGroup('min', 'datum')\n        },\n        y2: {\n          signal: stackFieldGroup('max', 'datum')\n        },\n        clip: {\n          value: true\n        }\n      });\n      innerGroupUpdate = {\n        y: {\n          field: {\n            group: 'y'\n          },\n          mult: -1\n        },\n        width: {\n          field: {\n            group: 'width'\n          }\n        }\n      };\n      mark.encode.update = Object.assign(Object.assign({}, omit(mark.encode.update, ['x', 'xc', 'x2'])), {\n        width: {\n          field: {\n            group: 'width'\n          }\n        }\n      });\n    } // Deal with cornerRadius properties\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = VG_CORNERRADIUS_CHANNELS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value;\n        var configValue = getMarkConfig(key, model.markDef, model.config); // Move from mark to group\n\n        if (mark.encode.update[key]) {\n          groupUpdate[key] = mark.encode.update[key];\n          delete mark.encode.update[key];\n        } else if (configValue) {\n          groupUpdate[key] = {\n            value: configValue\n          };\n        } // Overwrite any cornerRadius on mark set by config --- they are already moved to the group\n\n\n        if (configValue) {\n          mark.encode.update[key] = {\n            value: 0\n          };\n        }\n      } // For bin we have to add bin channels.\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var groupby = model.vgField(model.stack.groupbyChannel) ? [model.vgField(model.stack.groupbyChannel)] : [];\n\n    if ((_a = model.fieldDef(model.stack.groupbyChannel)) === null || _a === void 0 ? void 0 : _a.bin) {\n      groupby.push(model.vgField(model.stack.groupbyChannel, {\n        binSuffix: 'end'\n      }));\n    }\n\n    var strokeProperties = ['stroke', 'strokeWidth', 'strokeJoin', 'strokeCap', 'strokeDash', 'strokeDashOffset', 'strokeMiterLimit', 'strokeOpacity']; // Generate stroke properties for the group\n\n    groupUpdate = strokeProperties.reduce(function (encode, prop) {\n      if (mark.encode.update[prop]) {\n        return Object.assign(Object.assign({}, encode), _defineProperty({}, prop, mark.encode.update[prop]));\n      } else {\n        var configValue = getMarkConfig(prop, model.markDef, model.config);\n\n        if (configValue !== undefined) {\n          return Object.assign(Object.assign({}, encode), _defineProperty({}, prop, {\n            value: configValue\n          }));\n        } else {\n          return encode;\n        }\n      }\n    }, groupUpdate); // Apply strokeForeground and strokeOffset if stroke is used\n\n    if (groupUpdate.stroke) {\n      groupUpdate.strokeForeground = {\n        value: true\n      };\n      groupUpdate.strokeOffset = {\n        value: 0\n      };\n    }\n\n    return [{\n      type: 'group',\n      from: {\n        facet: {\n          data: model.requestDataName(MAIN),\n          name: STACK_GROUP_PREFIX + model.requestDataName(MAIN),\n          groupby: groupby,\n          aggregate: {\n            fields: [stackField({\n              suffix: 'start'\n            }), stackField({\n              suffix: 'start'\n            }), stackField({\n              suffix: 'end'\n            }), stackField({\n              suffix: 'end'\n            })],\n            ops: ['min', 'max', 'min', 'max']\n          }\n        }\n      },\n      encode: {\n        update: groupUpdate\n      },\n      marks: [{\n        type: 'group',\n        encode: {\n          update: innerGroupUpdate\n        },\n        marks: [mark]\n      }]\n    }];\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nexport function getSort(model) {\n  var encoding = model.encoding,\n      stack = model.stack,\n      mark = model.mark,\n      markDef = model.markDef,\n      config = model.config;\n  var order = encoding.order;\n\n  if (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(markDef.order) || isNullOrFalse(getMarkConfig('order', markDef, config))) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {\n      expr: 'datum'\n    });\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    var dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    var dimensionChannelDef = encoding[dimensionChannel];\n\n    if (isFieldDef(dimensionChannelDef)) {\n      var s = dimensionChannelDef.sort;\n\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {\n            prefix: dimensionChannel,\n            suffix: 'sort_index',\n            expr: 'datum'\n          })\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField({\n            // FIXME: this op might not already exist?\n            // FIXME: what if dimensionChannel (x or y) contains custom domain?\n            aggregate: isAggregate(model.encoding) ? s.op : undefined,\n            field: s.field\n          }, {\n            expr: 'datum'\n          })\n        };\n      } else if (isSortByEncoding(s)) {\n        var fieldDefToSort = model.fieldDef(s.encoding);\n        return {\n          field: vgField(fieldDefToSort, {\n            expr: 'datum'\n          }),\n          order: s.order\n        };\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n\n    return undefined;\n  }\n\n  return undefined;\n}\n\nfunction getMarkGroups(model) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    fromPrefix: ''\n  };\n  var mark = model.mark;\n  var clip = getFirstDefined(model.markDef.clip, scaleClip(model), projectionClip(model));\n  var style = getStyles(model.markDef);\n  var key = model.encoding.key;\n  var sort = getSort(model);\n  var interactive = interactiveFlag(model);\n  var postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n  return [Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark\n  }, clip ? {\n    clip: true\n  } : {}), style ? {\n    style: style\n  } : {}), key ? {\n    key: key.field\n  } : {}), sort ? {\n    sort: sort\n  } : {}), interactive ? interactive : {}), {\n    from: {\n      data: opt.fromPrefix + model.requestDataName(MAIN)\n    },\n    encode: {\n      update: markCompiler[mark].encodeEntry(model)\n    }\n  }), postEncodingTransform ? {\n    transform: postEncodingTransform\n  } : {})];\n}\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the selectionExtent property, which gets added during scale parsing.\n */\n\n\nfunction scaleClip(model) {\n  var xScale = model.getScaleComponent('x');\n  var yScale = model.getScaleComponent('y');\n  return xScale && xScale.get('selectionExtent') || yScale && yScale.get('selectionExtent') ? true : undefined;\n}\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\n\n\nfunction projectionClip(model) {\n  var projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n/**\n * Only output interactive flags if we have selections defined somewhere in our model hierarchy.\n */\n\n\nfunction interactiveFlag(model) {\n  if (!model.component.selection) return null;\n  var unitCount = keys(model.component.selection).length;\n  var parentCount = unitCount;\n  var parent = model.parent;\n\n  while (parent && parentCount === 0) {\n    parentCount = keys(parent.component.selection).length;\n    parent = parent.parent;\n  }\n\n  return parentCount ? {\n    interactive: unitCount > 0\n  } : null;\n}","map":null,"metadata":{},"sourceType":"module"}