{"ast":null,"code":"import { stableCompare, Transform } from 'vega-dataflow';\nimport { inherits, one } from 'vega-util';\nvar Zero = 'zero',\n    Center = 'center',\n    Normalize = 'normalize',\n    DefOutput = ['y0', 'y1'];\n/**\n * Stack layout for visualization elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to stack.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.\n */\n\nexport default function Stack(params) {\n  Transform.call(this, null, params);\n}\nStack.Definition = {\n  \"type\": \"Stack\",\n  \"metadata\": {\n    \"modifies\": true\n  },\n  \"params\": [{\n    \"name\": \"field\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"groupby\",\n    \"type\": \"field\",\n    \"array\": true\n  }, {\n    \"name\": \"sort\",\n    \"type\": \"compare\"\n  }, {\n    \"name\": \"offset\",\n    \"type\": \"enum\",\n    \"default\": Zero,\n    \"values\": [Zero, Center, Normalize]\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"array\": true,\n    \"length\": 2,\n    \"default\": DefOutput\n  }]\n};\nvar prototype = inherits(Stack, Transform);\n\nprototype.transform = function (_, pulse) {\n  var as = _.as || DefOutput,\n      y0 = as[0],\n      y1 = as[1],\n      sort = stableCompare(_.sort),\n      field = _.field || one,\n      stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,\n      groups,\n      i,\n      n,\n      max; // partition, sum, and sort the stack groups\n\n  groups = partition(pulse.source, _.groupby, sort, field); // compute stack layouts per group\n\n  for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {\n    stack(groups[i], max, field, y0, y1);\n  }\n\n  return pulse.reflow(_.modified()).modifies(as);\n};\n\nfunction stackCenter(group, max, field, y0, y1) {\n  var last = (max - group.sum) / 2,\n      m = group.length,\n      j = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last += Math.abs(field(t));\n  }\n}\n\nfunction stackNormalize(group, max, field, y0, y1) {\n  var scale = 1 / group.sum,\n      last = 0,\n      m = group.length,\n      j = 0,\n      v = 0,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last = scale * (v += Math.abs(field(t)));\n  }\n}\n\nfunction stackZero(group, max, field, y0, y1) {\n  var lastPos = 0,\n      lastNeg = 0,\n      m = group.length,\n      j = 0,\n      v,\n      t;\n\n  for (; j < m; ++j) {\n    t = group[j];\n    v = +field(t);\n\n    if (v < 0) {\n      t[y0] = lastNeg;\n      t[y1] = lastNeg += v;\n    } else {\n      t[y0] = lastPos;\n      t[y1] = lastPos += v;\n    }\n  }\n}\n\nfunction partition(data, groupby, sort, field) {\n  var groups = [],\n      get = function get(f) {\n    return f(t);\n  },\n      map,\n      i,\n      n,\n      m,\n      t,\n      k,\n      g,\n      s,\n      max; // partition data points into stack groups\n\n\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map = {}, i = 0, n = data.length; i < n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n\n      if (!g) {\n        map[k] = g = [];\n        groups.push(g);\n      }\n\n      g.push(t);\n    }\n  } // compute sums of groups, sort groups as needed\n\n\n  for (k = 0, max = 0, m = groups.length; k < m; ++k) {\n    g = groups[k];\n\n    for (i = 0, s = 0, n = g.length; i < n; ++i) {\n      s += Math.abs(field(g[i]));\n    }\n\n    g.sum = s;\n    if (s > max) max = s;\n    if (sort) g.sort(sort);\n  }\n\n  groups.max = max;\n  return groups;\n}","map":null,"metadata":{},"sourceType":"module"}