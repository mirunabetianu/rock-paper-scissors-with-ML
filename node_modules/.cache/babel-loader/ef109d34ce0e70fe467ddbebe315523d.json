{"ast":null,"code":"import parseDist from './util/Distributions';\nimport { ingest, Transform } from 'vega-dataflow';\nimport { sampleCurve } from 'vega-statistics';\nimport { error, extent, inherits } from 'vega-util';\n/**\n * Grid sample points for a probability density. Given a distribution and\n * a sampling extent, will generate points suitable for plotting either\n * PDF (probability density function) or CDF (cumulative distribution\n * function) curves.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.distribution - The probability distribution. This\n *   is an object parameter dependent on the distribution type.\n * @param {string} [params.method='pdf'] - The distribution method to sample.\n *   One of 'pdf' or 'cdf'.\n * @param {Array<number>} [params.extent] - The [min, max] extent over which\n *   to sample the distribution. This argument is required in most cases, but\n *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method\n *   that returns numerical sample points from which the extent can be deduced.\n * @param {number} [params.minsteps=25] - The minimum number of curve samples\n *   for plotting the density.\n * @param {number} [params.maxsteps=200] - The maximum number of curve samples\n *   for plotting the density.\n * @param {number} [params.steps] - The exact number of curve samples for\n *   plotting the density. If specified, overrides both minsteps and maxsteps\n *   to set an exact number of uniform samples. Useful in conjunction with\n *   a fixed extent to ensure consistent sample points for stacked densities.\n */\n\nexport default function Density(params) {\n  Transform.call(this, null, params);\n}\nvar distributions = [{\n  \"key\": {\n    \"function\": \"normal\"\n  },\n  \"params\": [{\n    \"name\": \"mean\",\n    \"type\": \"number\",\n    \"default\": 0\n  }, {\n    \"name\": \"stdev\",\n    \"type\": \"number\",\n    \"default\": 1\n  }]\n}, {\n  \"key\": {\n    \"function\": \"lognormal\"\n  },\n  \"params\": [{\n    \"name\": \"mean\",\n    \"type\": \"number\",\n    \"default\": 0\n  }, {\n    \"name\": \"stdev\",\n    \"type\": \"number\",\n    \"default\": 1\n  }]\n}, {\n  \"key\": {\n    \"function\": \"uniform\"\n  },\n  \"params\": [{\n    \"name\": \"min\",\n    \"type\": \"number\",\n    \"default\": 0\n  }, {\n    \"name\": \"max\",\n    \"type\": \"number\",\n    \"default\": 1\n  }]\n}, {\n  \"key\": {\n    \"function\": \"kde\"\n  },\n  \"params\": [{\n    \"name\": \"field\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"from\",\n    \"type\": \"data\"\n  }, {\n    \"name\": \"bandwidth\",\n    \"type\": \"number\",\n    \"default\": 0\n  }]\n}];\nvar mixture = {\n  \"key\": {\n    \"function\": \"mixture\"\n  },\n  \"params\": [{\n    \"name\": \"distributions\",\n    \"type\": \"param\",\n    \"array\": true,\n    \"params\": distributions\n  }, {\n    \"name\": \"weights\",\n    \"type\": \"number\",\n    \"array\": true\n  }]\n};\nDensity.Definition = {\n  \"type\": \"Density\",\n  \"metadata\": {\n    \"generates\": true\n  },\n  \"params\": [{\n    \"name\": \"extent\",\n    \"type\": \"number\",\n    \"array\": true,\n    \"length\": 2\n  }, {\n    \"name\": \"steps\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"minsteps\",\n    \"type\": \"number\",\n    \"default\": 25\n  }, {\n    \"name\": \"maxsteps\",\n    \"type\": \"number\",\n    \"default\": 200\n  }, {\n    \"name\": \"method\",\n    \"type\": \"string\",\n    \"default\": \"pdf\",\n    \"values\": [\"pdf\", \"cdf\"]\n  }, {\n    \"name\": \"distribution\",\n    \"type\": \"param\",\n    \"params\": distributions.concat(mixture)\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"array\": true,\n    \"default\": [\"value\", \"density\"]\n  }]\n};\nvar prototype = inherits(Density, Transform);\n\nprototype.transform = function (_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n  if (!this.value || pulse.changed() || _.modified()) {\n    var dist = parseDist(_.distribution, source(pulse)),\n        minsteps = _.steps || _.minsteps || 25,\n        maxsteps = _.steps || _.maxsteps || 200,\n        method = _.method || 'pdf';\n\n    if (method !== 'pdf' && method !== 'cdf') {\n      error('Invalid density method: ' + method);\n    }\n\n    if (!_.extent && !dist.data) {\n      error('Missing density extent parameter.');\n    }\n\n    method = dist[method];\n    var as = _.as || ['value', 'density'],\n        domain = _.extent || extent(dist.data()),\n        values = sampleCurve(method, domain, minsteps, maxsteps).map(function (v) {\n      var tuple = {};\n      tuple[as[0]] = v[0];\n      tuple[as[1]] = v[1];\n      return ingest(tuple);\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.add = out.source = values;\n  }\n\n  return out;\n};\n\nfunction source(pulse) {\n  return function () {\n    return pulse.materialize(pulse.SOURCE).source;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}