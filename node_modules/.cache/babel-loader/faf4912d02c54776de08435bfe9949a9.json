{"ast":null,"code":"import { groupkey } from './util/AggregateKeys';\nimport { createMeasure, compileMeasures, measureName, ValidAggregateOps } from './util/AggregateOps';\nimport TupleStore from './util/TupleStore';\nimport { ingest, replace, Transform } from 'vega-dataflow';\nimport { accessorFields, accessorName, array, error, inherits } from 'vega-util';\n/**\n * Group-by aggregation operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.\n * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.\n * @param {Array<string>} [params.as] - An array of output field names for aggregated values.\n * @param {boolean} [params.cross=false] - A flag indicating that the full\n *   cross-product of groupby values should be generated, including empty cells.\n *   If true, the drop parameter is ignored and empty cells are retained.\n * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.\n */\n\nexport default function Aggregate(params) {\n  Transform.call(this, null, params);\n  this._adds = []; // array of added output tuples\n\n  this._mods = []; // array of modified output tuples\n\n  this._alen = 0; // number of active added tuples\n\n  this._mlen = 0; // number of active modified tuples\n\n  this._drop = true; // should empty aggregation cells be removed\n\n  this._cross = false; // produce full cross-product of group-by values\n\n  this._dims = []; // group-by dimension accessors\n\n  this._dnames = []; // group-by dimension names\n\n  this._measures = []; // collection of aggregation monoids\n\n  this._countOnly = false; // flag indicating only count aggregation\n\n  this._counts = null; // collection of count fields\n\n  this._prev = null; // previous aggregation cells\n\n  this._inputs = null; // array of dependent input tuple field names\n\n  this._outputs = null; // array of output tuple field names\n}\nAggregate.Definition = {\n  \"type\": \"Aggregate\",\n  \"metadata\": {\n    \"generates\": true,\n    \"changes\": true\n  },\n  \"params\": [{\n    \"name\": \"groupby\",\n    \"type\": \"field\",\n    \"array\": true\n  }, {\n    \"name\": \"ops\",\n    \"type\": \"enum\",\n    \"array\": true,\n    \"values\": ValidAggregateOps\n  }, {\n    \"name\": \"fields\",\n    \"type\": \"field\",\n    \"null\": true,\n    \"array\": true\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"null\": true,\n    \"array\": true\n  }, {\n    \"name\": \"drop\",\n    \"type\": \"boolean\",\n    \"default\": true\n  }, {\n    \"name\": \"cross\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }, {\n    \"name\": \"key\",\n    \"type\": \"field\"\n  }]\n};\nvar prototype = inherits(Aggregate, Transform);\n\nprototype.transform = function (_, pulse) {\n  var aggr = this,\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      mod = _.modified();\n\n  aggr.stamp = out.stamp;\n\n  if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n    aggr._prev = aggr.value;\n    aggr.value = mod ? aggr.init(_) : {};\n    pulse.visit(pulse.SOURCE, function (t) {\n      return aggr.add(t);\n    });\n  } else {\n    aggr.value = aggr.value || aggr.init(_);\n    pulse.visit(pulse.REM, function (t) {\n      return aggr.rem(t);\n    });\n    pulse.visit(pulse.ADD, function (t) {\n      return aggr.add(t);\n    });\n  } // Indicate output fields and return aggregate tuples.\n\n\n  out.modifies(aggr._outputs); // Should empty cells be dropped?\n\n  aggr._drop = _.drop !== false; // If domain cross-product requested, generate empty cells as needed\n  // and ensure that empty cells are not dropped\n\n  if (_.cross && aggr._dims.length > 1) {\n    aggr._drop = false;\n    aggr.cross();\n  }\n\n  return aggr.changes(out);\n};\n\nprototype.cross = function () {\n  var aggr = this,\n      curr = aggr.value,\n      dims = aggr._dnames,\n      vals = dims.map(function () {\n    return {};\n  }),\n      n = dims.length; // collect all group-by domain values\n\n  function collect(cells) {\n    var key, i, t, v;\n\n    for (key in cells) {\n      t = cells[key].tuple;\n\n      for (i = 0; i < n; ++i) {\n        vals[i][v = t[dims[i]]] = v;\n      }\n    }\n  }\n\n  collect(aggr._prev);\n  collect(curr); // iterate over key cross-product, create cells as needed\n\n  function generate(base, tuple, index) {\n    var name = dims[index],\n        v = vals[index++],\n        k,\n        key;\n\n    for (k in v) {\n      tuple[name] = v[k];\n      key = base ? base + '|' + k : k;\n      if (index < n) generate(key, tuple, index);else if (!curr[key]) aggr.cell(key, tuple);\n    }\n  }\n\n  generate('', {}, 0);\n};\n\nprototype.init = function (_) {\n  // initialize input and output fields\n  var inputs = this._inputs = [],\n      outputs = this._outputs = [],\n      inputMap = {};\n\n  function inputVisit(get) {\n    var fields = array(accessorFields(get)),\n        i = 0,\n        n = fields.length,\n        f;\n\n    for (; i < n; ++i) {\n      if (!inputMap[f = fields[i]]) {\n        inputMap[f] = 1;\n        inputs.push(f);\n      }\n    }\n  } // initialize group-by dimensions\n\n\n  this._dims = array(_.groupby);\n  this._dnames = this._dims.map(function (d) {\n    var dname = accessorName(d);\n    inputVisit(d);\n    outputs.push(dname);\n    return dname;\n  });\n  this.cellkey = _.key ? _.key : groupkey(this._dims); // initialize aggregate measures\n\n  this._countOnly = true;\n  this._counts = [];\n  this._measures = [];\n  var fields = _.fields || [null],\n      ops = _.ops || ['count'],\n      as = _.as || [],\n      n = fields.length,\n      map = {},\n      field,\n      op,\n      m,\n      mname,\n      outname,\n      i;\n\n  if (n !== ops.length) {\n    error('Unmatched number of fields and aggregate ops.');\n  }\n\n  for (i = 0; i < n; ++i) {\n    field = fields[i];\n    op = ops[i];\n\n    if (field == null && op !== 'count') {\n      error('Null aggregate field specified.');\n    }\n\n    mname = accessorName(field);\n    outname = measureName(op, mname, as[i]);\n    outputs.push(outname);\n\n    if (op === 'count') {\n      this._counts.push(outname);\n\n      continue;\n    }\n\n    m = map[mname];\n\n    if (!m) {\n      inputVisit(field);\n      m = map[mname] = [];\n      m.field = field;\n\n      this._measures.push(m);\n    }\n\n    if (op !== 'count') this._countOnly = false;\n    m.push(createMeasure(op, outname));\n  }\n\n  this._measures = this._measures.map(function (m) {\n    return compileMeasures(m, m.field);\n  });\n  return {}; // aggregation cells (this.value)\n}; // -- Cell Management -----\n\n\nprototype.cellkey = groupkey();\n\nprototype.cell = function (key, t) {\n  var cell = this.value[key];\n\n  if (!cell) {\n    cell = this.value[key] = this.newcell(key, t);\n    this._adds[this._alen++] = cell;\n  } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {\n    cell.stamp = this.stamp;\n    this._adds[this._alen++] = cell;\n  } else if (cell.stamp < this.stamp) {\n    cell.stamp = this.stamp;\n    this._mods[this._mlen++] = cell;\n  }\n\n  return cell;\n};\n\nprototype.newcell = function (key, t) {\n  var cell = {\n    key: key,\n    num: 0,\n    agg: null,\n    tuple: this.newtuple(t, this._prev && this._prev[key]),\n    stamp: this.stamp,\n    store: false\n  };\n\n  if (!this._countOnly) {\n    var measures = this._measures,\n        n = measures.length,\n        i;\n    cell.agg = Array(n);\n\n    for (i = 0; i < n; ++i) {\n      cell.agg[i] = new measures[i](cell);\n    }\n  }\n\n  if (cell.store) {\n    cell.data = new TupleStore();\n  }\n\n  return cell;\n};\n\nprototype.newtuple = function (t, p) {\n  var names = this._dnames,\n      dims = this._dims,\n      x = {},\n      i,\n      n;\n\n  for (i = 0, n = dims.length; i < n; ++i) {\n    x[names[i]] = dims[i](t);\n  }\n\n  return p ? replace(p.tuple, x) : ingest(x);\n}; // -- Process Tuples -----\n\n\nprototype.add = function (t) {\n  var key = this.cellkey(t),\n      cell = this.cell(key, t),\n      agg,\n      i,\n      n;\n  cell.num += 1;\n  if (this._countOnly) return;\n  if (cell.store) cell.data.add(t);\n  agg = cell.agg;\n\n  for (i = 0, n = agg.length; i < n; ++i) {\n    agg[i].add(agg[i].get(t), t);\n  }\n};\n\nprototype.rem = function (t) {\n  var key = this.cellkey(t),\n      cell = this.cell(key, t),\n      agg,\n      i,\n      n;\n  cell.num -= 1;\n  if (this._countOnly) return;\n  if (cell.store) cell.data.rem(t);\n  agg = cell.agg;\n\n  for (i = 0, n = agg.length; i < n; ++i) {\n    agg[i].rem(agg[i].get(t), t);\n  }\n};\n\nprototype.celltuple = function (cell) {\n  var tuple = cell.tuple,\n      counts = this._counts,\n      agg,\n      i,\n      n; // consolidate stored values\n\n  if (cell.store) {\n    cell.data.values();\n  } // update tuple properties\n\n\n  for (i = 0, n = counts.length; i < n; ++i) {\n    tuple[counts[i]] = cell.num;\n  }\n\n  if (!this._countOnly) {\n    agg = cell.agg;\n\n    for (i = 0, n = agg.length; i < n; ++i) {\n      agg[i].set(tuple);\n    }\n  }\n\n  return tuple;\n};\n\nprototype.changes = function (out) {\n  var adds = this._adds,\n      mods = this._mods,\n      prev = this._prev,\n      drop = this._drop,\n      add = out.add,\n      rem = out.rem,\n      mod = out.mod,\n      cell,\n      key,\n      i,\n      n;\n  if (prev) for (key in prev) {\n    cell = prev[key];\n    if (!drop || cell.num) rem.push(cell.tuple);\n  }\n\n  for (i = 0, n = this._alen; i < n; ++i) {\n    add.push(this.celltuple(adds[i]));\n    adds[i] = null; // for garbage collection\n  }\n\n  for (i = 0, n = this._mlen; i < n; ++i) {\n    cell = mods[i];\n    (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));\n    mods[i] = null; // for garbage collection\n  }\n\n  this._alen = this._mlen = 0; // reset list of active cells\n\n  this._prev = null;\n  return out;\n};","map":null,"metadata":{},"sourceType":"module"}