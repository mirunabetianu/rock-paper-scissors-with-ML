{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar _regeneratorRuntime = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tf = __importStar(require(\"@tensorflow/tfjs\"));\n\nvar vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nvar dom_1 = require(\"../util/dom\");\n\nvar utils_1 = require(\"../util/utils\");\n\nvar render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a heatmap.\n *\n * ```js\n * const cols = 50;\n * const rows = 20;\n * const values = [];\n * for (let i = 0; i < cols; i++) {\n *   const col = []\n *   for (let j = 0; j < rows; j++) {\n *     col.push(i * j)\n *   }\n *   values.push(col);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Heatmap', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n * ```js\n * const data = {\n *   values: [[4, 2, 8, 20], [1, 7, 2, 10], [3, 3, 20, 13]],\n *   xTickLabels: ['cheese', 'pig', 'font'],\n *   yTickLabels: ['speed', 'smoothness', 'dexterity', 'mana'],\n * }\n *\n * // Render to visor\n * const surface = { name: 'Heatmap w Custom Labels', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\n\nfunction heatmap(container, data) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var options, drawArea, inputValues, xTickLabels, yTickLabels, dimension, _dimension, IDX_SEPARATOR, values, inputArray, _inputValues$shape, numRows, numCols, row, x, col, y, index, value, _inputArray, _row, _x, _col, _y, _value, embedOpts, spec, suffixPattern, suffixRegex, colorRange, fill, _fill;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = Object.assign({}, defaultOpts, opts);\n            drawArea = render_utils_1.getDrawArea(container);\n            inputValues = data.values;\n\n            if (!options.rowMajor) {\n              _context.next = 7;\n              break;\n            }\n\n            _context.next = 6;\n            return convertToRowMajor(data.values);\n\n          case 6:\n            inputValues = _context.sent;\n\n          case 7:\n            // Data validation\n            xTickLabels = data.xTickLabels, yTickLabels = data.yTickLabels;\n\n            if (xTickLabels != null) {\n              dimension = 0;\n              assertLabelsMatchShape(inputValues, xTickLabels, dimension);\n            } // Note that we will only do a check on the first element of the second\n            // dimension. We do not protect users against passing in a ragged array.\n\n\n            if (yTickLabels != null) {\n              _dimension = 1;\n              assertLabelsMatchShape(inputValues, yTickLabels, _dimension);\n            } //\n            // Format data for vega spec; an array of objects, one for for each cell\n            // in the matrix.\n            //\n            // If custom labels are passed in for xTickLabels or yTickLabels we need\n            // to make sure they are 'unique' before mapping them to visual properties.\n            // We therefore append the index of the label to the datum that will be used\n            // for that label in the x or y axis. We could do this in all cases but choose\n            // not to to avoid unnecessary string operations.\n            //\n            // We use IDX_SEPARATOR to demarcate the added index\n\n\n            IDX_SEPARATOR = '@tfidx@';\n            values = [];\n\n            if (!(inputValues instanceof tf.Tensor)) {\n              _context.next = 21;\n              break;\n            }\n\n            utils_1.assert(inputValues.rank === 2, 'Input to renderHeatmap must be a 2d array or Tensor2d'); // This is a slightly specialized version of TensorBuffer.get, inlining it\n            // avoids the overhead of a function call per data element access and is\n            // specialized to only deal with the 2d case.\n\n            _context.next = 16;\n            return inputValues.data();\n\n          case 16:\n            inputArray = _context.sent;\n            _inputValues$shape = _slicedToArray(inputValues.shape, 2), numRows = _inputValues$shape[0], numCols = _inputValues$shape[1];\n\n            for (row = 0; row < numRows; row++) {\n              x = xTickLabels ? \"\".concat(xTickLabels[row]).concat(IDX_SEPARATOR).concat(row) : row;\n\n              for (col = 0; col < numCols; col++) {\n                y = yTickLabels ? \"\".concat(yTickLabels[col]).concat(IDX_SEPARATOR).concat(col) : col;\n                index = row * numCols + col;\n                value = inputArray[index];\n                values.push({\n                  x: x,\n                  y: y,\n                  value: value\n                });\n              }\n            }\n\n            _context.next = 23;\n            break;\n\n          case 21:\n            _inputArray = inputValues;\n\n            for (_row = 0; _row < _inputArray.length; _row++) {\n              _x = xTickLabels ? \"\".concat(xTickLabels[_row]).concat(IDX_SEPARATOR).concat(_row) : _row;\n\n              for (_col = 0; _col < _inputArray[_row].length; _col++) {\n                _y = yTickLabels ? \"\".concat(yTickLabels[_col]).concat(IDX_SEPARATOR).concat(_col) : _col;\n                _value = _inputArray[_row][_col];\n                values.push({\n                  x: _x,\n                  y: _y,\n                  value: _value\n                });\n              }\n            }\n\n          case 23:\n            embedOpts = {\n              actions: false,\n              mode: 'vega-lite',\n              defaultStyle: false\n            };\n            spec = {\n              'width': options.width || dom_1.getDefaultWidth(drawArea),\n              'height': options.height || dom_1.getDefaultHeight(drawArea),\n              'padding': 0,\n              'autosize': {\n                'type': 'fit',\n                'contains': 'padding',\n                'resize': true\n              },\n              'config': {\n                'axis': {\n                  'labelFontSize': options.fontSize,\n                  'titleFontSize': options.fontSize\n                },\n                'text': {\n                  'fontSize': options.fontSize\n                },\n                'legend': {\n                  'labelFontSize': options.fontSize,\n                  'titleFontSize': options.fontSize\n                },\n                'scale': {\n                  'bandPaddingInner': 0,\n                  'bandPaddingOuter': 0\n                }\n              },\n              'data': {\n                'values': values\n              },\n              'mark': {\n                'type': 'rect',\n                'tooltip': true\n              },\n              'encoding': {\n                'x': {\n                  'field': 'x',\n                  'type': options.xType,\n                  'title': options.xLabel,\n                  'sort': 'x'\n                },\n                'y': {\n                  'field': 'y',\n                  'type': options.yType,\n                  'title': options.yLabel,\n                  'sort': 'y'\n                },\n                'fill': {\n                  'field': 'value',\n                  'type': 'quantitative'\n                }\n              }\n            }; //\n            // Format custom labels to remove the appended indices\n            //\n\n            suffixPattern = \"\".concat(IDX_SEPARATOR, \"\\\\d+$\");\n            suffixRegex = new RegExp(suffixPattern);\n\n            if (xTickLabels) {\n              // @ts-ignore\n              spec.encoding.x.axis = {\n                'labelExpr': \"replace(datum.value, regexp(/\".concat(suffixPattern, \"/), '')\")\n              };\n            }\n\n            if (yTickLabels) {\n              // @ts-ignore\n              spec.encoding.y.axis = {\n                'labelExpr': \"replace(datum.value, regexp(/\".concat(suffixPattern, \"/), '')\")\n              };\n            } // Customize tooltip formatting to remove the appended indices\n\n\n            if (xTickLabels || yTickLabels) {\n              //@ts-ignore\n              embedOpts.tooltip = {\n                sanitize: function sanitize(value) {\n                  var valueString = String(value);\n                  return valueString.replace(suffixRegex, '');\n                }\n              };\n            }\n\n            _context.t0 = options.colorMap;\n            _context.next = _context.t0 === 'blues' ? 33 : _context.t0 === 'greyscale' ? 35 : _context.t0 === 'viridis' ? 37 : 37;\n            break;\n\n          case 33:\n            colorRange = ['#f7fbff', '#4292c6'];\n            return _context.abrupt(\"break\", 39);\n\n          case 35:\n            colorRange = ['#000000', '#ffffff'];\n            return _context.abrupt(\"break\", 39);\n\n          case 37:\n            colorRange = 'viridis';\n            return _context.abrupt(\"break\", 39);\n\n          case 39:\n            if (colorRange !== 'viridis') {\n              fill = spec.encoding.fill; // @ts-ignore\n\n              fill.scale = {\n                'range': colorRange\n              };\n            }\n\n            if (options.domain) {\n              _fill = spec.encoding.fill; // @ts-ignore\n\n              if (_fill.scale != null) {\n                // @ts-ignore\n                _fill.scale = Object.assign({}, _fill.scale, {\n                  'domain': options.domain\n                });\n              } else {\n                // @ts-ignore\n                _fill.scale = {\n                  'domain': options.domain\n                };\n              }\n            }\n\n            _context.next = 43;\n            return vega_embed_1.default(drawArea, spec, embedOpts);\n\n          case 43:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.heatmap = heatmap;\n\nfunction convertToRowMajor(inputValues) {\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2() {\n    var originalShape, transposed, transposedValues, transposedShape;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (inputValues instanceof tf.Tensor) {\n              originalShape = inputValues.shape;\n              transposed = inputValues.transpose();\n            } else {\n              originalShape = [inputValues.length, inputValues[0].length];\n              transposed = tf.tidy(function () {\n                return tf.tensor2d(inputValues).transpose();\n              });\n            }\n\n            utils_1.assert(transposed.rank === 2, 'Input to renderHeatmap must be a 2d array or Tensor2d'); // Download the intermediate tensor values and\n            // dispose the transposed tensor.\n\n            _context2.next = 4;\n            return transposed.array();\n\n          case 4:\n            transposedValues = _context2.sent;\n            transposed.dispose();\n            transposedShape = [transposedValues.length, transposedValues[0].length];\n            utils_1.assert(originalShape[0] === transposedShape[1] && originalShape[1] === transposedShape[0], \"Unexpected transposed shape. Original \".concat(originalShape, \" : Transposed \").concat(transposedShape));\n            return _context2.abrupt(\"return\", transposedValues);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n\nfunction assertLabelsMatchShape(inputValues, labels, dimension) {\n  var shape = inputValues instanceof tf.Tensor ? inputValues.shape : [inputValues.length, inputValues[0].length];\n\n  if (dimension === 0) {\n    utils_1.assert(shape[0] === labels.length, \"Length of xTickLabels (\".concat(labels.length, \") must match number of rows\") + \" (\".concat(shape[0], \")\"));\n  } else if (dimension === 1) {\n    utils_1.assert(shape[1] === labels.length, \"Length of yTickLabels (\".concat(labels.length, \") must match number of columns (\").concat(shape[1], \")\"));\n  }\n}\n\nvar defaultOpts = {\n  xLabel: null,\n  yLabel: null,\n  xType: 'ordinal',\n  yType: 'ordinal',\n  colorMap: 'viridis',\n  fontSize: 12,\n  domain: null,\n  rowMajor: false\n};","map":null,"metadata":{},"sourceType":"script"}