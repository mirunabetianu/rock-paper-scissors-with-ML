{"ast":null,"code":"/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\nimport { __rest } from \"tslib\";\nimport { keys } from './util'; // Facet\n\nexport var ROW = 'row';\nexport var COLUMN = 'column';\nexport var FACET = 'facet'; // Position\n\nexport var X = 'x';\nexport var Y = 'y';\nexport var X2 = 'x2';\nexport var Y2 = 'y2'; // Geo Position\n\nexport var LATITUDE = 'latitude';\nexport var LONGITUDE = 'longitude';\nexport var LATITUDE2 = 'latitude2';\nexport var LONGITUDE2 = 'longitude2'; // Mark property with scale\n\nexport var COLOR = 'color';\nexport var FILL = 'fill';\nexport var STROKE = 'stroke';\nexport var SHAPE = 'shape';\nexport var SIZE = 'size';\nexport var OPACITY = 'opacity';\nexport var FILLOPACITY = 'fillOpacity';\nexport var STROKEOPACITY = 'strokeOpacity';\nexport var STROKEWIDTH = 'strokeWidth'; // Non-scale channel\n\nexport var TEXT = 'text';\nexport var ORDER = 'order';\nexport var DETAIL = 'detail';\nexport var KEY = 'key';\nexport var TOOLTIP = 'tooltip';\nexport var HREF = 'href';\nexport var URL = 'url';\nvar POSITION_CHANNEL_INDEX = {\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1\n};\nexport function isPositionChannel(c) {\n  return c in POSITION_CHANNEL_INDEX;\n}\nexport function getPositionChannelFromLatLong(channel) {\n  switch (channel) {\n    case LATITUDE:\n      return 'y';\n\n    case LATITUDE2:\n      return 'y2';\n\n    case LONGITUDE:\n      return 'x';\n\n    case LONGITUDE2:\n      return 'x2';\n  }\n}\nvar GEOPOSITION_CHANNEL_INDEX = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\nexport function isGeoPositionChannel(c) {\n  return c in GEOPOSITION_CHANNEL_INDEX;\n}\nexport var GEOPOSITION_CHANNELS = keys(GEOPOSITION_CHANNEL_INDEX);\nvar UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), GEOPOSITION_CHANNEL_INDEX), {\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1,\n  size: 1,\n  shape: 1,\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1,\n  url: 1\n});\nexport function isColorChannel(channel) {\n  return channel === 'color' || channel === 'fill' || channel === 'stroke';\n}\nvar FACET_CHANNEL_INDEX = {\n  row: 1,\n  column: 1,\n  facet: 1\n};\nexport var FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\nvar CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);\nexport var CHANNELS = keys(CHANNEL_INDEX);\n\nvar _o = CHANNEL_INDEX.order,\n    _d = CHANNEL_INDEX.detail,\n    _tt1 = CHANNEL_INDEX.tooltip,\n    SINGLE_DEF_CHANNEL_INDEX = __rest(CHANNEL_INDEX, [\"order\", \"detail\", \"tooltip\"]);\n\nvar _r = SINGLE_DEF_CHANNEL_INDEX.row,\n    _c = SINGLE_DEF_CHANNEL_INDEX.column,\n    _f = SINGLE_DEF_CHANNEL_INDEX.facet,\n    SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest(SINGLE_DEF_CHANNEL_INDEX, [\"row\", \"column\", \"facet\"]);\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them. Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\n\nexport var SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\nexport var SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\nexport function isSingleDefUnitChannel(str) {\n  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];\n}\nexport function isChannel(str) {\n  return !!CHANNEL_INDEX[str];\n}\nexport var SECONDARY_RANGE_CHANNEL = ['x2', 'y2', 'latitude2', 'longitude2'];\nexport function isSecondaryRangeChannel(c) {\n  var main = getMainRangeChannel(c);\n  return main !== c;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getMainRangeChannel(channel) {\n  switch (channel) {\n    case 'x2':\n      return 'x';\n\n    case 'y2':\n      return 'y';\n\n    case 'latitude2':\n      return 'latitude';\n\n    case 'longitude2':\n      return 'longitude';\n  }\n\n  return channel;\n}\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\n\nexport function getSecondaryRangeChannel(channel) {\n  switch (channel) {\n    case 'x':\n      return 'x2';\n\n    case 'y':\n      return 'y2';\n\n    case 'latitude':\n      return 'latitude2';\n\n    case 'longitude':\n      return 'longitude2';\n  }\n\n  return undefined;\n} // CHANNELS without COLUMN, ROW\n\nexport var UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX); // NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\n\nvar _x = UNIT_CHANNEL_INDEX.x,\n    _y = UNIT_CHANNEL_INDEX.y,\n    _x2 = UNIT_CHANNEL_INDEX.x2,\n    _y2 = UNIT_CHANNEL_INDEX.y2,\n    _latitude = UNIT_CHANNEL_INDEX.latitude,\n    _longitude = UNIT_CHANNEL_INDEX.longitude,\n    _latitude2 = UNIT_CHANNEL_INDEX.latitude2,\n    _longitude2 = UNIT_CHANNEL_INDEX.longitude2,\n    NONPOSITION_CHANNEL_INDEX = __rest(UNIT_CHANNEL_INDEX, [\"x\", \"y\", \"x2\", \"y2\", \"latitude\", \"longitude\", \"latitude2\", \"longitude2\"]);\n\nexport var NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX); // POSITION_SCALE_CHANNELS = X and Y;\n\nvar POSITION_SCALE_CHANNEL_INDEX = {\n  x: 1,\n  y: 1\n};\nexport var POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport function getSizeType(channel) {\n  return channel === 'x' ? 'width' : 'height';\n}\nexport function getPositionScaleChannel(sizeType) {\n  return sizeType === 'width' ? 'x' : 'y';\n} // NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\n\nvar _t = NONPOSITION_CHANNEL_INDEX.text,\n    _tt = NONPOSITION_CHANNEL_INDEX.tooltip,\n    _hr = NONPOSITION_CHANNEL_INDEX.href,\n    _u = NONPOSITION_CHANNEL_INDEX.url,\n    _dd = NONPOSITION_CHANNEL_INDEX.detail,\n    _k = NONPOSITION_CHANNEL_INDEX.key,\n    _oo = NONPOSITION_CHANNEL_INDEX.order,\n    NONPOSITION_SCALE_CHANNEL_INDEX = __rest(NONPOSITION_CHANNEL_INDEX, [\"text\", \"tooltip\", \"href\", \"url\", \"detail\", \"key\", \"order\"]);\n\nexport var NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport function isNonPositionScaleChannel(channel) {\n  return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n/**\n * @returns whether Vega supports legends for a particular channel\n */\n\nexport function supportLegend(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case STROKEWIDTH:\n      return true;\n\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      return false;\n  }\n} // Declare SCALE_CHANNEL_INDEX\n\nvar SCALE_CHANNEL_INDEX = Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);\n/** List of channels with scales */\n\nexport var SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport function isScaleChannel(channel) {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\n\nexport function supportMark(channel, mark) {\n  return getSupportedMark(channel)[mark];\n}\nvar ALL_MARKS = {\n  // all marks\n  area: 'always',\n  bar: 'always',\n  circle: 'always',\n  geoshape: 'always',\n  image: 'always',\n  line: 'always',\n  rule: 'always',\n  point: 'always',\n  rect: 'always',\n  square: 'always',\n  trail: 'always',\n  text: 'always',\n  tick: 'always'\n};\n\nvar _g = ALL_MARKS.geoshape,\n    ALL_MARKS_EXCEPT_GEOSHAPE = __rest(ALL_MARKS, [\"geoshape\"]);\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\n\n\nfunction getSupportedMark(channel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE: // falls through\n\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH: // falls through\n\n    case FACET:\n    case ROW: // falls through\n\n    case COLUMN:\n      return ALL_MARKS;\n\n    case X:\n    case Y:\n    case LATITUDE:\n    case LONGITUDE:\n      // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n      return ALL_MARKS_EXCEPT_GEOSHAPE;\n\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        area: 'always',\n        bar: 'always',\n        image: 'always',\n        rect: 'always',\n        rule: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned',\n        line: 'binned',\n        trail: 'binned'\n      };\n\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n\n    case SHAPE:\n      return {\n        point: 'always',\n        geoshape: 'always'\n      };\n\n    case TEXT:\n      return {\n        text: 'always'\n      };\n\n    case URL:\n      return {\n        image: 'always'\n      };\n  }\n}\n\nexport function rangeType(channel) {\n  switch (channel) {\n    case X:\n    case Y:\n    case SIZE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY: // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n\n    case X2:\n    case Y2:\n      return undefined;\n\n    case FACET:\n    case ROW:\n    case COLUMN:\n    case SHAPE: // TEXT, TOOLTIP, URL, and HREF have no scale but have discrete output [falls through]\n\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n    case URL:\n      return 'discrete';\n    // Color can be either continuous or discrete, depending on scale type.\n\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}