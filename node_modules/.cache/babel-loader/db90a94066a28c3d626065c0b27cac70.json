{"ast":null,"code":"import Parameters from './Parameters';\nimport UniqueList from './util/UniqueList';\nimport { array, error, id, isArray } from 'vega-util';\nvar OP_ID = 0;\nvar PULSE = 'pulse';\nvar NO_PARAMS = new Parameters(); // Boolean Flags\n\nvar SKIP = 1,\n    MODIFIED = 2;\n/**\n * An Operator is a processing node in a dataflow graph.\n * Each operator stores a value and an optional value update function.\n * Operators can accept a hash of named parameters. Parameter values can\n * either be direct (JavaScript literals, arrays, objects) or indirect\n * (other operators whose values will be pulled dynamically). Operators\n * included as parameters will have this operator added as a dependency.\n * @constructor\n * @param {*} [init] - The initial value for this operator.\n * @param {function(object, Pulse)} [update] - An update function. Upon\n *   evaluation of this operator, the update function will be invoked and the\n *   return value will be used as the new value of this operator.\n * @param {object} [params] - The parameters for this operator.\n * @param {boolean} [react=true] - Flag indicating if this operator should\n *   listen for changes to upstream operators included as parameters.\n * @see parameters\n */\n\nexport default function Operator(init, update, params, react) {\n  this.id = ++OP_ID;\n  this.value = init;\n  this.stamp = -1;\n  this.rank = -1;\n  this.qrank = -1;\n  this.flags = 0;\n\n  if (update) {\n    this._update = update;\n  }\n\n  if (params) this.parameters(params, react);\n}\nvar prototype = Operator.prototype;\n/**\n * Returns a list of target operators dependent on this operator.\n * If this list does not exist, it is created and then returned.\n * @return {UniqueList}\n */\n\nprototype.targets = function () {\n  return this._targets || (this._targets = UniqueList(id));\n};\n/**\n * Sets the value of this operator.\n * @param {*} value - the value to set.\n * @return {Number} Returns 1 if the operator value has changed\n *   according to strict equality, returns 0 otherwise.\n */\n\n\nprototype.set = function (value) {\n  if (this.value !== value) {\n    this.value = value;\n    return 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction flag(bit) {\n  return function (state) {\n    var f = this.flags;\n    if (arguments.length === 0) return !!(f & bit);\n    this.flags = state ? f | bit : f & ~bit;\n    return this;\n  };\n}\n/**\n * Indicates that operator evaluation should be skipped on the next pulse.\n * This operator will still propagate incoming pulses, but its update function\n * will not be invoked. The skip flag is reset after every pulse, so calling\n * this method will affect processing of the next pulse only.\n */\n\n\nprototype.skip = flag(SKIP);\n/**\n * Indicates that this operator's value has been modified on its most recent\n * pulse. Normally modification is checked via strict equality; however, in\n * some cases it is more efficient to update the internal state of an object.\n * In those cases, the modified flag can be used to trigger propagation. Once\n * set, the modification flag persists across pulses until unset. The flag can\n * be used with the last timestamp to test if a modification is recent.\n */\n\nprototype.modified = flag(MODIFIED);\n/**\n * Sets the parameters for this operator. The parameter values are analyzed for\n * operator instances. If found, this operator will be added as a dependency\n * of the parameterizing operator. Operator values are dynamically marshalled\n * from each operator parameter prior to evaluation. If a parameter value is\n * an array, the array will also be searched for Operator instances. However,\n * the search does not recurse into sub-arrays or object properties.\n * @param {object} params - A hash of operator parameters.\n * @param {boolean} [react=true] - A flag indicating if this operator should\n *   automatically update (react) when parameter values change. In other words,\n *   this flag determines if the operator registers itself as a listener on\n *   any upstream operators included in the parameters.\n * @param {boolean} [initonly=false] - A flag indicating if this operator\n *   should calculate an update only upon its initiatal evaluation, then\n *   deregister dependencies and suppress all future update invocations.\n * @return {Operator[]} - An array of upstream dependencies.\n */\n\nprototype.parameters = function (params, react, initonly) {\n  react = react !== false;\n  var self = this,\n      argval = self._argval = self._argval || new Parameters(),\n      argops = self._argops = self._argops || [],\n      deps = [],\n      name,\n      value,\n      n,\n      i;\n\n  function add(name, index, value) {\n    if (value instanceof Operator) {\n      if (value !== self) {\n        if (react) value.targets().add(self);\n        deps.push(value);\n      }\n\n      argops.push({\n        op: value,\n        name: name,\n        index: index\n      });\n    } else {\n      argval.set(name, index, value);\n    }\n  }\n\n  for (name in params) {\n    value = params[name];\n\n    if (name === PULSE) {\n      array(value).forEach(function (op) {\n        if (!(op instanceof Operator)) {\n          error('Pulse parameters must be operator instances.');\n        } else if (op !== self) {\n          op.targets().add(self);\n          deps.push(op);\n        }\n      });\n      self.source = value;\n    } else if (isArray(value)) {\n      argval.set(name, -1, Array(n = value.length));\n\n      for (i = 0; i < n; ++i) {\n        add(name, i, value[i]);\n      }\n    } else {\n      add(name, -1, value);\n    }\n  }\n\n  this.marshall().clear(); // initialize values\n\n  if (initonly) argops.initonly = true;\n  return deps;\n};\n/**\n * Internal method for marshalling parameter values.\n * Visits each operator dependency to pull the latest value.\n * @return {Parameters} A Parameters object to pass to the update function.\n */\n\n\nprototype.marshall = function (stamp) {\n  var argval = this._argval || NO_PARAMS,\n      argops = this._argops,\n      item,\n      i,\n      n,\n      op,\n      mod;\n\n  if (argops) {\n    for (i = 0, n = argops.length; i < n; ++i) {\n      item = argops[i];\n      op = item.op;\n      mod = op.modified() && op.stamp === stamp;\n      argval.set(item.name, item.index, op.value, mod);\n    }\n\n    if (argops.initonly) {\n      for (i = 0; i < n; ++i) {\n        item = argops[i];\n        item.op.targets().remove(this);\n      }\n\n      this._argops = null;\n      this._update = null;\n    }\n  }\n\n  return argval;\n};\n/**\n * Delegate method to perform operator processing.\n * Subclasses can override this method to perform custom processing.\n * By default, it marshalls parameters and calls the update function\n * if that function is defined. If the update function does not\n * change the operator value then StopPropagation is returned.\n * If no update function is defined, this method does nothing.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return The output pulse or StopPropagation. A falsy return value\n *   (including undefined) will let the input pulse pass through.\n */\n\n\nprototype.evaluate = function (pulse) {\n  var update = this._update;\n\n  if (update) {\n    var params = this.marshall(pulse.stamp),\n        v = update.call(this, params, pulse);\n    params.clear();\n\n    if (v !== this.value) {\n      this.value = v;\n    } else if (!this.modified()) {\n      return pulse.StopPropagation;\n    }\n  }\n};\n/**\n * Run this operator for the current pulse. If this operator has already\n * been run at (or after) the pulse timestamp, returns StopPropagation.\n * Internally, this method calls {@link evaluate} to perform processing.\n * If {@link evaluate} returns a falsy value, the input pulse is returned.\n * This method should NOT be overridden, instead overrride {@link evaluate}.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return the output pulse for this operator (or StopPropagation)\n */\n\n\nprototype.run = function (pulse) {\n  if (pulse.stamp < this.stamp) return pulse.StopPropagation;\n  var rv;\n\n  if (this.skip()) {\n    this.skip(false);\n    rv = 0;\n  } else {\n    rv = this.evaluate(pulse);\n  }\n\n  return this.pulse = rv || pulse;\n};","map":null,"metadata":{},"sourceType":"module"}