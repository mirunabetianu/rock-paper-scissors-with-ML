{"ast":null,"code":"import _slicedToArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/mirunabetianu/WebstormProjects/rps/src/components/AdvancedModel/AdvancedModel.jsx\";\nimport React from 'react';\nimport { TFWrapper } from '../../tfjs/evaluationHelpers';\nimport * as tf from '@tensorflow/tfjs';\nimport { setMove as _setMove } from '../../state/game/game.actions';\nimport { connect } from 'react-redux';\nimport { createStructuredSelector } from 'reselect';\nimport { selectMove } from '../../state/game/game.selector';\nvar ADV_RPS_MODEL_URL = process.env.PUBLIC_URL + '/adv_rps/';\nvar ADV_LABELS_URL = ADV_RPS_MODEL_URL + 'labels.json';\nvar ADV_MODEL_JSON = ADV_RPS_MODEL_URL + 'model.json';\n\nvar AdvancedModel =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(AdvancedModel, _React$Component);\n\n  function AdvancedModel() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, AdvancedModel);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AdvancedModel)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.videoRef = React.createRef();\n    _this.canvasRef = React.createRef();\n    _this.state = {\n      loading: true\n    };\n\n    _this.componentWillUnmount = function () {\n      // stop and collect garbage\n      var stream = window.stream;\n      var tracks = stream.getTracks();\n      tracks.forEach(function (track) {\n        track.stop();\n      });\n      window.stream = null;\n    };\n\n    _this.detectFrame = function (video, model, labels) {\n      TFWrapper(model).detect(video).then(function (predictions) {\n        _this.renderPredictions(predictions, labels);\n\n        requestAnimationFrame(function () {\n          // calm down when hidden!\n          if (_this.canvasRef.current) {\n            _this.detectFrame(video, model, labels);\n          }\n        });\n      });\n    };\n\n    _this.renderPredictions = function (predictions, labels) {\n      if (_this.canvasRef.current) {\n        var ctx = _this.canvasRef.current.getContext('2d');\n\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Font options.\n\n        var font = '16px sans-serif';\n        ctx.font = font;\n        ctx.textBaseline = 'top';\n        predictions.forEach(function (prediction) {\n          var x = prediction.bbox[0];\n          var y = prediction.bbox[1];\n          var width = prediction.bbox[2];\n          var height = prediction.bbox[3];\n          var label = labels[parseInt(prediction.class)];\n\n          if (label !== _this.props.currentMove) {\n            _this.props.setMove(labels[parseInt(prediction.class)]);\n          } // Draw the bounding box.\n\n\n          ctx.strokeStyle = '#FF0000';\n          ctx.lineWidth = 4;\n          ctx.strokeRect(x, y, width, height); // Draw the label background.\n\n          ctx.fillStyle = '#FF0000';\n          var textWidth = ctx.measureText(label).width;\n          var textHeight = parseInt(font, 10); // base 10\n\n          ctx.fillRect(x, y, textWidth + 4, textHeight + 4);\n        });\n        predictions.forEach(function (prediction) {\n          var x = prediction.bbox[0];\n          var y = prediction.bbox[1];\n          var label = labels[parseInt(prediction.class)]; // Draw the text last to ensure it's on top.\n\n          ctx.fillStyle = '#000000';\n          ctx.fillText(label, x, y);\n        });\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(AdvancedModel, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n        var webCamPromise = navigator.mediaDevices.getUserMedia({\n          audio: false,\n          video: {\n            facingMode: 'user'\n          }\n        }).then(function (stream) {\n          window.stream = stream;\n          _this2.videoRef.current.srcObject = stream;\n          return new Promise(function (resolve, _) {\n            _this2.videoRef.current.onloadedmetadata = function () {\n              resolve();\n            };\n          });\n        });\n        var modelPromise = tf.loadGraphModel(ADV_MODEL_JSON);\n        var labelsPromise = fetch(ADV_LABELS_URL).then(function (data) {\n          return data.json();\n        });\n        Promise.all([modelPromise, labelsPromise, webCamPromise]).then(function (values) {\n          var _values = _slicedToArray(values, 2),\n              model = _values[0],\n              labels = _values[1];\n\n          _this2.setState({\n            loading: false\n          });\n\n          _this2.detectFrame(_this2.videoRef.current, model, labels);\n        }).catch(function (error) {\n          console.error(error);\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", {\n        className: \"advancedContainer\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 121\n        },\n        __self: this\n      }, this.state.loading && React.createElement(\"p\", {\n        id: \"advancedLoadText\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 123\n        },\n        __self: this\n      }, \"Please wait, loading advanced model\"), React.createElement(\"video\", {\n        className: \"advancedCam\",\n        autoPlay: true,\n        playsInline: true,\n        muted: true,\n        ref: this.videoRef,\n        width: \"600\",\n        height: \"500\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 125\n        },\n        __self: this\n      }), React.createElement(\"canvas\", {\n        className: \"advancedBox\",\n        ref: this.canvasRef,\n        width: \"600\",\n        height: \"500\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 134\n        },\n        __self: this\n      }));\n    }\n  }]);\n\n  return AdvancedModel;\n}(React.Component);\n\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    setMove: function setMove(move) {\n      return dispatch(_setMove(move));\n    }\n  };\n};\n\nvar mapStateToProps = createStructuredSelector({\n  currentMove: selectMove\n});\nexport default connect(mapStateToProps, mapDispatchToProps)(AdvancedModel);","map":{"version":3,"sources":["/Users/mirunabetianu/WebstormProjects/rps/src/components/AdvancedModel/AdvancedModel.jsx"],"names":["React","TFWrapper","tf","setMove","connect","createStructuredSelector","selectMove","ADV_RPS_MODEL_URL","process","env","PUBLIC_URL","ADV_LABELS_URL","ADV_MODEL_JSON","AdvancedModel","videoRef","createRef","canvasRef","state","loading","componentWillUnmount","stream","window","tracks","getTracks","forEach","track","stop","detectFrame","video","model","labels","detect","then","predictions","renderPredictions","requestAnimationFrame","current","ctx","getContext","clearRect","canvas","width","height","font","textBaseline","prediction","x","bbox","y","label","parseInt","class","props","currentMove","strokeStyle","lineWidth","strokeRect","fillStyle","textWidth","measureText","textHeight","fillRect","fillText","navigator","mediaDevices","getUserMedia","webCamPromise","audio","facingMode","srcObject","Promise","resolve","_","onloadedmetadata","modelPromise","loadGraphModel","labelsPromise","fetch","data","json","all","values","setState","catch","error","console","Component","mapDispatchToProps","dispatch","move","mapStateToProps"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { TFWrapper } from '../../tfjs/evaluationHelpers';\nimport * as tf from '@tensorflow/tfjs';\nimport { setMove } from '../../state/game/game.actions';\nimport { connect } from 'react-redux';\nimport { createStructuredSelector } from 'reselect';\nimport { selectMove } from '../../state/game/game.selector';\n\nconst ADV_RPS_MODEL_URL = process.env.PUBLIC_URL + '/adv_rps/';\nconst ADV_LABELS_URL = ADV_RPS_MODEL_URL + 'labels.json';\nconst ADV_MODEL_JSON = ADV_RPS_MODEL_URL + 'model.json';\n\nclass AdvancedModel extends React.Component {\n  videoRef = React.createRef();\n  canvasRef = React.createRef();\n\n  state = {\n    loading: true\n  };\n\n  componentDidMount () {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      const webCamPromise = navigator.mediaDevices\n        .getUserMedia({\n          audio: false,\n          video: {\n            facingMode: 'user'\n          }\n        })\n        .then(stream => {\n          window.stream = stream;\n          this.videoRef.current.srcObject = stream;\n          return new Promise((resolve, _) => {\n            this.videoRef.current.onloadedmetadata = () => {\n              resolve();\n            };\n          });\n        });\n\n      const modelPromise = tf.loadGraphModel(ADV_MODEL_JSON);\n      const labelsPromise = fetch(ADV_LABELS_URL).then(data => data.json());\n      Promise.all([modelPromise, labelsPromise, webCamPromise])\n        .then(values => {\n          const [model, labels] = values;\n          this.setState({ loading: false });\n          this.detectFrame(this.videoRef.current, model, labels);\n        })\n        .catch(error => {\n          console.error(error);\n        });\n    }\n  }\n\n  componentWillUnmount = () => {\n    // stop and collect garbage\n    let stream = window.stream;\n    let tracks = stream.getTracks();\n\n    tracks.forEach(track => {\n      track.stop();\n    });\n\n    window.stream = null;\n  };\n\n  detectFrame = (video, model, labels) => {\n    TFWrapper(model)\n      .detect(video)\n      .then(predictions => {\n        this.renderPredictions(predictions, labels);\n        requestAnimationFrame(() => {\n          // calm down when hidden!\n          if (this.canvasRef.current) {\n            this.detectFrame(video, model, labels);\n          }\n        });\n      });\n  };\n\n  renderPredictions = (predictions, labels) => {\n    if (this.canvasRef.current) {\n      const ctx = this.canvasRef.current.getContext('2d');\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      // Font options.\n      const font = '16px sans-serif';\n      ctx.font = font;\n      ctx.textBaseline = 'top';\n      predictions.forEach(prediction => {\n        const x = prediction.bbox[0];\n        const y = prediction.bbox[1];\n        const width = prediction.bbox[2];\n        const height = prediction.bbox[3];\n        const label = labels[parseInt(prediction.class)];\n        if (label !== this.props.currentMove) {\n          this.props.setMove(labels[parseInt(prediction.class)]);\n        }\n        // Draw the bounding box.\n        ctx.strokeStyle = '#FF0000';\n        ctx.lineWidth = 4;\n        ctx.strokeRect(x, y, width, height);\n        // Draw the label background.\n        ctx.fillStyle = '#FF0000';\n        const textWidth = ctx.measureText(label).width;\n        const textHeight = parseInt(font, 10); // base 10\n        ctx.fillRect(x, y, textWidth + 4, textHeight + 4);\n      });\n\n      predictions.forEach(prediction => {\n        const x = prediction.bbox[0];\n        const y = prediction.bbox[1];\n        const label = labels[parseInt(prediction.class)];\n        // Draw the text last to ensure it's on top.\n        ctx.fillStyle = '#000000';\n        ctx.fillText(label, x, y);\n      });\n    }\n  };\n\n  render () {\n    return (\n      <div className=\"advancedContainer\">\n        {this.state.loading && (\n          <p id=\"advancedLoadText\">Please wait, loading advanced model</p>\n        )}\n        <video\n          className=\"advancedCam\"\n          autoPlay\n          playsInline\n          muted\n          ref={this.videoRef}\n          width=\"600\"\n          height=\"500\"\n        />\n        <canvas\n          className=\"advancedBox\"\n          ref={this.canvasRef}\n          width=\"600\"\n          height=\"500\"\n        />\n      </div>\n    );\n  }\n}\n\nconst mapDispatchToProps = dispatch => ({\n  setMove: move => dispatch(setMove(move))\n});\n\nconst mapStateToProps = createStructuredSelector({\n  currentMove: selectMove\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(AdvancedModel);"]},"metadata":{},"sourceType":"module"}