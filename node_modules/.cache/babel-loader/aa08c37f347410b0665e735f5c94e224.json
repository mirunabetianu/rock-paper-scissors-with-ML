{"ast":null,"code":"/**\n * Parse an event selector string.\n * Returns an array of event stream definitions.\n */\nexport default function (selector, source, marks) {\n  DEFAULT_SOURCE = source || VIEW;\n  MARKS = marks || DEFAULT_MARKS;\n  return parseMerge(selector.trim()).map(parseSelector);\n}\nvar VIEW = 'view',\n    LBRACK = '[',\n    RBRACK = ']',\n    LBRACE = '{',\n    RBRACE = '}',\n    COLON = ':',\n    COMMA = ',',\n    NAME = '@',\n    GT = '>',\n    ILLEGAL = /[[\\]{}]/,\n    DEFAULT_SOURCE,\n    MARKS,\n    DEFAULT_MARKS = {\n  '*': 1,\n  arc: 1,\n  area: 1,\n  group: 1,\n  image: 1,\n  line: 1,\n  path: 1,\n  rect: 1,\n  rule: 1,\n  shape: 1,\n  symbol: 1,\n  text: 1,\n  trail: 1\n};\n\nfunction isMarkType(type) {\n  return MARKS[type];\n}\n\nfunction find(s, i, endChar, pushChar, popChar) {\n  var count = 0,\n      n = s.length,\n      c;\n\n  for (; i < n; ++i) {\n    c = s[i];\n    if (!count && c === endChar) return i;else if (popChar && popChar.indexOf(c) >= 0) --count;else if (pushChar && pushChar.indexOf(c) >= 0) ++count;\n  }\n\n  return i;\n}\n\nfunction parseMerge(s) {\n  var output = [],\n      start = 0,\n      n = s.length,\n      i = 0;\n\n  while (i < n) {\n    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);\n    output.push(s.substring(start, i).trim());\n    start = ++i;\n  }\n\n  if (output.length === 0) {\n    throw 'Empty event selector: ' + s;\n  }\n\n  return output;\n}\n\nfunction parseSelector(s) {\n  return s[0] === '[' ? parseBetween(s) : parseStream(s);\n}\n\nfunction parseBetween(s) {\n  var n = s.length,\n      i = 1,\n      b,\n      stream;\n  i = find(s, i, RBRACK, LBRACK, RBRACK);\n\n  if (i === n) {\n    throw 'Empty between selector: ' + s;\n  }\n\n  b = parseMerge(s.substring(1, i));\n\n  if (b.length !== 2) {\n    throw 'Between selector must have two elements: ' + s;\n  }\n\n  s = s.slice(i + 1).trim();\n\n  if (s[0] !== GT) {\n    throw 'Expected \\'>\\' after between selector: ' + s;\n  }\n\n  b = b.map(parseSelector);\n  stream = parseSelector(s.slice(1).trim());\n\n  if (stream.between) {\n    return {\n      between: b,\n      stream: stream\n    };\n  } else {\n    stream.between = b;\n  }\n\n  return stream;\n}\n\nfunction parseStream(s) {\n  var stream = {\n    source: DEFAULT_SOURCE\n  },\n      source = [],\n      throttle = [0, 0],\n      markname = 0,\n      start = 0,\n      n = s.length,\n      i = 0,\n      j,\n      filter; // extract throttle from end\n\n  if (s[n - 1] === RBRACE) {\n    i = s.lastIndexOf(LBRACE);\n\n    if (i >= 0) {\n      try {\n        throttle = parseThrottle(s.substring(i + 1, n - 1));\n      } catch (e) {\n        throw 'Invalid throttle specification: ' + s;\n      }\n\n      s = s.slice(0, i).trim();\n      n = s.length;\n    } else throw 'Unmatched right brace: ' + s;\n\n    i = 0;\n  }\n\n  if (!n) throw s; // set name flag based on first char\n\n  if (s[0] === NAME) markname = ++i; // extract first part of multi-part stream selector\n\n  j = find(s, i, COLON);\n\n  if (j < n) {\n    source.push(s.substring(start, j).trim());\n    start = i = ++j;\n  } // extract remaining part of stream selector\n\n\n  i = find(s, i, LBRACK);\n\n  if (i === n) {\n    source.push(s.substring(start, n).trim());\n  } else {\n    source.push(s.substring(start, i).trim());\n    filter = [];\n    start = ++i;\n    if (start === n) throw 'Unmatched left bracket: ' + s;\n  } // extract filters\n\n\n  while (i < n) {\n    i = find(s, i, RBRACK);\n    if (i === n) throw 'Unmatched left bracket: ' + s;\n    filter.push(s.substring(start, i).trim());\n    if (i < n - 1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;\n    start = ++i;\n  } // marshall event stream specification\n\n\n  if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {\n    throw 'Invalid event selector: ' + s;\n  }\n\n  if (n > 1) {\n    stream.type = source[1];\n\n    if (markname) {\n      stream.markname = source[0].slice(1);\n    } else if (isMarkType(source[0])) {\n      stream.marktype = source[0];\n    } else {\n      stream.source = source[0];\n    }\n  } else {\n    stream.type = source[0];\n  }\n\n  if (stream.type.slice(-1) === '!') {\n    stream.consume = true;\n    stream.type = stream.type.slice(0, -1);\n  }\n\n  if (filter != null) stream.filter = filter;\n  if (throttle[0]) stream.throttle = throttle[0];\n  if (throttle[1]) stream.debounce = throttle[1];\n  return stream;\n}\n\nfunction parseThrottle(s) {\n  var a = s.split(COMMA);\n  if (!s.length || a.length > 2) throw s;\n  return a.map(function (_) {\n    var x = +_;\n    if (x !== x) throw s;\n    return x;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}