{"ast":null,"code":"import { Transform } from 'vega-dataflow';\nimport { bin } from 'vega-statistics';\nimport { inherits, accessor, accessorFields, accessorName } from 'vega-util'; // epsilon bias to offset floating point error (#1737)\n\nvar EPSILON = 1e-14;\n/**\n * Generates a binning function for discretizing data.\n * @constructor\n * @param {object} params - The parameters for this operator. The\n *   provided values should be valid options for the {@link bin} function.\n * @param {function(object): *} params.field - The data field to bin.\n */\n\nexport default function Bin(params) {\n  Transform.call(this, null, params);\n}\nBin.Definition = {\n  \"type\": \"Bin\",\n  \"metadata\": {\n    \"modifies\": true\n  },\n  \"params\": [{\n    \"name\": \"field\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"interval\",\n    \"type\": \"boolean\",\n    \"default\": true\n  }, {\n    \"name\": \"anchor\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"maxbins\",\n    \"type\": \"number\",\n    \"default\": 20\n  }, {\n    \"name\": \"base\",\n    \"type\": \"number\",\n    \"default\": 10\n  }, {\n    \"name\": \"divide\",\n    \"type\": \"number\",\n    \"array\": true,\n    \"default\": [5, 2]\n  }, {\n    \"name\": \"extent\",\n    \"type\": \"number\",\n    \"array\": true,\n    \"length\": 2,\n    \"required\": true\n  }, {\n    \"name\": \"span\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"step\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"steps\",\n    \"type\": \"number\",\n    \"array\": true\n  }, {\n    \"name\": \"minstep\",\n    \"type\": \"number\",\n    \"default\": 0\n  }, {\n    \"name\": \"nice\",\n    \"type\": \"boolean\",\n    \"default\": true\n  }, {\n    \"name\": \"name\",\n    \"type\": \"string\"\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"array\": true,\n    \"length\": 2,\n    \"default\": [\"bin0\", \"bin1\"]\n  }]\n};\nvar prototype = inherits(Bin, Transform);\n\nprototype.transform = function (_, pulse) {\n  var band = _.interval !== false,\n      bins = this._bins(_),\n      start = bins.start,\n      step = bins.step,\n      as = _.as || ['bin0', 'bin1'],\n      b0 = as[0],\n      b1 = as[1],\n      flag;\n\n  if (_.modified()) {\n    pulse = pulse.reflow(true);\n    flag = pulse.SOURCE;\n  } else {\n    flag = pulse.modified(accessorFields(_.field)) ? pulse.ADD_MOD : pulse.ADD;\n  }\n\n  pulse.visit(flag, band ? function (t) {\n    var v = bins(t); // minimum bin value (inclusive)\n\n    t[b0] = v; // maximum bin value (exclusive)\n    // use convoluted math for better floating point agreement\n    // see https://github.com/vega/vega/issues/830\n    // infinite values propagate through this formula! #2227\n\n    t[b1] = v == null ? null : start + step * (1 + (v - start) / step);\n  } : function (t) {\n    t[b0] = bins(t);\n  });\n  return pulse.modifies(band ? as : b0);\n};\n\nprototype._bins = function (_) {\n  if (this.value && !_.modified()) {\n    return this.value;\n  }\n\n  var field = _.field,\n      bins = bin(_),\n      step = bins.step,\n      start = bins.start,\n      stop = start + Math.ceil((bins.stop - start) / step) * step,\n      a,\n      d;\n\n  if ((a = _.anchor) != null) {\n    d = a - (start + step * Math.floor((a - start) / step));\n    start += d;\n    stop += d;\n  }\n\n  var f = function f(t) {\n    var v = field(t);\n    return v == null ? null : v < start ? -Infinity : v > stop ? +Infinity : (v = Math.max(start, Math.min(+v, stop - step)), start + step * Math.floor(EPSILON + (v - start) / step));\n  };\n\n  f.start = start;\n  f.stop = bins.stop;\n  f.step = step;\n  return this.value = accessor(f, accessorFields(field), _.name || 'bin_' + accessorName(field));\n};","map":null,"metadata":{},"sourceType":"module"}