{"ast":null,"code":"import _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport { isArray } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { COLUMN, FACET_CHANNELS, ROW } from '../channel';\nimport { normalize, vgField } from '../channeldef';\nimport { reduce } from '../encoding';\nimport * as log from '../log';\nimport { hasDiscreteDomain } from '../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../sort';\nimport { isFacetMapping } from '../spec/facet';\nimport { contains } from '../util';\nimport { isVgRangeStep } from '../vega.schema';\nimport { buildModel } from './buildmodel';\nimport { assembleFacetData } from './data/assemble';\nimport { sortArrayIndexField } from './data/calculate';\nimport { parseData as _parseData } from './data/parse';\nimport { assembleLabelTitle as _assembleLabelTitle } from './header/assemble';\nimport { getHeaderChannel, getHeaderProperty } from './header/common';\nimport { HEADER_CHANNELS, HEADER_TYPES } from './header/component';\nimport { parseFacetHeaders } from './header/parse';\nimport { parseChildrenLayoutSize } from './layoutsize/parse';\nimport { ModelWithField } from './model';\nimport { replaceRepeaterInFacet } from './repeater';\nimport { assembleDomain, getFieldFromDomain } from './scale/domain';\nimport { assembleFacetSignals } from './selection/assemble';\nexport function facetSortFieldName(fieldDef, sort, opt) {\n  return vgField(sort, Object.assign({\n    suffix: \"by_\".concat(vgField(fieldDef))\n  }, opt !== null && opt !== void 0 ? opt : {}));\n}\nexport var FacetModel =\n/*#__PURE__*/\nfunction (_ModelWithField) {\n  _inherits(FacetModel, _ModelWithField);\n\n  function FacetModel(spec, parent, parentGivenName, repeater, config) {\n    var _this;\n\n    _classCallCheck(this, FacetModel);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FacetModel).call(this, spec, 'facet', parent, parentGivenName, config, repeater, spec.resolve));\n    _this.child = buildModel(spec.spec, _assertThisInitialized(_assertThisInitialized(_this)), _this.getName('child'), undefined, repeater, config);\n    _this.children = [_this.child];\n    var facet = replaceRepeaterInFacet(spec.facet, repeater);\n    _this.facet = _this.initFacet(facet);\n    return _this;\n  }\n\n  _createClass(FacetModel, [{\n    key: \"initFacet\",\n    value: function initFacet(facet) {\n      // clone to prevent side effect to the original spec\n      if (!isFacetMapping(facet)) {\n        return {\n          facet: normalize(facet, 'facet')\n        };\n      }\n\n      return reduce(facet, function (normalizedFacet, fieldDef, channel) {\n        if (!contains([ROW, COLUMN], channel)) {\n          // Drop unsupported channel\n          log.warn(log.message.incompatibleChannel(channel, 'facet'));\n          return normalizedFacet;\n        }\n\n        if (fieldDef.field === undefined) {\n          log.warn(log.message.emptyFieldDef(fieldDef, channel));\n          return normalizedFacet;\n        } // Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n\n\n        normalizedFacet[channel] = normalize(fieldDef, channel);\n        return normalizedFacet;\n      }, {});\n    }\n  }, {\n    key: \"channelHasField\",\n    value: function channelHasField(channel) {\n      return !!this.facet[channel];\n    }\n  }, {\n    key: \"fieldDef\",\n    value: function fieldDef(channel) {\n      return this.facet[channel];\n    }\n  }, {\n    key: \"parseData\",\n    value: function parseData() {\n      this.component.data = _parseData(this);\n      this.child.parseData();\n    }\n  }, {\n    key: \"parseLayoutSize\",\n    value: function parseLayoutSize() {\n      parseChildrenLayoutSize(this);\n    }\n  }, {\n    key: \"parseSelections\",\n    value: function parseSelections() {\n      // As a facet has a single child, the selection components are the same.\n      // The child maintains its selections to assemble signals, which remain\n      // within its unit.\n      this.child.parseSelections();\n      this.component.selection = this.child.component.selection;\n    }\n  }, {\n    key: \"parseMarkGroup\",\n    value: function parseMarkGroup() {\n      this.child.parseMarkGroup();\n    }\n  }, {\n    key: \"parseAxesAndHeaders\",\n    value: function parseAxesAndHeaders() {\n      this.child.parseAxesAndHeaders();\n      parseFacetHeaders(this);\n    }\n  }, {\n    key: \"assembleSelectionTopLevelSignals\",\n    value: function assembleSelectionTopLevelSignals(signals) {\n      return this.child.assembleSelectionTopLevelSignals(signals);\n    }\n  }, {\n    key: \"assembleSignals\",\n    value: function assembleSignals() {\n      this.child.assembleSignals();\n      return [];\n    }\n  }, {\n    key: \"assembleSelectionData\",\n    value: function assembleSelectionData(data) {\n      return this.child.assembleSelectionData(data);\n    }\n  }, {\n    key: \"getHeaderLayoutMixins\",\n    value: function getHeaderLayoutMixins() {\n      var _a, _b, _c, _d;\n\n      var layoutMixins = {};\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = FACET_CHANNELS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var channel = _step.value;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = HEADER_TYPES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var headerType = _step2.value;\n              var layoutHeaderComponent = this.component.layoutHeaders[channel];\n              var headerComponent = layoutHeaderComponent[headerType];\n              var facetFieldDef = layoutHeaderComponent.facetFieldDef;\n\n              if (facetFieldDef) {\n                var titleOrient = getHeaderProperty('titleOrient', facetFieldDef, this.config, channel);\n\n                if (contains(['right', 'bottom'], titleOrient)) {\n                  var headerChannel = getHeaderChannel(channel, titleOrient);\n                  layoutMixins.titleAnchor = (_a = layoutMixins.titleAnchor, _a !== null && _a !== void 0 ? _a : {});\n                  layoutMixins.titleAnchor[headerChannel] = 'end';\n                }\n              }\n\n              if ((_b = headerComponent) === null || _b === void 0 ? void 0 : _b[0]) {\n                // set header/footerBand\n                var sizeType = channel === 'row' ? 'height' : 'width';\n                var bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n\n                if (channel !== 'facet' && !this.child.component.layoutSize.get(sizeType)) {\n                  // If facet child does not have size signal, then apply headerBand\n                  layoutMixins[bandType] = (_c = layoutMixins[bandType], _c !== null && _c !== void 0 ? _c : {});\n                  layoutMixins[bandType][channel] = 0.5;\n                }\n\n                if (layoutHeaderComponent.title) {\n                  layoutMixins.offset = (_d = layoutMixins.offset, _d !== null && _d !== void 0 ? _d : {});\n                  layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return layoutMixins;\n    }\n  }, {\n    key: \"assembleDefaultLayout\",\n    value: function assembleDefaultLayout() {\n      var _this$facet = this.facet,\n          column = _this$facet.column,\n          row = _this$facet.row;\n      var columns = column ? this.columnDistinctSignal() : row ? 1 : undefined;\n      var align = 'all'; // Do not align the cells if the scale corresponding to the direction is indepent.\n      // We always align when we facet into both row and column.\n\n      if (!row && this.component.resolve.scale.x === 'independent') {\n        align = 'none';\n      } else if (!column && this.component.resolve.scale.y === 'independent') {\n        align = 'none';\n      }\n\n      return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), columns ? {\n        columns: columns\n      } : {}), {\n        bounds: 'full',\n        align: align\n      });\n    }\n  }, {\n    key: \"assembleLayoutSignals\",\n    value: function assembleLayoutSignals() {\n      // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n      return this.child.assembleLayoutSignals();\n    }\n  }, {\n    key: \"columnDistinctSignal\",\n    value: function columnDistinctSignal() {\n      if (this.parent && this.parent instanceof FacetModel) {\n        // For nested facet, we will add columns to group mark instead\n        // See discussion in https://github.com/vega/vega/issues/952\n        // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n        return undefined;\n      } else {\n        // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n        var facetLayoutDataName = this.getName('column_domain');\n        return {\n          signal: \"length(data('\".concat(facetLayoutDataName, \"'))\")\n        };\n      }\n    }\n  }, {\n    key: \"assembleGroup\",\n    value: function assembleGroup(signals) {\n      if (this.parent && this.parent instanceof FacetModel) {\n        // Provide number of columns for layout.\n        // See discussion in https://github.com/vega/vega/issues/952\n        // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n        return Object.assign(Object.assign({}, this.channelHasField('column') ? {\n          encode: {\n            update: {\n              // TODO(https://github.com/vega/vega-lite/issues/2759):\n              // Correct the signal for facet of concat of facet_column\n              columns: {\n                field: vgField(this.facet.column, {\n                  prefix: 'distinct'\n                })\n              }\n            }\n          }\n        } : {}), _get(_getPrototypeOf(FacetModel.prototype), \"assembleGroup\", this).call(this, signals));\n      }\n\n      return _get(_getPrototypeOf(FacetModel.prototype), \"assembleGroup\", this).call(this, signals);\n    }\n    /**\n     * Aggregate cardinality for calculating size\n     */\n\n  }, {\n    key: \"getCardinalityAggregateForChild\",\n    value: function getCardinalityAggregateForChild() {\n      var fields = [];\n      var ops = [];\n      var as = [];\n\n      if (this.child instanceof FacetModel) {\n        if (this.child.channelHasField('column')) {\n          var field = vgField(this.child.facet.column);\n          fields.push(field);\n          ops.push('distinct');\n          as.push(\"distinct_\".concat(field));\n        }\n      } else {\n        for (var _i = 0, _arr = ['x', 'y']; _i < _arr.length; _i++) {\n          var channel = _arr[_i];\n          var childScaleComponent = this.child.component.scales[channel];\n\n          if (childScaleComponent && !childScaleComponent.merged) {\n            var type = childScaleComponent.get('type');\n            var range = childScaleComponent.get('range');\n\n            if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n              var domain = assembleDomain(this.child, channel);\n\n              var _field = getFieldFromDomain(domain);\n\n              if (_field) {\n                fields.push(_field);\n                ops.push('distinct');\n                as.push(\"distinct_\".concat(_field));\n              } else {\n                log.warn(\"Unknown field for \".concat(channel, \". Cannot calculate view size.\"));\n              }\n            }\n          }\n        }\n      }\n\n      return {\n        fields: fields,\n        ops: ops,\n        as: as\n      };\n    }\n  }, {\n    key: \"assembleFacet\",\n    value: function assembleFacet() {\n      var _this$component$data$ = this.component.data.facetRoot,\n          name = _this$component$data$.name,\n          data = _this$component$data$.data;\n      var _this$facet2 = this.facet,\n          row = _this$facet2.row,\n          column = _this$facet2.column;\n\n      var _this$getCardinalityA = this.getCardinalityAggregateForChild(),\n          fields = _this$getCardinalityA.fields,\n          ops = _this$getCardinalityA.ops,\n          as = _this$getCardinalityA.as;\n\n      var groupby = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = FACET_CHANNELS[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var channel = _step3.value;\n          var fieldDef = this.facet[channel];\n\n          if (fieldDef) {\n            groupby.push(vgField(fieldDef));\n            var bin = fieldDef.bin,\n                sort = fieldDef.sort;\n\n            if (isBinning(bin)) {\n              groupby.push(vgField(fieldDef, {\n                binSuffix: 'end'\n              }));\n            }\n\n            if (isSortField(sort)) {\n              var field = sort.field,\n                  _sort$op = sort.op,\n                  op = _sort$op === void 0 ? DEFAULT_SORT_OP : _sort$op;\n              var outputName = facetSortFieldName(fieldDef, sort);\n\n              if (row && column) {\n                // For crossed facet, use pre-calculate field as it requires a different groupby\n                // For each calculated field, apply max and assign them to the same name as\n                // all values of the same group should be the same anyway.\n                fields.push(outputName);\n                ops.push('max');\n                as.push(outputName);\n              } else {\n                fields.push(field);\n                ops.push(op);\n                as.push(outputName);\n              }\n            } else if (isArray(sort)) {\n              var _outputName = sortArrayIndexField(fieldDef, channel);\n\n              fields.push(_outputName);\n              ops.push('max');\n              as.push(_outputName);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var cross = !!row && !!column;\n      return Object.assign({\n        name: name,\n        data: data,\n        groupby: groupby\n      }, cross || fields.length > 0 ? {\n        aggregate: Object.assign(Object.assign({}, cross ? {\n          cross: cross\n        } : {}), fields.length ? {\n          fields: fields,\n          ops: ops,\n          as: as\n        } : {})\n      } : {});\n    }\n  }, {\n    key: \"facetSortFields\",\n    value: function facetSortFields(channel) {\n      var facet = this.facet;\n      var fieldDef = facet[channel];\n\n      if (fieldDef) {\n        if (isSortField(fieldDef.sort)) {\n          return [facetSortFieldName(fieldDef, fieldDef.sort, {\n            expr: 'datum'\n          })];\n        } else if (isArray(fieldDef.sort)) {\n          return [sortArrayIndexField(fieldDef, channel, {\n            expr: 'datum'\n          })];\n        }\n\n        return [vgField(fieldDef, {\n          expr: 'datum'\n        })];\n      }\n\n      return [];\n    }\n  }, {\n    key: \"facetSortOrder\",\n    value: function facetSortOrder(channel) {\n      var facet = this.facet;\n      var fieldDef = facet[channel];\n\n      if (fieldDef) {\n        var sort = fieldDef.sort;\n        var order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n        return [order];\n      }\n\n      return [];\n    }\n  }, {\n    key: \"assembleLabelTitle\",\n    value: function assembleLabelTitle() {\n      var facet = this.facet,\n          config = this.config;\n\n      if (facet.facet) {\n        // Facet always uses title to display labels\n        return _assembleLabelTitle(facet.facet, 'facet', config);\n      }\n\n      var ORTHOGONAL_ORIENT = {\n        row: ['top', 'bottom'],\n        column: ['left', 'right']\n      };\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = HEADER_CHANNELS[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var channel = _step4.value;\n\n          if (facet[channel]) {\n            var labelOrient = getHeaderProperty('labelOrient', facet[channel], config, channel);\n\n            if (contains(ORTHOGONAL_ORIENT[channel], labelOrient)) {\n              // Row/Column with orthogonal labelOrient must use title to display labels\n              return _assembleLabelTitle(facet[channel], channel, config);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"assembleMarks\",\n    value: function assembleMarks() {\n      var _this2 = this;\n\n      var child = this.child; // If we facet by two dimensions, we need to add a cross operator to the aggregation\n      // so that we create all groups\n\n      var facetRoot = this.component.data.facetRoot;\n      var data = assembleFacetData(facetRoot);\n      var encodeEntry = child.assembleGroupEncodeEntry(false);\n      var title = this.assembleLabelTitle() || child.assembleTitle();\n      var style = child.assembleGroupStyle();\n      var markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        name: this.getName('cell'),\n        type: 'group'\n      }, title ? {\n        title: title\n      } : {}), style ? {\n        style: style\n      } : {}), {\n        from: {\n          facet: this.assembleFacet()\n        },\n        // TODO: move this to after data\n        sort: {\n          field: FACET_CHANNELS.map(function (c) {\n            return _this2.facetSortFields(c);\n          }).flat(),\n          order: FACET_CHANNELS.map(function (c) {\n            return _this2.facetSortOrder(c);\n          }).flat()\n        }\n      }), data.length > 0 ? {\n        data: data\n      } : {}), encodeEntry ? {\n        encode: {\n          update: encodeEntry\n        }\n      } : {}), child.assembleGroup(assembleFacetSignals(this, [])));\n      return [markGroup];\n    }\n  }, {\n    key: \"getMapping\",\n    value: function getMapping() {\n      return this.facet;\n    }\n  }]);\n\n  return FacetModel;\n}(ModelWithField);","map":null,"metadata":{},"sourceType":"module"}