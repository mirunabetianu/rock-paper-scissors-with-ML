{"ast":null,"code":"import _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { isArgmaxDef, isArgminDef } from '../../aggregate';\nimport { getPositionChannelFromLatLong, getSecondaryRangeChannel, isGeoPositionChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBand, isTypedFieldDef, vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { duplicate, hash as _hash, keys, replacePathInField, setEqual } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\n\nfunction addDimension(dims, channel, fieldDef, model) {\n  var channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n\n  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.markDef, model.config)) {\n    dims.add(vgField(fieldDef, {}));\n    dims.add(vgField(fieldDef, {\n      suffix: 'end'\n    }));\n\n    if (binRequiresRange(fieldDef, channel)) {\n      dims.add(vgField(fieldDef, {\n        binSuffix: 'range'\n      }));\n    }\n  } else if (isGeoPositionChannel(channel)) {\n    var posChannel = getPositionChannelFromLatLong(channel);\n    dims.add(model.getName(posChannel));\n  } else {\n    dims.add(vgField(fieldDef));\n  }\n\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures, childMeasures) {\n  var _a;\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = keys(childMeasures)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var field = _step.value;\n      // when we merge a measure, we either have to add an aggregation operator or even a new field\n      var ops = childMeasures[field];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = keys(ops)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var op = _step2.value;\n\n          if (field in parentMeasures) {\n            // add operator to existing measure field\n            parentMeasures[field][op] = new Set([].concat(_toConsumableArray((_a = parentMeasures[field][op], _a !== null && _a !== void 0 ? _a : [])), _toConsumableArray(ops[op])));\n          } else {\n            parentMeasures[field] = _defineProperty({}, op, ops[op]);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nexport var AggregateNode =\n/*#__PURE__*/\nfunction (_DataFlowNode) {\n  _inherits(AggregateNode, _DataFlowNode);\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  function AggregateNode(parent, dimensions, measures) {\n    var _this;\n\n    _classCallCheck(this, AggregateNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AggregateNode).call(this, parent));\n    _this.dimensions = dimensions;\n    _this.measures = measures;\n    return _this;\n  }\n\n  _createClass(AggregateNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (setEqual(this.dimensions, other.dimensions)) {\n        mergeMeasures(this.measures, other.measures);\n        return true;\n      } else {\n        log.debug('different dimensions, cannot merge');\n        return false;\n      }\n    }\n  }, {\n    key: \"addDimensions\",\n    value: function addDimensions(fields) {\n      fields.forEach(this.dimensions.add, this.dimensions);\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set([].concat(_toConsumableArray(this.dimensions), _toConsumableArray(keys(this.measures))));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      var out = new Set();\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = keys(this.measures)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var field = _step3.value;\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = keys(this.measures[field])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var op = _step4.value;\n              var m = this.measures[field][op];\n\n              if (m.size === 0) {\n                out.add(\"\".concat(op, \"_\").concat(field));\n              } else {\n                m.forEach(out.add, out);\n              }\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                _iterator4.return();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return out;\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Aggregate \".concat(_hash({\n        dimensions: this.dimensions,\n        measures: this.measures\n      }));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var ops = [];\n      var fields = [];\n      var as = [];\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = keys(this.measures)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var field = _step5.value;\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            for (var _iterator6 = keys(this.measures[field])[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var op = _step6.value;\n              var _iteratorNormalCompletion7 = true;\n              var _didIteratorError7 = false;\n              var _iteratorError7 = undefined;\n\n              try {\n                for (var _iterator7 = this.measures[field][op][Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                  var alias = _step7.value;\n                  as.push(alias);\n                  ops.push(op);\n                  fields.push(field === '*' ? null : replacePathInField(field));\n                }\n              } catch (err) {\n                _didIteratorError7 = true;\n                _iteratorError7 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                    _iterator7.return();\n                  }\n                } finally {\n                  if (_didIteratorError7) {\n                    throw _iteratorError7;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      var result = {\n        type: 'aggregate',\n        groupby: _toConsumableArray(this.dimensions),\n        ops: ops,\n        fields: fields,\n        as: as\n      };\n      return result;\n    }\n  }, {\n    key: \"groupBy\",\n    get: function get() {\n      return this.dimensions;\n    }\n  }], [{\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var isAggregate = false;\n      model.forEachFieldDef(function (fd) {\n        if (fd.aggregate) {\n          isAggregate = true;\n        }\n      });\n      var meas = {};\n      var dims = new Set();\n\n      if (!isAggregate) {\n        // no need to create this node if the model has no aggregation\n        return null;\n      }\n\n      model.forEachFieldDef(function (fieldDef, channel) {\n        var _a, _b, _c, _d;\n\n        var aggregate = fieldDef.aggregate,\n            field = fieldDef.field;\n\n        if (aggregate) {\n          if (aggregate === 'count') {\n            meas['*'] = (_a = meas['*'], _a !== null && _a !== void 0 ? _a : {});\n            meas['*']['count'] = new Set([vgField(fieldDef, {\n              forAs: true\n            })]);\n          } else {\n            if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n              var op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n              var argField = aggregate[op];\n              meas[argField] = (_b = meas[argField], _b !== null && _b !== void 0 ? _b : {});\n              meas[argField][op] = new Set([vgField({\n                op: op,\n                field: argField\n              }, {\n                forAs: true\n              })]);\n            } else {\n              meas[field] = (_c = meas[field], _c !== null && _c !== void 0 ? _c : {});\n              meas[field][aggregate] = new Set([vgField(fieldDef, {\n                forAs: true\n              })]);\n            } // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n\n\n            if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n              meas[field] = (_d = meas[field], _d !== null && _d !== void 0 ? _d : {});\n              meas[field]['min'] = new Set([vgField({\n                field: field,\n                aggregate: 'min'\n              }, {\n                forAs: true\n              })]);\n              meas[field]['max'] = new Set([vgField({\n                field: field,\n                aggregate: 'max'\n              }, {\n                forAs: true\n              })]);\n            }\n          }\n        } else {\n          addDimension(dims, channel, fieldDef, model);\n        }\n      });\n\n      if (dims.size + keys(meas).length === 0) {\n        return null;\n      }\n\n      return new AggregateNode(parent, dims, meas);\n    }\n  }, {\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, t) {\n      var _a, _b, _c;\n\n      var dims = new Set();\n      var meas = {};\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = t.aggregate[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var s = _step8.value;\n          var op = s.op,\n              field = s.field,\n              as = s.as;\n\n          if (op) {\n            if (op === 'count') {\n              meas['*'] = (_a = meas['*'], _a !== null && _a !== void 0 ? _a : {});\n              meas['*']['count'] = new Set([as ? as : vgField(s, {\n                forAs: true\n              })]);\n            } else {\n              meas[field] = (_b = meas[field], _b !== null && _b !== void 0 ? _b : {});\n              meas[field][op] = new Set([as ? as : vgField(s, {\n                forAs: true\n              })]);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = (_c = t.groupby, _c !== null && _c !== void 0 ? _c : [])[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var _s = _step9.value;\n          dims.add(_s);\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      if (dims.size + keys(meas).length === 0) {\n        return null;\n      }\n\n      return new AggregateNode(parent, dims, meas);\n    }\n  }]);\n\n  return AggregateNode;\n}(DataFlowNode);","map":null,"metadata":{},"sourceType":"module"}