{"ast":null,"code":"import _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { isScaleFieldDef, vgField } from '../../channeldef';\nimport { fieldFilterExpression } from '../../predicate';\nimport { isSortArray } from '../../sort';\nimport { duplicate, hash as _hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport var CalculateNode =\n/*#__PURE__*/\nfunction (_DataFlowNode) {\n  _inherits(CalculateNode, _DataFlowNode);\n\n  function CalculateNode(parent, transform) {\n    var _this;\n\n    _classCallCheck(this, CalculateNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CalculateNode).call(this, parent));\n    _this.transform = transform;\n    _this._dependentFields = getDependentFields(_this.transform.calculate);\n    return _this;\n  }\n\n  _createClass(CalculateNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new CalculateNode(null, duplicate(this.transform));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set([this.transform.as]);\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return this._dependentFields;\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      return {\n        type: 'formula',\n        expr: this.transform.calculate,\n        as: this.transform.as\n      };\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Calculate \".concat(_hash(this.transform));\n    }\n  }], [{\n    key: \"parseAllForSortIndex\",\n    value: function parseAllForSortIndex(parent, model) {\n      // get all the encoding with sort fields from model\n      model.forEachFieldDef(function (fieldDef, channel) {\n        if (!isScaleFieldDef(fieldDef)) {\n          return;\n        }\n\n        if (isSortArray(fieldDef.sort)) {\n          var field = fieldDef.field,\n              timeUnit = fieldDef.timeUnit;\n          var sort = fieldDef.sort; // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n\n          var calculate = sort.map(function (sortValue, i) {\n            return \"\".concat(fieldFilterExpression({\n              field: field,\n              timeUnit: timeUnit,\n              equal: sortValue\n            }), \" ? \").concat(i, \" : \");\n          }).join('') + sort.length;\n          parent = new CalculateNode(parent, {\n            calculate: calculate,\n            as: sortArrayIndexField(fieldDef, channel, {\n              forAs: true\n            })\n          });\n        }\n      });\n      return parent;\n    }\n  }]);\n\n  return CalculateNode;\n}(DataFlowNode);\nexport function sortArrayIndexField(fieldDef, channel, opt) {\n  return vgField(fieldDef, Object.assign({\n    prefix: channel,\n    suffix: 'sort_index'\n  }, opt !== null && opt !== void 0 ? opt : {}));\n}","map":null,"metadata":{},"sourceType":"module"}