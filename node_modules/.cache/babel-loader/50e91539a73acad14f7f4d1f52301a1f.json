{"ast":null,"code":"import { isArray, stringValue } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isTimeFormatFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { ScaleType } from '../../scale';\nimport { getFirstDefined, keys, varName } from '../../util';\nimport { applyMarkConfig, timeFormatExpression } from '../common';\nimport * as mixins from '../mark/encode';\nimport { STORE } from '../selection';\nimport { defaultType } from './properties';\n\nfunction type(legendCmp, model, channel) {\n  var scaleType = model.getScaleComponent(channel).get('type');\n  return getFirstDefined(legendCmp.get('type'), defaultType({\n    channel: channel,\n    scaleType: scaleType,\n    alwaysReturn: true\n  }));\n}\n\nexport function symbols(fieldDef, symbolsSpec, model, channel, legendCmp) {\n  var _a, _b, _c, _d, _e;\n\n  if (type(legendCmp, model, channel) !== 'symbol') {\n    return undefined;\n  }\n\n  var out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), mixins.color(model)); // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  var markDef = model.markDef,\n      encoding = model.encoding,\n      config = model.config;\n  var filled = markDef.filled;\n  var opacity = (_a = getMaxValue(encoding.opacity), _a !== null && _a !== void 0 ? _a : markDef.opacity);\n  var condition = selectedCondition(model, legendCmp, fieldDef);\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || filled && channel === COLOR) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (legendCmp.get('symbolFillColor')) {\n          delete out.fill;\n        } else {\n          out.fill = {\n            value: (_b = config.legend.symbolBaseFillColor, _b !== null && _b !== void 0 ? _b : 'black')\n          };\n          out.fillOpacity = {\n            value: opacity !== null && opacity !== void 0 ? opacity : 1\n          };\n        }\n      } else if (isArray(out.fill)) {\n        var fill = (_e = (_d = getFirstConditionValue((_c = encoding.fill, _c !== null && _c !== void 0 ? _c : encoding.color)), _d !== null && _d !== void 0 ? _d : markDef.fill), _e !== null && _e !== void 0 ? _e : filled && markDef.color);\n\n        if (fill) {\n          out.fill = {\n            value: fill\n          };\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || !filled && channel === COLOR) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field']) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        var stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n\n        if (stroke) {\n          out.stroke = {\n            value: stroke\n          };\n        }\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    if (condition) {\n      out.opacity = [{\n        test: condition,\n        value: opacity !== null && opacity !== void 0 ? opacity : 1\n      }, {\n        value: config.legend.unselectedOpacity\n      }];\n    } else if (opacity) {\n      out.opacity = {\n        value: opacity\n      };\n    }\n  }\n\n  out = Object.assign(Object.assign({}, out), symbolsSpec);\n  return keys(out).length > 0 ? out : undefined;\n}\nexport function gradient(fieldDef, gradientSpec, model, channel, legendCmp) {\n  if (type(legendCmp, model, channel) !== 'gradient') {\n    return undefined;\n  }\n\n  var out = {};\n  var opacity = getMaxValue(model.encoding.opacity) || model.markDef.opacity;\n\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = {\n      value: opacity\n    };\n  }\n\n  out = Object.assign(Object.assign({}, out), gradientSpec);\n  return keys(out).length > 0 ? out : undefined;\n}\nexport function labels(fieldDef, labelsSpec, model, channel, legendCmp) {\n  var legend = model.legend(channel);\n  var config = model.config;\n  var condition = selectedCondition(model, legendCmp, fieldDef);\n  var out = {};\n\n  if (isTimeFormatFieldDef(fieldDef)) {\n    var isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n    var expr = timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.timeFormat, isUTCScale);\n    labelsSpec = Object.assign(Object.assign({}, expr ? {\n      text: {\n        signal: expr\n      }\n    } : {}), labelsSpec);\n  }\n\n  if (condition) {\n    labelsSpec.opacity = [{\n      test: condition,\n      value: 1\n    }, {\n      value: config.legend.unselectedOpacity\n    }];\n  }\n\n  out = Object.assign(Object.assign({}, out), labelsSpec);\n  return keys(out).length > 0 ? out : undefined;\n}\nexport function entries(fieldDef, entriesSpec, model, channel, legendCmp) {\n  var _a;\n\n  var selections = legendCmp.get('selections');\n  return ((_a = selections) === null || _a === void 0 ? void 0 : _a.length) ? {\n    fill: {\n      value: 'transparent'\n    }\n  } : undefined;\n}\n\nfunction getMaxValue(channelDef) {\n  return getConditionValue(channelDef, function (v, conditionalDef) {\n    return Math.max(v, conditionalDef.value);\n  });\n}\n\nexport function getFirstConditionValue(channelDef) {\n  return getConditionValue(channelDef, function (v, conditionalDef) {\n    return getFirstDefined(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue(channelDef, reducer) {\n  if (hasConditionalValueDef(channelDef)) {\n    return (isArray(channelDef.condition) ? channelDef.condition : [channelDef.condition]).reduce(reducer, channelDef.value);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value;\n  }\n\n  return undefined;\n}\n\nfunction selectedCondition(model, legendCmp, fieldDef) {\n  var _a;\n\n  var selections = legendCmp.get('selections');\n  if (!((_a = selections) === null || _a === void 0 ? void 0 : _a.length)) return undefined;\n  var field = stringValue(fieldDef.field);\n  return selections.map(function (name) {\n    var store = stringValue(varName(name) + STORE);\n    return \"(!length(data(\".concat(store, \")) || (\").concat(name, \"[\").concat(field, \"] && indexof(\").concat(name, \"[\").concat(field, \"], datum.value) >= 0))\");\n  }).join(' || ');\n}","map":null,"metadata":{},"sourceType":"module"}