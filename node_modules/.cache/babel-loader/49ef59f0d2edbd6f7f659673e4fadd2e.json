{"ast":null,"code":"import parseExpression from './expression';\nimport parseStream from './stream';\nimport { Scope, View } from '../util';\nimport { selector } from 'vega-event-selector';\nimport { array, error, extend, isString, stringValue } from 'vega-util';\nvar preamble = 'var datum=event.item&&event.item.datum;';\nexport default function (spec, scope, target) {\n  var events = spec.events,\n      update = spec.update,\n      encode = spec.encode,\n      sources = [],\n      entry = {\n    target: target\n  };\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  } // interpret as an event selector string\n\n\n  if (isString(events)) {\n    events = selector(events, scope.isSubscope() ? Scope : View);\n  } // separate event streams from signal updates\n\n\n  events = array(events).filter(function (s) {\n    return s.signal || s.scale ? (sources.push(s), 0) : 1;\n  }); // merge internal operator listeners\n\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  } // merge event streams, include as source\n\n\n  if (events.length) {\n    sources.push(events.length > 1 ? {\n      merge: events\n    } : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  } // resolve update value\n\n\n  entry.update = isString(update) ? parseExpression(update, scope, preamble) : update.expr != null ? parseExpression(update.expr, scope, preamble) : update.value != null ? update.value : update.signal != null ? {\n    $expr: '_.value',\n    $params: {\n      value: scope.signalRef(update.signal)\n    }\n  } : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {\n      force: true\n    };\n  }\n\n  sources.forEach(function (source) {\n    scope.addUpdate(extend(streamSource(source, scope), entry));\n  });\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '[' + sources.map(function (s) {\n      return s.scale ? 'scale(\"' + s.scale + '\")' : s.signal;\n    }) + ']'\n  };\n}","map":null,"metadata":{},"sourceType":"module"}