{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { isArray } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLUMN, FACET_CHANNELS, ROW } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { hash as _hash } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { HEADER_CHANNELS, HEADER_TYPES } from '../header/component';\nimport { assembleDomain, getFieldFromDomain } from '../scale/domain';\nimport { sortArrayIndexField } from './calculate';\nimport { DataFlowNode } from './dataflow';\n/**\n * A node that helps us track what fields we are faceting by.\n */\n\nexport var FacetNode =\n/*#__PURE__*/\nfunction (_DataFlowNode) {\n  _inherits(FacetNode, _DataFlowNode);\n\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  function FacetNode(parent, model, name, data) {\n    var _this;\n\n    _classCallCheck(this, FacetNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FacetNode).call(this, parent));\n    _this.model = model;\n    _this.name = name;\n    _this.data = data;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = FACET_CHANNELS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var channel = _step.value;\n        var fieldDef = model.facet[channel];\n\n        if (fieldDef) {\n          var bin = fieldDef.bin,\n              sort = fieldDef.sort;\n          _this[channel] = Object.assign({\n            name: model.getName(\"\".concat(channel, \"_domain\")),\n            fields: [vgField(fieldDef)].concat(_toConsumableArray(isBinning(bin) ? [vgField(fieldDef, {\n              binSuffix: 'end'\n            })] : []))\n          }, isSortField(sort) ? {\n            sortField: sort\n          } : isArray(sort) ? {\n            sortIndexField: sortArrayIndexField(fieldDef, channel)\n          } : {});\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    _this.childModel = model.child;\n    return _this;\n  }\n\n  _createClass(FacetNode, [{\n    key: \"hash\",\n    value: function hash() {\n      var out = \"Facet\";\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = FACET_CHANNELS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var channel = _step2.value;\n\n          if (this[channel]) {\n            out += \" \".concat(channel.charAt(0), \":\").concat(_hash(this[channel]));\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return out;\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var depFields = new Set(this.fields);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = FACET_CHANNELS[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var channel = _step3.value;\n\n          if (this[channel]) {\n            if (this[channel].sortField) {\n              depFields.add(this[channel].sortField.field);\n            }\n\n            if (this[channel].sortIndexField) {\n              depFields.add(this[channel].sortIndexField);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return depFields;\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(); // facet does not produce any new fields\n    }\n    /**\n     * The name to reference this source is its name.\n     */\n\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      return this.name;\n    }\n  }, {\n    key: \"getChildIndependentFieldsWithStep\",\n    value: function getChildIndependentFieldsWithStep() {\n      var childIndependentFieldsWithStep = {};\n\n      for (var _i = 0, _arr = ['x', 'y']; _i < _arr.length; _i++) {\n        var channel = _arr[_i];\n        var childScaleComponent = this.childModel.component.scales[channel];\n\n        if (childScaleComponent && !childScaleComponent.merged) {\n          // independent scale\n          var type = childScaleComponent.get('type');\n          var range = childScaleComponent.get('range');\n\n          if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n            var domain = assembleDomain(this.childModel, channel);\n            var field = getFieldFromDomain(domain);\n\n            if (field) {\n              childIndependentFieldsWithStep[channel] = field;\n            } else {\n              log.warn(\"Unknown field for \".concat(channel, \". Cannot calculate view size.\"));\n            }\n          }\n        }\n      }\n\n      return childIndependentFieldsWithStep;\n    }\n  }, {\n    key: \"assembleRowColumnHeaderData\",\n    value: function assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {\n      var childChannel = {\n        row: 'y',\n        column: 'x'\n      }[channel];\n      var fields = [];\n      var ops = [];\n      var as = [];\n\n      if (childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n        if (crossedDataName) {\n          // If there is a crossed data, calculate max\n          fields.push(\"distinct_\".concat(childIndependentFieldsWithStep[childChannel]));\n          ops.push('max');\n        } else {\n          // If there is no crossed data, just calculate distinct\n          fields.push(childIndependentFieldsWithStep[childChannel]);\n          ops.push('distinct');\n        } // Although it is technically a max, just name it distinct so it's easier to refer to it\n\n\n        as.push(\"distinct_\".concat(childIndependentFieldsWithStep[childChannel]));\n      }\n\n      var _this$channel = this[channel],\n          sortField = _this$channel.sortField,\n          sortIndexField = _this$channel.sortIndexField;\n\n      if (sortField) {\n        var _sortField$op = sortField.op,\n            op = _sortField$op === void 0 ? DEFAULT_SORT_OP : _sortField$op,\n            field = sortField.field;\n        fields.push(field);\n        ops.push(op);\n        as.push(vgField(sortField, {\n          forAs: true\n        }));\n      } else if (sortIndexField) {\n        fields.push(sortIndexField);\n        ops.push('max');\n        as.push(sortIndexField);\n      }\n\n      return {\n        name: this[channel].name,\n        // Use data from the crossed one if it exist\n        source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,\n        transform: [Object.assign({\n          type: 'aggregate',\n          groupby: this[channel].fields\n        }, fields.length ? {\n          fields: fields,\n          ops: ops,\n          as: as\n        } : {})]\n      };\n    }\n  }, {\n    key: \"assembleFacetHeaderData\",\n    value: function assembleFacetHeaderData(childIndependentFieldsWithStep) {\n      var _a, _b;\n\n      var columns = this.model.layout.columns;\n      var layoutHeaders = this.model.component.layoutHeaders;\n      var data = [];\n      var hasSharedAxis = {};\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = HEADER_CHANNELS[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var headerChannel = _step4.value;\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = HEADER_TYPES[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var headerType = _step5.value;\n              var headers = (_a = layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType], _a !== null && _a !== void 0 ? _a : []);\n              var _iteratorNormalCompletion6 = true;\n              var _didIteratorError6 = false;\n              var _iteratorError6 = undefined;\n\n              try {\n                for (var _iterator6 = headers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                  var header = _step6.value;\n\n                  if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                    hasSharedAxis[headerChannel] = true;\n                    break;\n                  }\n                }\n              } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                    _iterator6.return();\n                  }\n                } finally {\n                  if (_didIteratorError6) {\n                    throw _iteratorError6;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n\n          if (hasSharedAxis[headerChannel]) {\n            var cardinality = \"length(data(\\\"\".concat(this.facet.name, \"\\\"))\");\n            var stop = headerChannel === 'row' ? columns ? {\n              signal: \"ceil(\".concat(cardinality, \" / \").concat(columns, \")\")\n            } : 1 : columns ? {\n              signal: \"min(\".concat(cardinality, \", \").concat(columns, \")\")\n            } : {\n              signal: cardinality\n            };\n            data.push({\n              name: \"\".concat(this.facet.name, \"_\").concat(headerChannel),\n              transform: [{\n                type: 'sequence',\n                start: 0,\n                stop: stop\n              }]\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var row = hasSharedAxis.row,\n          column = hasSharedAxis.column;\n\n      if (row || column) {\n        data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n      }\n\n      return data;\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _a, _b;\n\n      var data = [];\n      var crossedDataName = null;\n      var childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n      var column = this.column,\n          row = this.row,\n          facet = this.facet;\n\n      if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n        // Need to create a cross dataset to correctly calculate cardinality\n        crossedDataName = \"cross_\".concat(this.column.name, \"_\").concat(this.row.name);\n        var fields = [].concat((_a = childIndependentFieldsWithStep.x, _a !== null && _a !== void 0 ? _a : []), (_b = childIndependentFieldsWithStep.y, _b !== null && _b !== void 0 ? _b : []));\n        var ops = fields.map(function () {\n          return 'distinct';\n        });\n        data.push({\n          name: crossedDataName,\n          source: this.data,\n          transform: [{\n            type: 'aggregate',\n            groupby: this.fields,\n            fields: fields,\n            ops: ops\n          }]\n        });\n      }\n\n      for (var _i2 = 0, _arr2 = [COLUMN, ROW]; _i2 < _arr2.length; _i2++) {\n        var channel = _arr2[_i2];\n\n        if (this[channel]) {\n          data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n        }\n      }\n\n      if (facet) {\n        var facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n\n        if (facetData) {\n          data.push.apply(data, _toConsumableArray(facetData));\n        }\n      }\n\n      return data;\n    }\n  }, {\n    key: \"fields\",\n    get: function get() {\n      var _a;\n\n      var f = [];\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = FACET_CHANNELS[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var channel = _step7.value;\n\n          if ((_a = this[channel]) === null || _a === void 0 ? void 0 : _a.fields) {\n            f.push.apply(f, _toConsumableArray(this[channel].fields));\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return f;\n    }\n  }]);\n\n  return FacetNode;\n}(DataFlowNode);","map":null,"metadata":{},"sourceType":"module"}