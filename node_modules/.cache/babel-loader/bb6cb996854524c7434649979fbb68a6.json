{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar _classCallCheck = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _createClass = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar preact_1 = require(\"preact\");\n\nvar glamor_1 = require(\"glamor\");\n\nvar surface_1 = require(\"./surface\");\n\nvar tabs_1 = require(\"./tabs\");\n/**\n * The Visor is a component that displays and manages 'Tabs' and 'Surfaces'.\n *\n * It is meant to exist as a singleton component on a given page and is thus\n * accessed by a visor() function that exposes a single instance of this\n * component via an imperative API (i.e. its implementation as a (p)react\n * component is an internal implementation detail.\n *\n * Following that, and somewhat unlike a typical react component, it does allow\n * for imperative calls to that instance to modify internal state. Any state\n * that needs to be serialized or persisted should be lifted to props.\n */\n\n\nvar VisorComponent =\n/*#__PURE__*/\nfunction (_preact_1$Component) {\n  _inherits(VisorComponent, _preact_1$Component);\n\n  _createClass(VisorComponent, null, [{\n    key: \"render\",\n\n    /**\n     * Helper function to render the component to the DOM.\n     *\n     * Note that although the visor has a parent element, it rendered via absolute\n     * positioning and is thus taken out of regular document flow.\n     *\n     * @param parent A DOM element\n     * @param replaceNode The element that re-rendering this component would\n     *                    replace. Usually null initially and will be returned by\n     *                    this function after the first render.\n     * @param props Initial visor props\n     */\n    value: function render(parent, replaceNode, props) {\n      return preact_1.render(preact_1.h(VisorComponent, Object.assign({}, props)), parent, replaceNode);\n    }\n  }]);\n\n  function VisorComponent(props) {\n    var _this;\n\n    _classCallCheck(this, VisorComponent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(VisorComponent).call(this, props));\n    _this.surfaces = new Map();\n    var startOpen = props.startOpen == null ? true : props.startOpen;\n    _this.state = {\n      isOpen: startOpen,\n      isFullscreen: false,\n      activeTab: null,\n      tabs: new Set()\n    };\n    _this.keyHandler = _this.keyHandler.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  } // These public methods are exposed via an imperative interface\n\n\n  _createClass(VisorComponent, [{\n    key: \"close\",\n    value: function close() {\n      this.setState({\n        isOpen: false\n      });\n    }\n  }, {\n    key: \"open\",\n    value: function open() {\n      this.setState({\n        isOpen: true\n      });\n    }\n  }, {\n    key: \"toggle\",\n    value: function toggle() {\n      this.setState({\n        isOpen: !this.state.isOpen\n      });\n    }\n  }, {\n    key: \"toggleFullScreen\",\n    value: function toggleFullScreen() {\n      this.setState({\n        isFullscreen: !this.state.isFullscreen\n      });\n    }\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return this.state.isOpen;\n    }\n  }, {\n    key: \"isFullscreen\",\n    value: function isFullscreen() {\n      return this.state.isFullscreen;\n    }\n  }, {\n    key: \"getSurface\",\n    value: function getSurface(label, tab) {\n      var surfaceId = this.surfaceId(label, tab);\n      var surface;\n\n      if (this.surfaces.has(surfaceId)) {\n        surface = this.surfaces.get(surfaceId);\n      } else {\n        throw Error(\"Surface not found with id: \".concat(surfaceId));\n      }\n\n      return {\n        container: surface.container,\n        label: surface.label,\n        drawArea: surface.drawArea\n      };\n    }\n  }, {\n    key: \"bindKeys\",\n    value: function bindKeys() {\n      document.addEventListener('keydown', this.keyHandler, false);\n    }\n  }, {\n    key: \"unbindKeys\",\n    value: function unbindKeys() {\n      document.removeEventListener('keydown', this.keyHandler);\n    }\n  }, {\n    key: \"surfaceId\",\n    value: function surfaceId(label, tab) {\n      return label + tab;\n    }\n  }, {\n    key: \"setTabs\",\n    value: function setTabs(surfaceList) {\n      // Check if we have new tabs\n      var nextTabs = surfaceList.map(function (s) {\n        return s.tab;\n      });\n      var tabs = this.state.tabs;\n      var newActiveTab;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = nextTabs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var tab = _step.value;\n\n          if (!tabs.has(tab)) {\n            tabs.add(tab);\n            newActiveTab = tab;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (newActiveTab != null) {\n        this.setState({\n          tabs: tabs,\n          activeTab: newActiveTab\n        });\n      }\n    }\n  }, {\n    key: \"getTabs\",\n    value: function getTabs() {\n      return this.state.tabs;\n    } // Event Handlers\n\n  }, {\n    key: \"registerSurface\",\n    value: function registerSurface(name, tab, surface) {\n      var surfaceId = this.surfaceId(name, tab);\n      this.surfaces.set(surfaceId, surface);\n    }\n  }, {\n    key: \"keyHandler\",\n    value: function keyHandler(event) {\n      var BACKTICK_KEY = 192;\n\n      if (event.keyCode === BACKTICK_KEY) {\n        if (event.shiftKey) {\n          this.toggleFullScreen();\n        } else {\n          this.toggle();\n        }\n      }\n    }\n  }, {\n    key: \"setActiveTab\",\n    value: function setActiveTab(tab) {\n      this.setState({\n        activeTab: tab\n      });\n    } // Lifecycle Methods\n\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.bindKeys();\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      this.setTabs(this.props.surfaceList);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      this.setTabs(nextProps.surfaceList);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$state = this.state,\n          isOpen = _this$state.isOpen,\n          isFullscreen = _this$state.isFullscreen,\n          activeTab = _this$state.activeTab;\n      var surfaceList = this.props.surfaceList;\n      var tabNames = Array.from(this.getTabs().values());\n      var SMALL_WIDTH = '550px';\n      var LARGE_WIDTH = '90vw';\n      var width = isFullscreen ? LARGE_WIDTH : SMALL_WIDTH;\n      var defaultStyles = glamor_1.css({\n        width: width,\n        height: '100%',\n        backgroundColor: '#fafafa',\n        boxSizing: 'border-box',\n        padding: '10px',\n        position: 'fixed',\n        top: '0px',\n        // tslint:disable-next-line\n        transition: \"right 0.5s cubic-bezier(0.645, 0.045, 0.355, 1), width 0.5s cubic-bezier(0.645, 0.045, 0.355, 1)\",\n        boxShadow: '0 2px 5px rgba(0, 0, 0, 0.12), 0 2px 5px rgba(0, 0, 0, 0.24)',\n        overflow: 'auto',\n        fontFamily: 'sans-serif',\n        fontSize: '14px',\n        zIndex: 1000\n      });\n      var openStyle = glamor_1.css({\n        right: '0'\n      });\n      var closedStyle = glamor_1.css({\n        right: \"calc(-\".concat(width, \" - 10px)\")\n      });\n      var position = isOpen ? openStyle : closedStyle; // TODO. Add flex wrapping for surfaces\n\n      var surfacesContainerStyle = glamor_1.css({});\n      return preact_1.h(\"div\", {\n        className: \"\".concat(defaultStyles, \" \").concat(position, \" visor\"),\n        \"data-isopen\": isOpen,\n        \"data-isfullscreen\": isFullscreen\n      }, preact_1.h(VisorControls, {\n        fullScreenHandler: this.toggleFullScreen.bind(this),\n        closeHandler: this.close.bind(this),\n        isFullScreen: isFullscreen\n      }), preact_1.h(tabs_1.Tabs, {\n        tabNames: tabNames,\n        activeTab: activeTab,\n        handleClick: this.setActiveTab.bind(this)\n      }), preact_1.h(\"div\", {\n        className: \"\".concat(surfacesContainerStyle, \" visor-surfaces\")\n      }, surfaceList.map(function (surfaceInfo) {\n        return preact_1.h(surface_1.SurfaceComponent, {\n          key: surfaceInfo.name + surfaceInfo.tab,\n          name: surfaceInfo.name,\n          tab: surfaceInfo.tab,\n          styles: surfaceInfo.styles,\n          registerSurface: _this2.registerSurface.bind(_this2),\n          visible: activeTab === surfaceInfo.tab\n        });\n      })));\n    }\n  }]);\n\n  return VisorComponent;\n}(preact_1.Component);\n\nexports.VisorComponent = VisorComponent;\n\nfunction VisorControls(props) {\n  var isFullScreen = props.isFullScreen,\n      fullScreenHandler = props.fullScreenHandler,\n      closeHandler = props.closeHandler;\n  var toolBarStyle = glamor_1.css({\n    display: 'flex',\n    backgroundColor: 'white',\n    border: '1px solid white',\n    padding: '6px',\n    paddingTop: '10px',\n    marginBottom: '10px',\n    borderRadius: '6px',\n    marginTop: '-16px'\n  });\n  var controlsButtonClass = glamor_1.css({\n    fontSize: '.875rem',\n    borderRadius: '.25rem',\n    paddingLeft: '1rem',\n    paddingRight: '1rem',\n    paddingTop: '.5rem',\n    paddingBottom: '.5rem',\n    textDecoration: 'none',\n    transition: 'color .15s ease-in',\n    color: '#111'\n  });\n  var floatRight = glamor_1.css({\n    marginLeft: 'auto'\n  });\n  return preact_1.h(\"div\", {\n    className: \"\".concat(toolBarStyle, \" visor-controls\")\n  }, preact_1.h(\"button\", {\n    className: \"\".concat(controlsButtonClass),\n    onClick: fullScreenHandler\n  }, isFullScreen ? 'Minimize' : 'Maximize'), preact_1.h(\"button\", {\n    className: \"\".concat(controlsButtonClass, \" \").concat(floatRight),\n    onClick: closeHandler\n  }, \"Hide\"));\n}","map":null,"metadata":{},"sourceType":"script"}