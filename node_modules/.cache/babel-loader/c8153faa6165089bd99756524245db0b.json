{"ast":null,"code":"import { isColorChannel } from '../../channel';\nimport { valueArray } from '../../channeldef';\nimport { isContinuousToContinuous } from '../../scale';\nimport { contains, getFirstDefined } from '../../util';\nimport { getFirstConditionValue } from './encode';\nexport function values(legend, fieldDef) {\n  var vals = legend.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n\n  return undefined;\n}\nexport function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {\n  var _a;\n\n  if (channel !== 'shape') {\n    // use the value from the shape encoding or the mark config if they exist\n    var shape = (_a = getFirstConditionValue(shapeChannelDef), _a !== null && _a !== void 0 ? _a : markShape);\n\n    if (shape) {\n      return shape;\n    }\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'rect':\n    case 'image':\n    case 'square':\n      return 'square';\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return 'stroke';\n\n    case 'point':\n    case 'circle':\n    case 'tick':\n    case 'geoshape':\n    case 'area':\n    case 'text':\n      return 'circle';\n  }\n}\nexport function clipHeight(legendType) {\n  if (legendType === 'gradient') {\n    return 20;\n  }\n\n  return undefined;\n}\nexport function type(params) {\n  var legend = params.legend;\n  return getFirstDefined(legend.type, defaultType(params));\n}\nexport function defaultType(_ref) {\n  var channel = _ref.channel,\n      timeUnit = _ref.timeUnit,\n      scaleType = _ref.scaleType,\n      alwaysReturn = _ref.alwaysReturn;\n\n  // Following the logic in https://github.com/vega/vega-parser/blob/master/src/parsers/legend.js\n  if (isColorChannel(channel)) {\n    if (contains(['quarter', 'month', 'day'], timeUnit)) {\n      return 'symbol';\n    }\n\n    if (isContinuousToContinuous(scaleType)) {\n      return alwaysReturn ? 'gradient' : undefined;\n    }\n  }\n\n  return alwaysReturn ? 'symbol' : undefined;\n}\nexport function direction(_ref2) {\n  var legend = _ref2.legend,\n      legendConfig = _ref2.legendConfig,\n      timeUnit = _ref2.timeUnit,\n      channel = _ref2.channel,\n      scaleType = _ref2.scaleType;\n  var orient = getFirstDefined(legend.orient, legendConfig.orient, 'right');\n  var legendType = type({\n    legend: legend,\n    channel: channel,\n    timeUnit: timeUnit,\n    scaleType: scaleType,\n    alwaysReturn: true\n  });\n  return getFirstDefined(legend.direction, legendConfig[legendType ? 'gradientDirection' : 'symbolDirection'], defaultDirection(orient, legendType));\n}\n\nfunction defaultDirection(orient, legendType) {\n  switch (orient) {\n    case 'top':\n    case 'bottom':\n      return 'horizontal';\n\n    case 'left':\n    case 'right':\n    case 'none':\n    case undefined:\n      // undefined = \"right\" in Vega\n      return undefined;\n    // vertical is Vega's default\n\n    default:\n      // top-left / ...\n      // For inner legend, uses compact layout like Tableau\n      return legendType === 'gradient' ? 'horizontal' : undefined;\n  }\n}\n\nexport function defaultGradientLength(_ref3) {\n  var legend = _ref3.legend,\n      legendConfig = _ref3.legendConfig,\n      model = _ref3.model,\n      channel = _ref3.channel,\n      scaleType = _ref3.scaleType;\n  var gradientHorizontalMaxLength = legendConfig.gradientHorizontalMaxLength,\n      gradientHorizontalMinLength = legendConfig.gradientHorizontalMinLength,\n      gradientVerticalMaxLength = legendConfig.gradientVerticalMaxLength,\n      gradientVerticalMinLength = legendConfig.gradientVerticalMinLength;\n  var dir = direction({\n    legend: legend,\n    legendConfig: legendConfig,\n    channel: channel,\n    scaleType: scaleType\n  });\n\n  if (dir === 'horizontal') {\n    var orient = getFirstDefined(legend.orient, legendConfig.orient);\n\n    if (orient === 'top' || orient === 'bottom') {\n      return gradientLengthSignal(model, 'width', gradientHorizontalMinLength, gradientHorizontalMaxLength);\n    } else {\n      return gradientHorizontalMinLength;\n    }\n  } else {\n    // vertical / undefined (Vega uses vertical by default)\n    return gradientLengthSignal(model, 'height', gradientVerticalMinLength, gradientVerticalMaxLength);\n  }\n}\n\nfunction gradientLengthSignal(model, sizeType, min, max) {\n  var sizeSignal = model.getSizeSignalRef(sizeType).signal;\n  return {\n    signal: \"clamp(\".concat(sizeSignal, \", \").concat(min, \", \").concat(max, \")\")\n  };\n}\n\nexport function defaultLabelOverlap(scaleType) {\n  if (contains(['quantile', 'threshold', 'log'], scaleType)) {\n    return 'greedy';\n  }\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"module"}