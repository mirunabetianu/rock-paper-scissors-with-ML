{"ast":null,"code":"import { max } from 'd3-array';\nimport { rgb } from 'd3-color';\nimport { canvas } from 'vega-canvas';\nimport { Transform } from 'vega-dataflow';\nimport { accessorFields, constant, extend, identity, inherits, isFunction, toSet, zero } from 'vega-util';\n/**\n * Render a heatmap image for input raster grid data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} [params.field] - The field with raster grid\n *   data. If unspecified, the tuple itself is interpreted as a raster grid.\n * @param {string} [params.color] - A constant color value or function for\n *   individual pixel color. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {number} [params.opacity] - A constant opacity value or function for\n *   individual pixel opacity. If a function, it will be invoked with an input\n *   object that includes $x, $y, $value, and $max fields for the grid.\n * @param {string} [params.resolve] - The method for resolving maximum values\n *   across multiple input grids. If 'independent' (the default), maximum\n *   calculation will be performed separately for each grid. If 'shared',\n *   a single global maximum will be used for all input grids.\n * @param {string} [params.as='image'] - The output field in which to store\n *   the generated bitmap canvas images (default 'image').\n */\n\nexport default function Heatmap(params) {\n  Transform.call(this, null, params);\n}\nHeatmap.Definition = {\n  \"type\": \"heatmap\",\n  \"metadata\": {\n    \"modifies\": true\n  },\n  \"params\": [{\n    \"name\": \"field\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"color\",\n    \"type\": \"string\",\n    \"expr\": true\n  }, {\n    \"name\": \"opacity\",\n    \"type\": \"number\",\n    \"expr\": true\n  }, {\n    \"name\": \"resolve\",\n    \"type\": \"enum\",\n    \"values\": [\"shared\", \"independent\"],\n    \"default\": \"independent\"\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"default\": \"image\"\n  }]\n};\nvar prototype = inherits(Heatmap, Transform);\n\nprototype.transform = function (_, pulse) {\n  if (!pulse.changed() && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var source = pulse.materialize(pulse.SOURCE).source,\n      shared = _.resolve === 'shared',\n      field = _.field || identity,\n      opacity = opacity_(_.opacity, _),\n      color = color_(_.color, _),\n      as = _.as || 'image',\n      obj = {\n    $x: 0,\n    $y: 0,\n    $value: 0,\n    $max: shared ? max(source.map(function (t) {\n      return max(field(t).values);\n    })) : 0\n  };\n  source.forEach(function (t) {\n    var v = field(t); // build proxy data object\n\n    var o = extend({}, t, obj); // set maximum value if not globally shared\n\n    if (!shared) o.$max = max(v.values || []); // generate canvas image\n    // optimize color/opacity if not pixel-dependent\n\n    t[as] = toCanvas(v, o, color.dep ? color : constant(color(o)), opacity.dep ? opacity : constant(opacity(o)));\n  });\n  return pulse.reflow(true).modifies(as);\n}; // get image color function\n\n\nfunction color_(color, _) {\n  var f;\n\n  if (isFunction(color)) {\n    f = function f(obj) {\n      return rgb(color(obj, _));\n    };\n\n    f.dep = dependency(color);\n  } else {\n    // default to mid-grey\n    f = constant(rgb(color || '#888'));\n  }\n\n  return f;\n} // get image opacity function\n\n\nfunction opacity_(opacity, _) {\n  var f;\n\n  if (isFunction(opacity)) {\n    f = function f(obj) {\n      return opacity(obj, _);\n    };\n\n    f.dep = dependency(opacity);\n  } else if (opacity) {\n    f = constant(opacity);\n  } else {\n    // default to [0, max] opacity gradient\n    f = function f(obj) {\n      return obj.$value / obj.$max || 0;\n    };\n\n    f.dep = true;\n  }\n\n  return f;\n} // check if function depends on individual pixel data\n\n\nfunction dependency(f) {\n  if (!isFunction(f)) return false;\n  var set = toSet(accessorFields(f));\n  return set.$x || set.$y || set.$value || set.$max;\n} // render raster grid to canvas\n\n\nfunction toCanvas(grid, obj, color, opacity) {\n  var n = grid.width,\n      m = grid.height,\n      x1 = grid.x1 || 0,\n      y1 = grid.y1 || 0,\n      x2 = grid.x2 || n,\n      y2 = grid.y2 || m,\n      val = grid.values,\n      value = val ? function (i) {\n    return val[i];\n  } : zero,\n      can = canvas(x2 - x1, y2 - y1),\n      ctx = can.getContext('2d'),\n      img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),\n      pix = img.data;\n\n  for (var j = y1, k = 0; j < y2; ++j) {\n    obj.$y = j - y1;\n\n    for (var i = x1, r = j * n; i < x2; ++i, k += 4) {\n      obj.$x = i - x1;\n      obj.$value = value(i + r);\n      var v = color(obj);\n      pix[k + 0] = v.r;\n      pix[k + 1] = v.g;\n      pix[k + 2] = v.b;\n      pix[k + 3] = ~~(255 * opacity(obj));\n    }\n  }\n\n  ctx.putImageData(img, 0, 0);\n  return can;\n}","map":null,"metadata":{},"sourceType":"module"}