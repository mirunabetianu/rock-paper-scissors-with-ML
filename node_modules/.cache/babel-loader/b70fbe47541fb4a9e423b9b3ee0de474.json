{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { hasOwnProperty } from 'vega-util';\nimport { LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE } from '../../channel';\nimport { MAIN } from '../../data';\nimport { PROJECTION_PROPERTIES } from '../../projection';\nimport { GEOJSON } from '../../type';\nimport { duplicate, every, stringify } from '../../util';\nimport { isUnitModel } from '../model';\nimport { ProjectionComponent } from './component';\nexport function parseProjection(model) {\n  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);\n}\n\nfunction parseUnitProjection(model) {\n  var _a;\n\n  if (model.hasProjection) {\n    var proj = model.specifiedProjection;\n    var fit = !(proj && (proj.scale != null || proj.translate != null));\n    var size = fit ? [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')] : undefined;\n    var data = fit ? gatherFitData(model) : undefined;\n    return new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, (_a = model.config.projection, _a !== null && _a !== void 0 ? _a : {})), proj !== null && proj !== void 0 ? proj : {}), size, data);\n  }\n\n  return undefined;\n}\n\nfunction gatherFitData(model) {\n  var data = [];\n\n  for (var _i = 0, _arr = [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]]; _i < _arr.length; _i++) {\n    var posssiblePair = _arr[_i];\n\n    if (model.channelHasField(posssiblePair[0]) || model.channelHasField(posssiblePair[1])) {\n      data.push({\n        signal: model.getName(\"geojson_\".concat(data.length))\n      });\n    }\n  }\n\n  if (model.channelHasField(SHAPE) && model.fieldDef(SHAPE).type === GEOJSON) {\n    data.push({\n      signal: model.getName(\"geojson_\".concat(data.length))\n    });\n  }\n\n  if (data.length === 0) {\n    // main source is geojson, so we can just use that\n    data.push(model.requestDataName(MAIN));\n  }\n\n  return data;\n}\n\nfunction mergeIfNoConflict(first, second) {\n  var allPropertiesShared = every(PROJECTION_PROPERTIES, function (prop) {\n    // neither has the property\n    if (!hasOwnProperty(first.explicit, prop) && !hasOwnProperty(second.explicit, prop)) {\n      return true;\n    } // both have property and an equal value for property\n\n\n    if (hasOwnProperty(first.explicit, prop) && hasOwnProperty(second.explicit, prop) && // some properties might be signals or objects and require hashing for comparison\n    stringify(first.get(prop)) === stringify(second.get(prop))) {\n      return true;\n    }\n\n    return false;\n  });\n  var size = stringify(first.size) === stringify(second.size);\n\n  if (size) {\n    if (allPropertiesShared) {\n      return first;\n    } else if (stringify(first.explicit) === stringify({})) {\n      return second;\n    } else if (stringify(second.explicit) === stringify({})) {\n      return first;\n    }\n  } // if all properties don't match, let each unit spec have its own projection\n\n\n  return null;\n}\n\nfunction parseNonUnitProjections(model) {\n  if (model.children.length === 0) {\n    return undefined;\n  }\n\n  var nonUnitProjection; // parse all children first\n\n  model.children.forEach(function (child) {\n    return parseProjection(child);\n  }); // analyze parsed projections, attempt to merge\n\n  var mergable = every(model.children, function (child) {\n    var projection = child.component.projection;\n\n    if (!projection) {\n      // child layer does not use a projection\n      return true;\n    } else if (!nonUnitProjection) {\n      // cached 'projection' is null, cache this one\n      nonUnitProjection = projection;\n      return true;\n    } else {\n      var merge = mergeIfNoConflict(nonUnitProjection, projection);\n\n      if (merge) {\n        nonUnitProjection = merge;\n      }\n\n      return !!merge;\n    }\n  }); // if cached one and all other children share the same projection,\n\n  if (nonUnitProjection && mergable) {\n    // so we can elevate it to the layer level\n    var name = model.projectionName(true);\n    var modelProjection = new ProjectionComponent(name, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data)); // rename and assign all others as merged\n\n    model.children.forEach(function (child) {\n      var projection = child.component.projection;\n\n      if (projection) {\n        if (projection.isFit) {\n          var _modelProjection$data;\n\n          (_modelProjection$data = modelProjection.data).push.apply(_modelProjection$data, _toConsumableArray(child.component.projection.data));\n        }\n\n        child.renameProjection(projection.get('name'), name);\n        projection.merged = true;\n      }\n    });\n    return modelProjection;\n  }\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"module"}