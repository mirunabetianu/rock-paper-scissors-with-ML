{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar _regeneratorRuntime = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nvar dom_1 = require(\"../util/dom\");\n\nvar utils_1 = require(\"../util/utils\");\n\nvar render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a line chart\n *\n * ```js\n * const series1 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 - (Math.random() * 50))\n *   .map((y, x) => ({ x, y, }));\n *\n * const series2 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 - (Math.random() * 150))\n *   .map((y, x) => ({ x, y, }));\n *\n * const series = ['First', 'Second'];\n * const data = { values: [series1, series2], series }\n *\n * const surface = { name: 'Line chart', tab: 'Charts' };\n * tfvis.render.linechart(surface, data);\n * ```\n *\n * ```js\n * const series1 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 + 50)\n *   .map((y, x) => ({ x, y, }));\n *\n * const data = { values: [series1] }\n *\n * // Render to visor\n * const surface = { name: 'Zoomed Line Chart', tab: 'Charts' };\n * tfvis.render.linechart(surface, data, { zoomToFit: true });\n * ```\n *\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\n\nfunction linechart(container, data) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var _data, numValues, _series, vlChartValues, _loop, valueIdx, options, yScale, sharedEncoding, lineLayers, tooltipLayer, drawArea, spec, embedOpts;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // Nest data if necessary before further processing\n            _data = Array.isArray(data.values[0]) ? data.values : [data.values];\n            numValues = _data[0].length; // Create series names if none were passed in.\n\n            _series = data.series ? data.series : _data.map(function (_, i) {\n              return \"Series \".concat(i + 1);\n            });\n            utils_1.assert(_series.length === _data.length, 'Must have an equal number of series labels as there are data series');\n\n            if (opts.seriesColors != null) {\n              utils_1.assert(opts.seriesColors.length === _data.length, 'Must have an equal number of series colors as there are data series');\n            }\n\n            vlChartValues = [];\n\n            _loop = function _loop(valueIdx) {\n              var v = {\n                x: valueIdx\n              };\n\n              _series.forEach(function (seriesName, seriesIdx) {\n                var seriesValue = _data[seriesIdx][valueIdx].y;\n                v[seriesName] = seriesValue;\n                v[\"\".concat(seriesName, \"-name\")] = seriesName;\n              });\n\n              vlChartValues.push(v);\n            };\n\n            for (valueIdx = 0; valueIdx < numValues; valueIdx++) {\n              _loop(valueIdx);\n            }\n\n            options = Object.assign({}, defaultOpts, opts);\n\n            yScale = function yScale() {\n              if (options.zoomToFit) {\n                return {\n                  'zero': false\n                };\n              } else if (options.yAxisDomain != null) {\n                return {\n                  'domain': options.yAxisDomain\n                };\n              }\n\n              return undefined;\n            };\n\n            sharedEncoding = {\n              x: {\n                field: 'x',\n                type: options.xType,\n                title: options.xLabel\n              },\n              tooltip: [{\n                field: 'x',\n                type: 'quantitative'\n              }].concat(_toConsumableArray(_series.map(function (seriesName) {\n                return {\n                  field: seriesName,\n                  type: 'quantitative'\n                };\n              })))\n            };\n            lineLayers = _series.map(function (seriesName) {\n              return {\n                // data will be defined at the chart level.\n                'data': undefined,\n                'mark': {\n                  'type': 'line',\n                  'clip': true\n                },\n                'encoding': {\n                  // Note: the encoding for 'x' is shared\n                  // Add a y encoding for this series\n                  'y': {\n                    'field': seriesName,\n                    'type': options.yType,\n                    'title': options.yLabel,\n                    'scale': yScale()\n                  },\n                  'color': {\n                    'field': \"\".concat(seriesName, \"-name\"),\n                    'type': 'nominal',\n                    'legend': {\n                      'values': _series,\n                      title: null\n                    },\n                    'scale': {\n                      'range': options.seriesColors\n                    }\n                  }\n                }\n              };\n            });\n            tooltipLayer = {\n              'mark': 'rule',\n              'selection': {\n                'hover': {\n                  'type': 'single',\n                  'on': 'mouseover',\n                  'nearest': true,\n                  clear: 'mouseout'\n                }\n              },\n              'encoding': {\n                'color': {\n                  'value': 'grey',\n                  'condition': {\n                    'selection': {\n                      'not': 'hover'\n                    },\n                    'value': 'transparent'\n                  }\n                }\n              }\n            };\n            drawArea = render_utils_1.getDrawArea(container);\n            spec = {\n              'width': options.width || dom_1.getDefaultWidth(drawArea),\n              'height': options.height || dom_1.getDefaultHeight(drawArea),\n              'padding': 0,\n              'autosize': {\n                'type': 'fit',\n                'contains': 'padding',\n                'resize': true\n              },\n              'config': {\n                'axis': {\n                  'labelFontSize': options.fontSize,\n                  'titleFontSize': options.fontSize\n                },\n                'text': {\n                  'fontSize': options.fontSize\n                },\n                'legend': {\n                  'labelFontSize': options.fontSize,\n                  'titleFontSize': options.fontSize\n                }\n              },\n              'data': {\n                'values': vlChartValues\n              },\n              'encoding': sharedEncoding,\n              'layer': [].concat(_toConsumableArray(lineLayers), [tooltipLayer])\n            };\n            embedOpts = {\n              actions: false,\n              mode: 'vega-lite',\n              defaultStyle: false\n            };\n            _context.next = 18;\n            return vega_embed_1.default(drawArea, spec, embedOpts);\n\n          case 18:\n            return _context.abrupt(\"return\", Promise.resolve());\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.linechart = linechart;\nvar defaultOpts = {\n  xLabel: 'x',\n  yLabel: 'y',\n  xType: 'quantitative',\n  yType: 'quantitative',\n  zoomToFit: false,\n  fontSize: 11\n};","map":null,"metadata":{},"sourceType":"script"}