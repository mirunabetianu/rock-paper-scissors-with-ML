{"ast":null,"code":"import Renderer from './Renderer';\nimport { gradientRef, isGradient, patternPrefix } from './Gradient';\nimport marks from './marks/index';\nimport { domChild, domClear, domCreate, cssClass } from './util/dom';\nimport { openTag, closeTag } from './util/tags';\nimport { fontFamily, fontSize, lineHeight, textLines, textValue } from './util/text';\nimport { visit } from './util/visit';\nimport clip from './util/svg/clip';\nimport metadata from './util/svg/metadata';\nimport { styles, styleProperties } from './util/svg/styles';\nimport { inherits, isArray } from 'vega-util';\nvar ns = metadata.xmlns;\nexport default function SVGRenderer(loader) {\n  Renderer.call(this, loader);\n  this._dirtyID = 0;\n  this._dirty = [];\n  this._svg = null;\n  this._root = null;\n  this._defs = null;\n}\nvar prototype = inherits(SVGRenderer, Renderer);\nvar base = Renderer.prototype;\n\nprototype.initialize = function (el, width, height, padding) {\n  if (el) {\n    this._svg = domChild(el, 0, 'svg', ns);\n\n    this._svg.setAttribute('class', 'marks');\n\n    domClear(el, 1); // set the svg root group\n\n    this._root = domChild(this._svg, 0, 'g', ns);\n    domClear(this._svg, 1);\n  } // create the svg definitions cache\n\n\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  }; // set background color if defined\n\n  this.background(this._bgcolor);\n  return base.initialize.call(this, el, width, height, padding);\n};\n\nprototype.background = function (bgcolor) {\n  if (arguments.length && this._svg) {\n    this._svg.style.setProperty('background-color', bgcolor);\n  }\n\n  return base.background.apply(this, arguments);\n};\n\nprototype.resize = function (width, height, origin, scaleFactor) {\n  base.resize.call(this, width, height, origin, scaleFactor);\n\n  if (this._svg) {\n    this._svg.setAttribute('width', this._width * this._scale);\n\n    this._svg.setAttribute('height', this._height * this._scale);\n\n    this._svg.setAttribute('viewBox', '0 0 ' + this._width + ' ' + this._height);\n\n    this._root.setAttribute('transform', 'translate(' + this._origin + ')');\n  }\n\n  this._dirty = [];\n  return this;\n};\n\nprototype.canvas = function () {\n  return this._svg;\n};\n\nprototype.svg = function () {\n  if (!this._svg) return null;\n  var attr = {\n    class: 'marks',\n    width: this._width * this._scale,\n    height: this._height * this._scale,\n    viewBox: '0 0 ' + this._width + ' ' + this._height\n  };\n\n  for (var key in metadata) {\n    attr[key] = metadata[key];\n  }\n\n  var bg = !this._bgcolor ? '' : openTag('rect', {\n    width: this._width,\n    height: this._height,\n    style: 'fill: ' + this._bgcolor + ';'\n  }) + closeTag('rect');\n  return openTag('svg', attr) + bg + this._svg.innerHTML + closeTag('svg');\n}; // -- Render entry point --\n\n\nprototype._render = function (scene) {\n  // perform spot updates and re-render markup\n  if (this._dirtyCheck()) {\n    if (this._dirtyAll) this._resetDefs();\n    this.draw(this._root, scene);\n    domClear(this._root, 1);\n  }\n\n  this.updateDefs();\n  this._dirty = [];\n  ++this._dirtyID;\n  return this;\n}; // -- Manage SVG definitions ('defs') block --\n\n\nprototype.updateDefs = function () {\n  var svg = this._svg,\n      defs = this._defs,\n      el = defs.el,\n      index = 0,\n      id;\n\n  for (id in defs.gradient) {\n    if (!el) defs.el = el = domChild(svg, 0, 'defs', ns);\n    index = updateGradient(el, defs.gradient[id], index);\n  }\n\n  for (id in defs.clipping) {\n    if (!el) defs.el = el = domChild(svg, 0, 'defs', ns);\n    index = updateClipping(el, defs.clipping[id], index);\n  } // clean-up\n\n\n  if (el) {\n    if (index === 0) {\n      svg.removeChild(el);\n      defs.el = null;\n    } else {\n      domClear(el, index);\n    }\n  }\n};\n\nfunction updateGradient(el, grad, index) {\n  var i, n, stop;\n\n  if (grad.gradient === 'radial') {\n    // SVG radial gradients automatically transform to normalized bbox\n    // coordinates, in a way that is cumbersome to replicate in canvas.\n    // So we wrap the radial gradient in a pattern element, allowing us\n    // to mantain a circular gradient that matches what canvas provides.\n    var pt = domChild(el, index++, 'pattern', ns);\n    pt.setAttribute('id', patternPrefix + grad.id);\n    pt.setAttribute('viewBox', '0,0,1,1');\n    pt.setAttribute('width', '100%');\n    pt.setAttribute('height', '100%');\n    pt.setAttribute('preserveAspectRatio', 'xMidYMid slice');\n    pt = domChild(pt, 0, 'rect', ns);\n    pt.setAttribute('width', '1');\n    pt.setAttribute('height', '1');\n    pt.setAttribute('fill', 'url(' + href() + '#' + grad.id + ')');\n    el = domChild(el, index++, 'radialGradient', ns);\n    el.setAttribute('id', grad.id);\n    el.setAttribute('fx', grad.x1);\n    el.setAttribute('fy', grad.y1);\n    el.setAttribute('fr', grad.r1);\n    el.setAttribute('cx', grad.x2);\n    el.setAttribute('cy', grad.y2);\n    el.setAttribute('r', grad.r2);\n  } else {\n    el = domChild(el, index++, 'linearGradient', ns);\n    el.setAttribute('id', grad.id);\n    el.setAttribute('x1', grad.x1);\n    el.setAttribute('x2', grad.x2);\n    el.setAttribute('y1', grad.y1);\n    el.setAttribute('y2', grad.y2);\n  }\n\n  for (i = 0, n = grad.stops.length; i < n; ++i) {\n    stop = domChild(el, i, 'stop', ns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n\n  domClear(el, i);\n  return index;\n}\n\nfunction updateClipping(el, clip, index) {\n  var mask;\n  el = domChild(el, index, 'clipPath', ns);\n  el.setAttribute('id', clip.id);\n\n  if (clip.path) {\n    mask = domChild(el, 0, 'path', ns);\n    mask.setAttribute('d', clip.path);\n  } else {\n    mask = domChild(el, 0, 'rect', ns);\n    mask.setAttribute('x', 0);\n    mask.setAttribute('y', 0);\n    mask.setAttribute('width', clip.width);\n    mask.setAttribute('height', clip.height);\n  }\n\n  domClear(el, 1);\n  return index + 1;\n}\n\nprototype._resetDefs = function () {\n  var def = this._defs;\n  def.gradient = {};\n  def.clipping = {};\n}; // -- Manage rendering of items marked as dirty --\n\n\nprototype.dirty = function (item) {\n  if (item.dirty !== this._dirtyID) {\n    item.dirty = this._dirtyID;\n\n    this._dirty.push(item);\n  }\n};\n\nprototype.isDirty = function (item) {\n  return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;\n};\n\nprototype._dirtyCheck = function () {\n  this._dirtyAll = true;\n  var items = this._dirty;\n  if (!items.length || !this._dirtyID) return true;\n  var id = ++this._dirtyID,\n      item,\n      mark,\n      type,\n      mdef,\n      i,\n      n,\n      o;\n\n  for (i = 0, n = items.length; i < n; ++i) {\n    item = items[i];\n    mark = item.mark;\n\n    if (mark.marktype !== type) {\n      // memoize mark instance lookup\n      type = mark.marktype;\n      mdef = marks[type];\n    }\n\n    if (mark.zdirty && mark.dirty !== id) {\n      this._dirtyAll = false;\n      dirtyParents(item, id);\n      mark.items.forEach(function (i) {\n        i.dirty = id;\n      });\n    }\n\n    if (mark.zdirty) continue; // handle in standard drawing pass\n\n    if (item.exit) {\n      // EXIT\n      if (mdef.nested && mark.items.length) {\n        // if nested mark with remaining points, update instead\n        o = mark.items[0];\n        if (o._svg) this._update(mdef, o._svg, o);\n      } else if (item._svg) {\n        // otherwise remove from DOM\n        o = item._svg.parentNode;\n        if (o) o.removeChild(item._svg);\n      }\n\n      item._svg = null;\n      continue;\n    }\n\n    item = mdef.nested ? mark.items[0] : item;\n    if (item._update === id) continue; // already visited\n\n    if (!item._svg || !item._svg.ownerSVGElement) {\n      // ENTER\n      this._dirtyAll = false;\n      dirtyParents(item, id);\n    } else {\n      // IN-PLACE UPDATE\n      this._update(mdef, item._svg, item);\n    }\n\n    item._update = id;\n  }\n\n  return !this._dirtyAll;\n};\n\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item = item.mark.group) {\n    item.dirty = id;\n\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n} // -- Construct & maintain scenegraph to SVG mapping ---\n// Draw a mark container.\n\n\nprototype.draw = function (el, scene, prev) {\n  if (!this.isDirty(scene)) return scene._svg;\n  var renderer = this,\n      svg = this._svg,\n      mdef = marks[scene.marktype],\n      events = scene.interactive === false ? 'none' : null,\n      isGroup = mdef.tag === 'g',\n      sibling = null,\n      i = 0,\n      parent;\n  parent = bind(scene, el, prev, 'g', svg);\n  parent.setAttribute('class', cssClass(scene));\n\n  if (!isGroup) {\n    parent.style.setProperty('pointer-events', events);\n  }\n\n  if (scene.clip) {\n    parent.setAttribute('clip-path', clip(renderer, scene, scene.group));\n  } else {\n    parent.removeAttribute('clip-path');\n  }\n\n  function process(item) {\n    var dirty = renderer.isDirty(item),\n        node = bind(item, parent, sibling, mdef.tag, svg);\n\n    if (dirty) {\n      renderer._update(mdef, node, item);\n\n      if (isGroup) recurse(renderer, node, item);\n    }\n\n    sibling = node;\n    ++i;\n  }\n\n  if (mdef.nested) {\n    if (scene.items.length) process(scene.items[0]);\n  } else {\n    visit(scene, process);\n  }\n\n  domClear(parent, i);\n  return parent;\n}; // Recursively process group contents.\n\n\nfunction recurse(renderer, el, group) {\n  el = el.lastChild.previousSibling;\n  var prev,\n      idx = 0;\n  visit(group, function (item) {\n    prev = renderer.draw(el, item, prev);\n    ++idx;\n  }); // remove any extraneous DOM elements\n\n  domClear(el, 1 + idx);\n} // Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\n\n\nfunction bind(item, el, sibling, tag, svg) {\n  var node = item._svg,\n      doc; // create a new dom node if needed\n\n  if (!node) {\n    doc = el.ownerDocument;\n    node = domCreate(doc, tag, ns);\n    item._svg = node;\n\n    if (item.mark) {\n      node.__data__ = item;\n      node.__values__ = {\n        fill: 'default'\n      }; // if group, create background, content, and foreground elements\n\n      if (tag === 'g') {\n        var bg = domCreate(doc, 'path', ns);\n        node.appendChild(bg);\n        bg.__data__ = item;\n        var cg = domCreate(doc, 'g', ns);\n        node.appendChild(cg);\n        cg.__data__ = item;\n        var fg = domCreate(doc, 'path', ns);\n        node.appendChild(fg);\n        fg.__data__ = item;\n        fg.__values__ = {\n          fill: 'default'\n        };\n      }\n    }\n  } // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\n\n\n  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {\n    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n  }\n\n  return node;\n}\n\nfunction siblingCheck(node, sibling) {\n  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same\n} // -- Set attributes & styles on SVG elements ---\n\n\nvar element = null,\n    // temp var for current SVG element\nvalues = null; // temp var for current values hash\n// Extra configuration for certain mark types\n\nvar mark_extras = {\n  group: function group(mdef, el, item) {\n    var fg, bg;\n    element = fg = el.childNodes[2];\n    values = fg.__values__;\n    mdef.foreground(emit, item, this);\n    values = el.__values__; // use parent's values hash\n\n    element = el.childNodes[1];\n    mdef.content(emit, item, this);\n    element = bg = el.childNodes[0];\n    mdef.background(emit, item, this);\n    var value = item.mark.interactive === false ? 'none' : null;\n\n    if (value !== values.events) {\n      fg.style.setProperty('pointer-events', value);\n      bg.style.setProperty('pointer-events', value);\n      values.events = value;\n    }\n\n    if (item.strokeForeground && item.stroke) {\n      var fill = item.fill;\n      fg.style.removeProperty('display'); // set style of background\n\n      this.style(bg, item);\n      bg.style.removeProperty('stroke'); // set style of foreground\n\n      if (fill) item.fill = null;\n      values = fg.__values__;\n      this.style(fg, item);\n      if (fill) item.fill = fill; // leave element null to prevent downstream styling\n\n      element = null;\n    } else {\n      // ensure foreground is ignored\n      fg.style.setProperty('display', 'none');\n      fg.style.setProperty('fill', 'none');\n    }\n  },\n  image: function image(mdef, el, item) {\n    if (item.smooth === false) {\n      setStyle(el, 'image-rendering', 'optimizeSpeed');\n      setStyle(el, 'image-rendering', 'pixelated');\n    } else {\n      setStyle(el, 'image-rendering', null);\n    }\n  },\n  text: function text(mdef, el, item) {\n    var tl = textLines(item),\n        key,\n        value,\n        doc,\n        lh;\n\n    if (isArray(tl)) {\n      // multi-line text\n      value = tl.map(function (_) {\n        return textValue(item, _);\n      });\n      key = value.join('\\n'); // content cache key\n\n      if (key !== values.text) {\n        domClear(el, 0);\n        doc = el.ownerDocument;\n        lh = lineHeight(item);\n        value.forEach(function (t, i) {\n          var ts = domCreate(doc, 'tspan', ns);\n          ts.__data__ = item; // data binding\n\n          ts.textContent = t;\n\n          if (i) {\n            ts.setAttribute('x', 0);\n            ts.setAttribute('dy', lh);\n          }\n\n          el.appendChild(ts);\n        });\n        values.text = key;\n      }\n    } else {\n      // single-line text\n      value = textValue(item, tl);\n\n      if (value !== values.text) {\n        el.textContent = value;\n        values.text = value;\n      }\n    }\n\n    setStyle(el, 'font-family', fontFamily(item));\n    setStyle(el, 'font-size', fontSize(item) + 'px');\n    setStyle(el, 'font-style', item.fontStyle);\n    setStyle(el, 'font-variant', item.fontVariant);\n    setStyle(el, 'font-weight', item.fontWeight);\n  }\n};\n\nfunction setStyle(el, name, value) {\n  if (value !== values[name]) {\n    if (value == null) {\n      el.style.removeProperty(name);\n    } else {\n      el.style.setProperty(name, value + '');\n    }\n\n    values[name] = value;\n  }\n}\n\nprototype._update = function (mdef, el, item) {\n  // set dom element and values cache\n  // provides access to emit method\n  element = el;\n  values = el.__values__; // apply svg attributes\n\n  mdef.attr(emit, item, this); // some marks need special treatment\n\n  var extra = mark_extras[mdef.type];\n  if (extra) extra.call(this, mdef, el, item); // apply svg css styles\n  // note: element may be modified by 'extra' method\n\n  if (element) this.style(element, item);\n};\n\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return;\n\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    if (ns) {\n      element.setAttributeNS(ns, name, value);\n    } else {\n      element.setAttribute(name, value);\n    }\n  } else {\n    // else remove DOM attribute\n    if (ns) {\n      element.removeAttributeNS(ns, name);\n    } else {\n      element.removeAttribute(name);\n    }\n  } // note current value for future comparison\n\n\n  values[name] = value;\n}\n\nprototype.style = function (el, o) {\n  if (o == null) return;\n  var i, n, prop, name, value;\n\n  for (i = 0, n = styleProperties.length; i < n; ++i) {\n    prop = styleProperties[i];\n    value = o[prop];\n\n    if (prop === 'font') {\n      value = fontFamily(o);\n    }\n\n    if (value === values[prop]) continue;\n    name = styles[prop];\n\n    if (value == null) {\n      if (name === 'fill') {\n        el.style.setProperty(name, 'none');\n      } else {\n        el.style.removeProperty(name);\n      }\n    } else {\n      if (isGradient(value)) {\n        value = gradientRef(value, this._defs.gradient, href());\n      }\n\n      el.style.setProperty(name, value + '');\n    }\n\n    values[prop] = value;\n  }\n};\n\nfunction href() {\n  var loc;\n  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;\n}","map":null,"metadata":{},"sourceType":"module"}