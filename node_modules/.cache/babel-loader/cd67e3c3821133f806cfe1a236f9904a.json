{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { isFieldDef } from '../../../channeldef';\nimport { getFirstDefined } from '../../../util';\nimport { getStyleConfig } from '../../common';\nimport { getOffset } from './offset';\nimport { alignedPositionChannel } from './position-align';\nimport { pointPosition, pointPositionDefaultRef } from './position-point';\nimport * as ref from './valueref';\nexport function pointOrRangePosition(channel, model, _ref) {\n  var defaultPos = _ref.defaultPos,\n      defaultPos2 = _ref.defaultPos2,\n      range = _ref.range;\n\n  if (range) {\n    return rangePosition(channel, model, {\n      defaultPos: defaultPos,\n      defaultPos2: defaultPos2\n    });\n  }\n\n  return pointPosition(channel, model, {\n    defaultPos: defaultPos\n  });\n}\nexport function rangePosition(channel, model, _ref2) {\n  var defaultPos = _ref2.defaultPos,\n      defaultPos2 = _ref2.defaultPos2;\n  var markDef = model.markDef,\n      config = model.config;\n  var channel2 = channel === 'x' ? 'x2' : 'y2';\n  var sizeChannel = channel === 'x' ? 'width' : 'height';\n  var pos2Mixins = pointPosition2(model, defaultPos2, channel2);\n  var vgChannel = pos2Mixins[sizeChannel] ? alignedPositionChannel(channel, markDef, config) : channel;\n  return Object.assign(Object.assign({}, pointPosition(channel, model, {\n    defaultPos: defaultPos,\n    vgChannel: vgChannel\n  })), pos2Mixins);\n}\n/**\n * Return encode for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\n\nfunction pointPosition2(model, defaultPos, channel) {\n  var _position2orSize;\n\n  var encoding = model.encoding,\n      mark = model.mark,\n      markDef = model.markDef,\n      stack = model.stack,\n      config = model.config;\n  var baseChannel = channel === 'x2' ? 'x' : 'y';\n  var sizeChannel = channel === 'x2' ? 'width' : 'height';\n  var channelDef = encoding[baseChannel];\n  var scaleName = model.scaleName(baseChannel);\n  var scale = model.getScaleComponent(baseChannel);\n  var offset = getOffset(channel, model.markDef);\n\n  if (!channelDef && (encoding.latitude || encoding.longitude)) {\n    // use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.\n    return _defineProperty({}, channel, {\n      field: model.getName(channel)\n    });\n  }\n\n  var valueRef = position2Ref({\n    channel: channel,\n    channelDef: channelDef,\n    channel2Def: encoding[channel],\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return _defineProperty({}, channel, valueRef);\n  }\n\n  var defaultRef = pointPositionDefaultRef({\n    model: model,\n    markDef: markDef,\n    config: config,\n    defaultPos: defaultPos,\n    channel: channel,\n    scaleName: scaleName,\n    scale: scale,\n    mark: mark,\n    checkBarAreaWithoutZero: !encoding[channel] // only check for non-ranged marks\n\n  })(); // TODO: check width/height encoding here once we add them\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n  return getFirstDefined(position2orSize(channel, markDef), position2orSize(channel, (_position2orSize = {}, _defineProperty(_position2orSize, channel, getStyleConfig(channel, markDef, config.style)), _defineProperty(_position2orSize, sizeChannel, getStyleConfig(sizeChannel, markDef, config.style)), _position2orSize)), position2orSize(channel, config[mark]), position2orSize(channel, config.mark), _defineProperty({}, channel, defaultRef));\n}\n\nfunction position2Ref(_ref5) {\n  var channel = _ref5.channel,\n      channelDef = _ref5.channelDef,\n      channel2Def = _ref5.channel2Def,\n      markDef = _ref5.markDef,\n      config = _ref5.config,\n      scaleName = _ref5.scaleName,\n      scale = _ref5.scale,\n      stack = _ref5.stack,\n      offset = _ref5.offset,\n      defaultRef = _ref5.defaultRef;\n\n  if (isFieldDef(channelDef) && stack && // If fieldChannel is X and channel is X2 (or Y and Y2)\n  channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n    return ref.fieldRef(channelDef, scaleName, {\n      suffix: 'start'\n    }, {\n      offset: offset\n    });\n  }\n\n  return ref.midPointRefWithPositionInvalidTest({\n    channel: channel,\n    channelDef: channel2Def,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    markDef: markDef,\n    config: config,\n    offset: offset,\n    defaultRef: defaultRef\n  });\n}\n\nfunction position2orSize(channel, markDef) {\n  var sizeChannel = channel === 'x2' ? 'width' : 'height';\n\n  if (markDef[channel]) {\n    return _defineProperty({}, channel, ref.widthHeightValueRef(channel, markDef[channel]));\n  } else if (markDef[sizeChannel]) {\n    return _defineProperty({}, sizeChannel, {\n      value: markDef[sizeChannel]\n    });\n  }\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"module"}