{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash as _hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport var ImputeNode =\n/*#__PURE__*/\nfunction (_DataFlowNode) {\n  _inherits(ImputeNode, _DataFlowNode);\n\n  function ImputeNode(parent, transform) {\n    var _this;\n\n    _classCallCheck(this, ImputeNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ImputeNode).call(this, parent));\n    _this.transform = transform;\n    return _this;\n  }\n\n  _createClass(ImputeNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new ImputeNode(null, duplicate(this.transform));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      var _a;\n\n      return new Set([this.transform.impute, this.transform.key].concat(_toConsumableArray((_a = this.transform.groupby, _a !== null && _a !== void 0 ? _a : []))));\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set([this.transform.impute]);\n    }\n  }, {\n    key: \"processSequence\",\n    value: function processSequence(keyvals) {\n      var _keyvals$start = keyvals.start,\n          start = _keyvals$start === void 0 ? 0 : _keyvals$start,\n          stop = keyvals.stop,\n          step = keyvals.step;\n      var result = [start, stop].concat(_toConsumableArray(step ? [step] : [])).join(',');\n      return {\n        signal: \"sequence(\".concat(result, \")\")\n      };\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Impute \".concat(_hash(this.transform));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var _this$transform = this.transform,\n          impute = _this$transform.impute,\n          key = _this$transform.key,\n          keyvals = _this$transform.keyvals,\n          method = _this$transform.method,\n          groupby = _this$transform.groupby,\n          value = _this$transform.value,\n          _this$transform$frame = _this$transform.frame,\n          frame = _this$transform$frame === void 0 ? [null, null] : _this$transform$frame;\n      var initialImpute = Object.assign(Object.assign(Object.assign(Object.assign({\n        type: 'impute',\n        field: impute,\n        key: key\n      }, keyvals ? {\n        keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals\n      } : {}), {\n        method: 'value'\n      }), groupby ? {\n        groupby: groupby\n      } : {}), {\n        value: null\n      });\n      var setImputedField;\n\n      if (method && method !== 'value') {\n        var deriveNewField = Object.assign({\n          type: 'window',\n          as: [\"imputed_\".concat(impute, \"_value\")],\n          ops: [method],\n          fields: [impute],\n          frame: frame,\n          ignorePeers: false\n        }, groupby ? {\n          groupby: groupby\n        } : {});\n        var replaceOriginal = {\n          type: 'formula',\n          expr: \"datum.\".concat(impute, \" === null ? datum.imputed_\").concat(impute, \"_value : datum.\").concat(impute),\n          as: impute\n        };\n        setImputedField = [deriveNewField, replaceOriginal];\n      } else {\n        var replaceWithValue = {\n          type: 'formula',\n          expr: \"datum.\".concat(impute, \" === null ? \").concat(value, \" : datum.\").concat(impute),\n          as: impute\n        };\n        setImputedField = [replaceWithValue];\n      }\n\n      return [initialImpute].concat(_toConsumableArray(setImputedField));\n    }\n  }], [{\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, imputeTransform) {\n      return new ImputeNode(parent, imputeTransform);\n    }\n  }, {\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var encoding = model.encoding;\n      var xDef = encoding.x;\n      var yDef = encoding.y;\n\n      if (isFieldDef(xDef) && isFieldDef(yDef)) {\n        var imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n\n        if (imputedChannel === undefined) {\n          return undefined;\n        }\n\n        var keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n        var _imputedChannel$imput = imputedChannel.impute,\n            method = _imputedChannel$imput.method,\n            value = _imputedChannel$imput.value,\n            frame = _imputedChannel$imput.frame,\n            keyvals = _imputedChannel$imput.keyvals;\n        var groupbyFields = pathGroupingFields(model.mark, encoding);\n        return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n          impute: imputedChannel.field,\n          key: keyChannel.field\n        }, method ? {\n          method: method\n        } : {}), value !== undefined ? {\n          value: value\n        } : {}), frame ? {\n          frame: frame\n        } : {}), keyvals !== undefined ? {\n          keyvals: keyvals\n        } : {}), groupbyFields.length ? {\n          groupby: groupbyFields\n        } : {}));\n      }\n\n      return null;\n    }\n  }]);\n\n  return ImputeNode;\n}(DataFlowNode);","map":null,"metadata":{},"sourceType":"module"}