{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isArray } from 'vega-util';\nimport { isArgmaxDef, isArgminDef } from './aggregate';\nimport { isBinned, isBinning } from './bin';\nimport { CHANNELS, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, supportMark } from './channel';\nimport { binRequiresRange, getFieldDef, getGuide, getTypedFieldDef, hasConditionalFieldDef, isConditionalDef, isFieldDef, isTypedFieldDef, isValueDef, normalize, normalizeFieldDef, title, vgField } from './channeldef';\nimport * as log from './log';\nimport { TEMPORAL } from './type';\nimport { keys, some } from './util';\nexport function channelHasField(encoding, channel) {\n  var channelDef = encoding && encoding[channel];\n\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, function (fieldDef) {\n        return !!fieldDef.field;\n      });\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n    }\n  }\n\n  return false;\n}\nexport function isAggregate(encoding) {\n  return some(CHANNELS, function (channel) {\n    if (channelHasField(encoding, channel)) {\n      var channelDef = encoding[channel];\n\n      if (isArray(channelDef)) {\n        return some(channelDef, function (fieldDef) {\n          return !!fieldDef.aggregate;\n        });\n      } else {\n        var fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n\n    return false;\n  });\n}\nexport function extractTransformsFromEncoding(oldEncoding, config) {\n  var groupby = [];\n  var bins = [];\n  var timeUnits = [];\n  var aggregate = [];\n  var encoding = {};\n  forEach(oldEncoding, function (channelDef, channel) {\n    // Extract potential embedded transformations along with remaining properties\n    if (isFieldDef(channelDef)) {\n      var field = channelDef.field,\n          aggOp = channelDef.aggregate,\n          timeUnit = channelDef.timeUnit,\n          bin = channelDef.bin,\n          remaining = __rest(channelDef, [\"field\", \"aggregate\", \"timeUnit\", \"bin\"]);\n\n      if (aggOp || timeUnit || bin) {\n        var guide = getGuide(channelDef);\n        var isTitleDefined = guide && guide.title;\n        var newField = vgField(channelDef, {\n          forAs: true\n        });\n        var newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : {\n          title: title(channelDef, config, {\n            allowDisabling: true\n          })\n        }), remaining), {\n          // Always overwrite field\n          field: newField\n        });\n        var isPositionChannel = channel === 'x' || channel === 'y';\n\n        if (aggOp) {\n          var op;\n\n          if (isArgmaxDef(aggOp)) {\n            op = 'argmax';\n            newField = vgField({\n              op: 'argmax',\n              field: aggOp.argmax\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = \"\".concat(newField, \".\").concat(field);\n          } else if (isArgminDef(aggOp)) {\n            op = 'argmin';\n            newField = vgField({\n              op: 'argmin',\n              field: aggOp.argmin\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = \"\".concat(newField, \".\").concat(field);\n          } else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n            op = aggOp;\n          }\n\n          if (op) {\n            var aggregateEntry = {\n              op: op,\n              as: newField\n            };\n\n            if (field) {\n              aggregateEntry.field = field;\n            }\n\n            aggregate.push(aggregateEntry);\n          }\n        } else {\n          groupby.push(newField);\n\n          if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n            bins.push({\n              bin: bin,\n              field: field,\n              as: newField\n            }); // Add additional groupbys for range and end of bins\n\n            groupby.push(vgField(channelDef, {\n              binSuffix: 'end'\n            }));\n\n            if (binRequiresRange(channelDef, channel)) {\n              groupby.push(vgField(channelDef, {\n                binSuffix: 'range'\n              }));\n            } // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n\n\n            if (isPositionChannel) {\n              var secondaryChannel = {\n                field: newField + '_end'\n              };\n              encoding[channel + '2'] = secondaryChannel;\n            }\n\n            newFieldDef.bin = 'binned';\n\n            if (!isSecondaryRangeChannel(channel)) {\n              newFieldDef['type'] = 'quantitative';\n            }\n          } else if (timeUnit) {\n            timeUnits.push({\n              timeUnit: timeUnit,\n              field: field,\n              as: newField\n            }); // define the format type for later compilation\n\n            var formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n\n            if (formatType) {\n              if (channel === 'text' || channel === 'tooltip') {\n                newFieldDef['formatType'] = formatType;\n              } else if (isNonPositionScaleChannel(channel)) {\n                newFieldDef['legend'] = Object.assign({\n                  formatType: formatType\n                }, newFieldDef['legend']);\n              } else if (isPositionChannel) {\n                newFieldDef['axis'] = Object.assign({\n                  formatType: formatType\n                }, newFieldDef['axis']);\n              }\n            }\n          }\n        } // now the field should refer to post-transformed field instead\n\n\n        encoding[channel] = newFieldDef;\n      } else {\n        groupby.push(field);\n        encoding[channel] = oldEncoding[channel];\n      }\n    } else {\n      // For value def, just copy\n      encoding[channel] = oldEncoding[channel];\n    }\n  });\n  return {\n    bins: bins,\n    timeUnits: timeUnits,\n    aggregate: aggregate,\n    groupby: groupby,\n    encoding: encoding\n  };\n}\nexport function markChannelCompatible(encoding, channel, mark) {\n  var markSupported = supportMark(channel, mark);\n\n  if (!markSupported) {\n    return false;\n  } else if (markSupported === 'binned') {\n    var primaryFieldDef = encoding[channel === 'x2' ? 'x' : 'y']; // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function normalizeEncoding(encoding, markDef) {\n  var mark = markDef.type;\n  return keys(encoding).reduce(function (normalizedEncoding, channel) {\n    var _a;\n\n    if (!isChannel(channel)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(channel));\n      return normalizedEncoding;\n    }\n\n    if (!markChannelCompatible(encoding, channel, mark)) {\n      // Drop unsupported channel\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      return normalizedEncoding;\n    } // Drop line's size if the field is aggregated.\n\n\n    if (channel === 'size' && mark === 'line') {\n      var fieldDef = getTypedFieldDef(encoding[channel]);\n\n      if ((_a = fieldDef) === null || _a === void 0 ? void 0 : _a.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        return normalizedEncoding;\n      }\n    } // Drop color if either fill or stroke is specified\n\n\n    if (channel === 'color' && (markDef.filled ? 'fill' in encoding : 'stroke' in encoding)) {\n      log.warn(log.message.droppingColor('encoding', {\n        fill: 'fill' in encoding,\n        stroke: 'stroke' in encoding\n      }));\n      return normalizedEncoding;\n    }\n\n    var channelDef = encoding[channel];\n\n    if (channel === 'detail' || channel === 'order' && !isArray(channelDef) && !isValueDef(channelDef) || channel === 'tooltip' && isArray(channelDef)) {\n      if (channelDef) {\n        // Array of fieldDefs for detail channel (or production rule)\n        normalizedEncoding[channel] = (isArray(channelDef) ? channelDef : [channelDef]).reduce(function (defs, fieldDef) {\n          if (!isFieldDef(fieldDef)) {\n            log.warn(log.message.emptyFieldDef(fieldDef, channel));\n          } else {\n            defs.push(normalizeFieldDef(fieldDef, channel));\n          }\n\n          return defs;\n        }, []);\n      }\n    } else {\n      if (channel === 'tooltip' && channelDef === null) {\n        // Preserve null so we can use it to disable tooltip\n        normalizedEncoding[channel] = null;\n      } else if (!isFieldDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef)) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        return normalizedEncoding;\n      }\n\n      normalizedEncoding[channel] = normalize(channelDef, channel);\n    }\n\n    return normalizedEncoding;\n  }, {});\n}\nexport function fieldDefs(encoding) {\n  var arr = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = keys(encoding)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var channel = _step.value;\n\n      if (channelHasField(encoding, channel)) {\n        var channelDef = encoding[channel];\n        var channelDefArray = isArray(channelDef) ? channelDef : [channelDef];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = channelDefArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var def = _step2.value;\n\n            if (isFieldDef(def)) {\n              arr.push(def);\n            } else if (hasConditionalFieldDef(def)) {\n              arr.push(def.condition);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return arr;\n}\nexport function forEach(mapping, f, thisArg) {\n  if (!mapping) {\n    return;\n  }\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var channel = _step3.value;\n      var el = mapping[channel];\n\n      if (isArray(el)) {\n        el.forEach(function (channelDef) {\n          f.call(thisArg, channelDef, channel);\n        });\n      } else {\n        f.call(thisArg, el, channel);\n      }\n    };\n\n    for (var _iterator3 = keys(mapping)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      _loop();\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n}\nexport function reduce(mapping, f, init, thisArg) {\n  if (!mapping) {\n    return init;\n  }\n\n  return keys(mapping).reduce(function (r, channel) {\n    var map = mapping[channel];\n\n    if (isArray(map)) {\n      return map.reduce(function (r1, channelDef) {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n/**\n * Returns list of path grouping fields for the given encoding\n */\n\nexport function pathGroupingFields(mark, encoding) {\n  return keys(encoding).reduce(function (details, channel) {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group\n      case 'x':\n      case 'y':\n      case 'href':\n      case 'url':\n      case 'x2':\n      case 'y2': // falls through\n\n      case 'latitude':\n      case 'longitude':\n      case 'latitude2':\n      case 'longitude2': // TODO: case 'cursor':\n      // text, shape, shouldn't be a part of line/trail/area [falls through]\n\n      case 'text':\n      case 'shape': // falls through\n      // tooltip fields should not be added to group by [falls through]\n\n      case 'tooltip':\n        return details;\n\n      case 'order':\n        // order should not group line / trail\n        if (mark === 'line' || mark === 'trail') {\n          return details;\n        }\n\n      // but order should group area for stacking (falls through)\n\n      case 'detail':\n      case 'key':\n        {\n          var channelDef = encoding[channel];\n\n          if (isArray(channelDef) || isFieldDef(channelDef)) {\n            (isArray(channelDef) ? channelDef : [channelDef]).forEach(function (fieldDef) {\n              if (!fieldDef.aggregate) {\n                details.push(vgField(fieldDef, {}));\n              }\n            });\n          }\n\n          return details;\n        }\n\n      case 'size':\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n\n      // For line, size should group lines.\n      // falls through\n\n      case 'color':\n      case 'fill':\n      case 'stroke':\n      case 'opacity':\n      case 'fillOpacity':\n      case 'strokeOpacity':\n      case 'strokeWidth':\n        {\n          // TODO strokeDashOffset:\n          // falls through\n          var fieldDef = getTypedFieldDef(encoding[channel]);\n\n          if (fieldDef && !fieldDef.aggregate) {\n            details.push(vgField(fieldDef, {}));\n          }\n\n          return details;\n        }\n    }\n  }, []);\n}","map":null,"metadata":{},"sourceType":"module"}