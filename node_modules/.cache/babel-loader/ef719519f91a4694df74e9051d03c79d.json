{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { __rest } from \"tslib\";\nimport { isNumber, isObject } from 'vega-util';\nimport { extractTransformsFromEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined, keys } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, filterTooltipWithAggregatedField, getCompositeMarkTooltip, getTitle, makeCompositeAggregatePartFactory, partLayerMixins } from './common';\nexport var BOXPLOT = 'boxplot';\nvar BOXPLOT_PART_INDEX = {\n  box: 1,\n  median: 1,\n  outliers: 1,\n  rule: 1,\n  ticks: 1\n};\nexport var BOXPLOT_PARTS = keys(BOXPLOT_PART_INDEX);\nexport var boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);\nexport function getBoxPlotType(extent) {\n  if (isNumber(extent)) {\n    return 'tukey';\n  } // Ham: If we ever want to, we could add another extent syntax `{kIQR: number}` for the original [Q1-k*IQR, Q3+k*IQR] whisker and call this boxPlotType = `kIQR`. However, I'm not exposing this for now.\n\n\n  return extent;\n}\nexport function normalizeBoxPlot(spec, _ref) {\n  var config = _ref.config;\n\n  var _a, _b; // TODO: use selection\n\n\n  var mark = spec.mark,\n      _encoding = spec.encoding,\n      selection = spec.selection,\n      _p = spec.projection,\n      outerSpec = __rest(spec, [\"mark\", \"encoding\", \"selection\", \"projection\"]);\n\n  var markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  }; // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n\n  if (selection) {\n    log.warn(log.message.selectionNotSupported('boxplot'));\n  }\n\n  var extent = (_a = markDef.extent, _a !== null && _a !== void 0 ? _a : config.boxplot.extent);\n  var sizeValue = getFirstDefined(markDef.size, config.boxplot.size);\n  var boxPlotType = getBoxPlotType(extent);\n\n  var _boxParams = boxParams(spec, extent, config),\n      transform = _boxParams.transform,\n      continuousAxisChannelDef = _boxParams.continuousAxisChannelDef,\n      continuousAxis = _boxParams.continuousAxis,\n      groupby = _boxParams.groupby,\n      aggregate = _boxParams.aggregate,\n      encodingWithoutContinuousAxis = _boxParams.encodingWithoutContinuousAxis,\n      ticksOrient = _boxParams.ticksOrient,\n      boxOrient = _boxParams.boxOrient,\n      customTooltipWithoutAggregatedField = _boxParams.customTooltipWithoutAggregatedField;\n\n  var color = encodingWithoutContinuousAxis.color,\n      size = encodingWithoutContinuousAxis.size,\n      encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, [\"color\", \"size\"]);\n\n  var makeBoxPlotPart = function makeBoxPlotPart(sharedEncoding) {\n    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);\n  };\n\n  var makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n  var makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n  var makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? {\n    size: size\n  } : {}));\n  var fiveSummaryTooltipEncoding = getCompositeMarkTooltip([{\n    fieldPrefix: boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_',\n    titlePrefix: 'Max'\n  }, {\n    fieldPrefix: 'upper_box_',\n    titlePrefix: 'Q3'\n  }, {\n    fieldPrefix: 'mid_box_',\n    titlePrefix: 'Median'\n  }, {\n    fieldPrefix: 'lower_box_',\n    titlePrefix: 'Q1'\n  }, {\n    fieldPrefix: boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_',\n    titlePrefix: 'Min'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis); // ## Whisker Layers\n\n  var endTick = {\n    type: 'tick',\n    color: 'black',\n    opacity: 1,\n    orient: ticksOrient,\n    invalid: null\n  };\n  var whiskerTooltipEncoding = boxPlotType === 'min-max' ? fiveSummaryTooltipEncoding // for min-max, show five-summary tooltip for whisker\n  : // for tukey / k-IQR, just show upper/lower-whisker\n  getCompositeMarkTooltip([{\n    fieldPrefix: 'upper_whisker_',\n    titlePrefix: 'Upper Whisker'\n  }, {\n    fieldPrefix: 'lower_whisker_',\n    titlePrefix: 'Lower Whisker'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n  var whiskerLayers = [].concat(_toConsumableArray(makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: null\n    },\n    positionPrefix: 'lower_whisker',\n    endPositionPrefix: 'lower_box',\n    extraEncoding: whiskerTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: null\n    },\n    positionPrefix: 'upper_box',\n    endPositionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'lower_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  }))); // ## Box Layers\n  // TODO: support hiding certain mark parts\n\n  var boxLayers = [].concat(_toConsumableArray(boxPlotType !== 'tukey' ? whiskerLayers : []), _toConsumableArray(makeBoxPlotBox({\n    partName: 'box',\n    mark: Object.assign(Object.assign({\n      type: 'bar'\n    }, sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: boxOrient,\n      invalid: null\n    }),\n    positionPrefix: 'lower_box',\n    endPositionPrefix: 'upper_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  })), _toConsumableArray(makeBoxPlotMidTick({\n    partName: 'median',\n    mark: Object.assign(Object.assign(Object.assign({\n      type: 'tick',\n      invalid: null\n    }, isObject(config.boxplot.median) && config.boxplot.median.color ? {\n      color: config.boxplot.median.color\n    } : {}), sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: ticksOrient\n    }),\n    positionPrefix: 'mid_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  }))); // ## Filtered Layers\n\n  var filteredLayersMixins;\n\n  if (boxPlotType !== 'min-max') {\n    var lowerBoxExpr = \"datum[\\\"lower_box_\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n    var upperBoxExpr = \"datum[\\\"upper_box_\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n    var iqrExpr = \"(\".concat(upperBoxExpr, \" - \").concat(lowerBoxExpr, \")\");\n    var lowerWhiskerExpr = \"\".concat(lowerBoxExpr, \" - \").concat(extent, \" * \").concat(iqrExpr);\n    var upperWhiskerExpr = \"\".concat(upperBoxExpr, \" + \").concat(extent, \" * \").concat(iqrExpr);\n    var fieldExpr = \"datum[\\\"\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n    var joinaggregateTransform = {\n      joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),\n      groupby: groupby\n    };\n    var filteredWhiskerSpec = undefined;\n\n    if (boxPlotType === 'tukey') {\n      filteredWhiskerSpec = {\n        transform: [{\n          filter: \"(\".concat(lowerWhiskerExpr, \" <= \").concat(fieldExpr, \") && (\").concat(fieldExpr, \" <= \").concat(upperWhiskerExpr, \")\")\n        }, {\n          aggregate: [{\n            op: 'min',\n            field: continuousAxisChannelDef.field,\n            as: 'lower_whisker_' + continuousAxisChannelDef.field\n          }, {\n            op: 'max',\n            field: continuousAxisChannelDef.field,\n            as: 'upper_whisker_' + continuousAxisChannelDef.field\n          }, // preserve lower_box / upper_box\n          {\n            op: 'min',\n            field: 'lower_box_' + continuousAxisChannelDef.field,\n            as: 'lower_box_' + continuousAxisChannelDef.field\n          }, {\n            op: 'max',\n            field: 'upper_box_' + continuousAxisChannelDef.field,\n            as: 'upper_box_' + continuousAxisChannelDef.field\n          }].concat(_toConsumableArray(aggregate)),\n          groupby: groupby\n        }],\n        layer: whiskerLayers\n      };\n    }\n\n    var tooltip = encodingWithoutSizeColorAndContinuousAxis.tooltip,\n        encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, [\"tooltip\"]);\n\n    var scale = continuousAxisChannelDef.scale,\n        axis = continuousAxisChannelDef.axis;\n    var title = getTitle(continuousAxisChannelDef);\n    var outlierLayersMixins = partLayerMixins(markDef, 'outliers', config.boxplot, {\n      transform: [{\n        filter: \"(\".concat(fieldExpr, \" < \").concat(lowerWhiskerExpr, \") || (\").concat(fieldExpr, \" > \").concat(upperWhiskerExpr, \")\")\n      }],\n      mark: 'point',\n      encoding: Object.assign(Object.assign(_defineProperty({}, continuousAxis, Object.assign(Object.assign(Object.assign({\n        field: continuousAxisChannelDef.field,\n        type: continuousAxisChannelDef.type\n      }, title !== undefined ? {\n        title: title\n      } : {}), scale !== undefined ? {\n        scale: scale\n      } : {}), axis !== undefined ? {\n        axis: axis\n      } : {})), encodingWithoutSizeColorContinuousAxisAndTooltip), customTooltipWithoutAggregatedField ? {\n        tooltip: customTooltipWithoutAggregatedField\n      } : {})\n    })[0];\n\n    if (outlierLayersMixins && filteredWhiskerSpec) {\n      filteredLayersMixins = {\n        transform: [joinaggregateTransform],\n        layer: [outlierLayersMixins, filteredWhiskerSpec]\n      };\n    } else if (outlierLayersMixins) {\n      filteredLayersMixins = outlierLayersMixins;\n      filteredLayersMixins.transform.unshift(joinaggregateTransform);\n    } else if (filteredWhiskerSpec) {\n      filteredLayersMixins = filteredWhiskerSpec;\n      filteredLayersMixins.transform.unshift(joinaggregateTransform);\n    }\n  }\n\n  if (filteredLayersMixins) {\n    // tukey box plot with outliers included\n    return Object.assign(Object.assign({}, outerSpec), {\n      layer: [filteredLayersMixins, {\n        // boxplot\n        transform: transform,\n        layer: boxLayers\n      }]\n    });\n  }\n\n  return Object.assign(Object.assign({}, outerSpec), {\n    transform: (_b = outerSpec.transform, _b !== null && _b !== void 0 ? _b : []).concat(transform),\n    layer: boxLayers\n  });\n}\n\nfunction boxParamsQuartiles(continousAxisField) {\n  return [{\n    op: 'q1',\n    field: continousAxisField,\n    as: 'lower_box_' + continousAxisField\n  }, {\n    op: 'q3',\n    field: continousAxisField,\n    as: 'upper_box_' + continousAxisField\n  }];\n}\n\nfunction boxParams(spec, extent, config) {\n  var orient = compositeMarkOrient(spec, BOXPLOT);\n\n  var _compositeMarkContinu = compositeMarkContinuousAxis(spec, orient, BOXPLOT),\n      continuousAxisChannelDef = _compositeMarkContinu.continuousAxisChannelDef,\n      continuousAxis = _compositeMarkContinu.continuousAxis;\n\n  var continuousFieldName = continuousAxisChannelDef.field;\n  var boxPlotType = getBoxPlotType(extent);\n  var boxplotSpecificAggregate = [].concat(_toConsumableArray(boxParamsQuartiles(continuousFieldName)), [{\n    op: 'median',\n    field: continuousFieldName,\n    as: 'mid_box_' + continuousFieldName\n  }, {\n    op: 'min',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_') + continuousFieldName\n  }, {\n    op: 'max',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_') + continuousFieldName\n  }]);\n  var postAggregateCalculates = boxPlotType === 'min-max' || boxPlotType === 'tukey' ? [] : [// This is for the  original k-IQR, which we do not expose\n  {\n    calculate: \"datum[\\\"upper_box_\".concat(continuousFieldName, \"\\\"] - datum[\\\"lower_box_\").concat(continuousFieldName, \"\\\"]\"),\n    as: 'iqr_' + continuousFieldName\n  }, {\n    calculate: \"min(datum[\\\"upper_box_\".concat(continuousFieldName, \"\\\"] + datum[\\\"iqr_\").concat(continuousFieldName, \"\\\"] * \").concat(extent, \", datum[\\\"max_\").concat(continuousFieldName, \"\\\"])\"),\n    as: 'upper_whisker_' + continuousFieldName\n  }, {\n    calculate: \"max(datum[\\\"lower_box_\".concat(continuousFieldName, \"\\\"] - datum[\\\"iqr_\").concat(continuousFieldName, \"\\\"] * \").concat(extent, \", datum[\\\"min_\").concat(continuousFieldName, \"\\\"])\"),\n    as: 'lower_whisker_' + continuousFieldName\n  }];\n\n  var _a = spec.encoding,\n      _b = continuousAxis,\n      oldContinuousAxisChannelDef = _a[_b],\n      oldEncodingWithoutContinuousAxis = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n  var _filterTooltipWithAgg = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis),\n      customTooltipWithoutAggregatedField = _filterTooltipWithAgg.customTooltipWithoutAggregatedField,\n      filteredEncoding = _filterTooltipWithAgg.filteredEncoding;\n\n  var _extractTransformsFro = extractTransformsFromEncoding(filteredEncoding, config),\n      bins = _extractTransformsFro.bins,\n      timeUnits = _extractTransformsFro.timeUnits,\n      aggregate = _extractTransformsFro.aggregate,\n      groupby = _extractTransformsFro.groupby,\n      encodingWithoutContinuousAxis = _extractTransformsFro.encoding;\n\n  var ticksOrient = orient === 'vertical' ? 'horizontal' : 'vertical';\n  var boxOrient = orient;\n  var transform = [].concat(_toConsumableArray(bins), _toConsumableArray(timeUnits), [{\n    aggregate: [].concat(_toConsumableArray(aggregate), _toConsumableArray(boxplotSpecificAggregate)),\n    groupby: groupby\n  }], postAggregateCalculates);\n  return {\n    transform: transform,\n    groupby: groupby,\n    aggregate: aggregate,\n    continuousAxisChannelDef: continuousAxisChannelDef,\n    continuousAxis: continuousAxis,\n    encodingWithoutContinuousAxis: encodingWithoutContinuousAxis,\n    ticksOrient: ticksOrient,\n    boxOrient: boxOrient,\n    customTooltipWithoutAggregatedField: customTooltipWithoutAggregatedField\n  };\n}","map":null,"metadata":{},"sourceType":"module"}