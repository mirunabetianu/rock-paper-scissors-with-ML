{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport cursor from './cursor';\nimport { data, dataref, change, insert, remove } from './data';\nimport { initializeEventConfig, events } from './events';\nimport hover from './hover';\nimport finalize from './finalize';\nimport initialize from './initialize';\nimport renderToImageURL from './render-to-image-url';\nimport renderToCanvas from './render-to-canvas';\nimport renderToSVG from './render-to-svg';\nimport { resizeRenderer } from './render-size';\nimport runtime from './runtime';\nimport { scale } from './scale';\nimport { resizeView, initializeResize, viewWidth, viewHeight } from './size';\nimport { getState, setState } from './state';\nimport timer from './timer';\nimport defaultTooltip from './tooltip';\nimport trap from './trap';\nimport { asyncCallback, Dataflow } from 'vega-dataflow';\nimport { error, extend, inherits, hasOwnProperty, stringValue } from 'vega-util';\nimport { CanvasHandler, Scenegraph, renderModule, RenderType } from 'vega-scenegraph';\n/**\n * Create a new View instance from a Vega dataflow runtime specification.\n * The generated View will not immediately be ready for display. Callers\n * should also invoke the initialize method (e.g., to set the parent\n * DOM element in browser-based deployment) and then invoke the run\n * method to evaluate the dataflow graph. Rendering will automatically\n * be peformed upon dataflow runs.\n * @constructor\n * @param {object} spec - The Vega dataflow runtime specification.\n */\n\nexport default function View(spec, options) {\n  var view = this;\n  options = options || {};\n  Dataflow.call(view);\n  if (options.loader) view.loader(options.loader);\n  if (options.logger) view.logger(options.logger);\n  if (options.logLevel != null) view.logLevel(options.logLevel);\n  view._el = null;\n  view._elBind = null;\n  view._renderType = options.renderer || RenderType.Canvas;\n  view._scenegraph = new Scenegraph();\n  var root = view._scenegraph.root; // initialize renderer, handler and event management\n\n  view._renderer = null;\n  view._tooltip = options.tooltip || defaultTooltip, view._redraw = true;\n  view._handler = new CanvasHandler().scene(root);\n  view._preventDefault = false;\n  view._timers = [];\n  view._eventListeners = [];\n  view._resizeListeners = []; // initialize event configuration\n\n  view._eventConfig = initializeEventConfig(spec.eventConfig); // initialize dataflow graph\n\n  var ctx = runtime(view, spec, options.functions);\n  view._runtime = ctx;\n  view._signals = ctx.signals;\n  view._bind = (spec.bindings || []).map(function (_) {\n    return {\n      state: null,\n      param: extend({}, _)\n    };\n  }); // initialize scenegraph\n\n  if (ctx.root) ctx.root.set(root);\n  root.source = ctx.data.root.input;\n  view.pulse(ctx.data.root.input, view.changeset().insert(root.items)); // initialize background color\n\n  view._background = options.background || ctx.background || null; // initialize view size\n\n  view._width = view.width();\n  view._height = view.height();\n  view._viewWidth = viewWidth(view, view._width);\n  view._viewHeight = viewHeight(view, view._height);\n  view._origin = [0, 0];\n  view._resize = 0;\n  view._autosize = 1;\n  initializeResize(view); // initialize cursor\n\n  cursor(view); // initialize hover proessing, if requested\n\n  if (options.hover) view.hover(); // initialize DOM container(s) and renderer\n\n  if (options.container) view.initialize(options.container, options.bind);\n}\nvar prototype = inherits(View, Dataflow); // -- DATAFLOW / RENDERING ----\n\nprototype.evaluate =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(encode, prerun, postrun) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Dataflow.prototype.evaluate.call(this, encode, prerun);\n\n          case 2:\n            if (!(this._redraw || this._resize)) {\n              _context.next = 14;\n              break;\n            }\n\n            _context.prev = 3;\n\n            if (!this._renderer) {\n              _context.next = 8;\n              break;\n            }\n\n            if (this._resize) {\n              this._resize = 0;\n              resizeRenderer(this);\n            }\n\n            _context.next = 8;\n            return this._renderer.renderAsync(this._scenegraph.root);\n\n          case 8:\n            this._redraw = false;\n            _context.next = 14;\n            break;\n\n          case 11:\n            _context.prev = 11;\n            _context.t0 = _context[\"catch\"](3);\n            this.error(_context.t0);\n\n          case 14:\n            // evaluate postrun\n            if (postrun) asyncCallback(this, postrun);\n            return _context.abrupt(\"return\", this);\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[3, 11]]);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nprototype.dirty = function (item) {\n  this._redraw = true;\n  this._renderer && this._renderer.dirty(item);\n}; // -- GET / SET ----\n\n\nprototype.container = function () {\n  return this._el;\n};\n\nprototype.scenegraph = function () {\n  return this._scenegraph;\n};\n\nprototype.origin = function () {\n  return this._origin.slice();\n};\n\nfunction lookupSignal(view, name) {\n  return hasOwnProperty(view._signals, name) ? view._signals[name] : error('Unrecognized signal name: ' + stringValue(name));\n}\n\nprototype.signal = function (name, value, options) {\n  var op = lookupSignal(this, name);\n  return arguments.length === 1 ? op.value : this.update(op, value, options);\n};\n\nprototype.background = function (_) {\n  if (arguments.length) {\n    this._background = _;\n    this._resize = 1;\n    return this;\n  } else {\n    return this._background;\n  }\n};\n\nprototype.width = function (_) {\n  return arguments.length ? this.signal('width', _) : this.signal('width');\n};\n\nprototype.height = function (_) {\n  return arguments.length ? this.signal('height', _) : this.signal('height');\n};\n\nprototype.padding = function (_) {\n  return arguments.length ? this.signal('padding', _) : this.signal('padding');\n};\n\nprototype.autosize = function (_) {\n  return arguments.length ? this.signal('autosize', _) : this.signal('autosize');\n};\n\nprototype.renderer = function (type) {\n  if (!arguments.length) return this._renderType;\n  if (!renderModule(type)) error('Unrecognized renderer type: ' + type);\n\n  if (type !== this._renderType) {\n    this._renderType = type;\n\n    this._resetRenderer();\n  }\n\n  return this;\n};\n\nprototype.tooltip = function (handler) {\n  if (!arguments.length) return this._tooltip;\n\n  if (handler !== this._tooltip) {\n    this._tooltip = handler;\n\n    this._resetRenderer();\n  }\n\n  return this;\n};\n\nprototype.loader = function (loader) {\n  if (!arguments.length) return this._loader;\n\n  if (loader !== this._loader) {\n    Dataflow.prototype.loader.call(this, loader);\n\n    this._resetRenderer();\n  }\n\n  return this;\n};\n\nprototype.resize = function () {\n  // set flag to perform autosize\n  this._autosize = 1; // touch autosize signal to ensure top-level ViewLayout runs\n\n  return this.touch(lookupSignal(this, 'autosize'));\n};\n\nprototype._resetRenderer = function () {\n  if (this._renderer) {\n    this._renderer = null;\n    this.initialize(this._el, this._elBind);\n  }\n}; // -- SIZING ----\n\n\nprototype._resizeView = resizeView; // -- EVENT HANDLING ----\n\nprototype.addEventListener = function (type, handler, options) {\n  var callback = handler;\n\n  if (!(options && options.trap === false)) {\n    // wrap callback in error handler\n    callback = trap(this, handler);\n    callback.raw = handler;\n  }\n\n  this._handler.on(type, callback);\n\n  return this;\n};\n\nprototype.removeEventListener = function (type, handler) {\n  var handlers = this._handler.handlers(type),\n      i = handlers.length,\n      h,\n      t; // search registered handlers, remove if match found\n\n\n  while (--i >= 0) {\n    t = handlers[i].type;\n    h = handlers[i].handler;\n\n    if (type === t && (handler === h || handler === h.raw)) {\n      this._handler.off(t, h);\n\n      break;\n    }\n  }\n\n  return this;\n};\n\nprototype.addResizeListener = function (handler) {\n  var l = this._resizeListeners;\n\n  if (l.indexOf(handler) < 0) {\n    // add handler if it isn't already registered\n    // note: error trapping handled elsewhere, so\n    // no need to wrap handlers here\n    l.push(handler);\n  }\n\n  return this;\n};\n\nprototype.removeResizeListener = function (handler) {\n  var l = this._resizeListeners,\n      i = l.indexOf(handler);\n\n  if (i >= 0) {\n    l.splice(i, 1);\n  }\n\n  return this;\n};\n\nfunction findOperatorHandler(op, handler) {\n  var t = op._targets || [],\n      h = t.filter(function (op) {\n    var u = op._update;\n    return u && u.handler === handler;\n  });\n  return h.length ? h[0] : null;\n}\n\nfunction addOperatorListener(view, name, op, handler) {\n  var h = findOperatorHandler(op, handler);\n\n  if (!h) {\n    h = trap(this, function () {\n      handler(name, op.value);\n    });\n    h.handler = handler;\n    view.on(op, null, h);\n  }\n\n  return view;\n}\n\nfunction removeOperatorListener(view, op, handler) {\n  var h = findOperatorHandler(op, handler);\n  if (h) op._targets.remove(h);\n  return view;\n}\n\nprototype.addSignalListener = function (name, handler) {\n  return addOperatorListener(this, name, lookupSignal(this, name), handler);\n};\n\nprototype.removeSignalListener = function (name, handler) {\n  return removeOperatorListener(this, lookupSignal(this, name), handler);\n};\n\nprototype.addDataListener = function (name, handler) {\n  return addOperatorListener(this, name, dataref(this, name).values, handler);\n};\n\nprototype.removeDataListener = function (name, handler) {\n  return removeOperatorListener(this, dataref(this, name).values, handler);\n};\n\nprototype.preventDefault = function (_) {\n  if (arguments.length) {\n    this._preventDefault = _;\n    return this;\n  } else {\n    return this._preventDefault;\n  }\n};\n\nprototype.timer = timer;\nprototype.events = events;\nprototype.finalize = finalize;\nprototype.hover = hover; // -- DATA ----\n\nprototype.data = data;\nprototype.change = change;\nprototype.insert = insert;\nprototype.remove = remove; // -- SCALES --\n\nprototype.scale = scale; // -- INITIALIZATION ----\n\nprototype.initialize = initialize; // -- HEADLESS RENDERING ----\n\nprototype.toImageURL = renderToImageURL;\nprototype.toCanvas = renderToCanvas;\nprototype.toSVG = renderToSVG; // -- SAVE / RESTORE STATE ----\n\nprototype.getState = getState;\nprototype.setState = setState;","map":null,"metadata":{},"sourceType":"module"}