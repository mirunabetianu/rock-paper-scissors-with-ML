{"ast":null,"code":"import { Group, AxisRole, LegendRole, TitleRole } from './constants';\nimport { Transform } from 'vega-dataflow';\nimport { boundClip, Marks } from 'vega-scenegraph';\nimport { inherits } from 'vega-util';\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\n\nexport default function Bound(params) {\n  Transform.call(this, null, params);\n}\nvar prototype = inherits(Bound, Transform);\n\nprototype.transform = function (_, pulse) {\n  var view = pulse.dataflow,\n      mark = _.mark,\n      type = mark.marktype,\n      entry = Marks[type],\n      bound = entry.bound,\n      markBounds = mark.bounds,\n      rebound;\n\n  if (entry.nested) {\n    // multi-item marks have a single bounds instance\n    if (mark.items.length) view.dirty(mark.items[0]);\n    markBounds = boundItem(mark, bound);\n    mark.items.forEach(function (item) {\n      item.bounds.clear().union(markBounds);\n    });\n  } else if (type === Group || _.modified()) {\n    // operator parameters modified -> re-bound all items\n    // updates group bounds in response to modified group content\n    pulse.visit(pulse.MOD, function (item) {\n      view.dirty(item);\n    });\n    markBounds.clear();\n    mark.items.forEach(function (item) {\n      markBounds.union(boundItem(item, bound));\n    }); // force reflow for axes/legends/titles to propagate any layout changes\n\n    switch (mark.role) {\n      case AxisRole:\n      case LegendRole:\n      case TitleRole:\n        pulse.reflow();\n    }\n  } else {\n    // incrementally update bounds, re-bound mark as needed\n    rebound = pulse.changed(pulse.REM);\n    pulse.visit(pulse.ADD, function (item) {\n      markBounds.union(boundItem(item, bound));\n    });\n    pulse.visit(pulse.MOD, function (item) {\n      rebound = rebound || markBounds.alignsWith(item.bounds);\n      view.dirty(item);\n      markBounds.union(boundItem(item, bound));\n    });\n\n    if (rebound) {\n      markBounds.clear();\n      mark.items.forEach(function (item) {\n        markBounds.union(item.bounds);\n      });\n    }\n  } // ensure mark bounds do not exceed any clipping region\n\n\n  boundClip(mark);\n  return pulse.modifies('bounds');\n};\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}","map":null,"metadata":{},"sourceType":"module"}