{"ast":null,"code":"import _slicedToArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport linear from './linear';\nimport { points } from './points';\nimport quad from './quad';\nimport rSquared from './r-squared'; // Adapted from d3-regression by Harry Stevens\n// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE\n// ... which was adapted from regression-js by Tom Alexander\n// Source: https://github.com/Tom-Alexander/regression-js/blob/master/src/regression.js#L246\n// License: https://github.com/Tom-Alexander/regression-js/blob/master/LICENSE\n\nexport default function (data, x, y, order) {\n  // use more efficient methods for lower orders\n  if (order === 1) return linear(data, x, y);\n  if (order === 2) return quad(data, x, y);\n\n  var _points = points(data, x, y),\n      _points2 = _slicedToArray(_points, 4),\n      xv = _points2[0],\n      yv = _points2[1],\n      ux = _points2[2],\n      uy = _points2[3],\n      n = xv.length,\n      lhs = [],\n      rhs = [],\n      k = order + 1;\n\n  var i, j, l, v, c;\n\n  for (i = 0; i < k; ++i) {\n    for (l = 0, v = 0; l < n; ++l) {\n      v += Math.pow(xv[l], i) * yv[l];\n    }\n\n    lhs.push(v);\n    c = new Float64Array(k);\n\n    for (j = 0; j < k; ++j) {\n      for (l = 0, v = 0; l < n; ++l) {\n        v += Math.pow(xv[l], i + j);\n      }\n\n      c[j] = v;\n    }\n\n    rhs.push(c);\n  }\n\n  rhs.push(lhs);\n\n  var coef = gaussianElimination(rhs),\n      predict = function predict(x) {\n    x -= ux;\n    var y = uy + coef[0] + coef[1] * x + coef[2] * x * x;\n\n    for (i = 3; i < k; ++i) {\n      y += coef[i] * Math.pow(x, i);\n    }\n\n    return y;\n  };\n\n  return {\n    coef: uncenter(k, coef, -ux, uy),\n    predict: predict,\n    rSquared: rSquared(data, x, y, 0, predict)\n  };\n}\n\nfunction uncenter(k, a, x, y) {\n  var z = Array(k);\n  var i, j, v, c; // initialize to zero\n\n  for (i = 0; i < k; ++i) {\n    z[i] = 0;\n  } // polynomial expansion\n\n\n  for (i = k - 1; i >= 0; --i) {\n    v = a[i];\n    c = 1;\n    z[i] += v;\n\n    for (j = 1; j <= i; ++j) {\n      c *= (i + 1 - j) / j; // binomial coefficent\n\n      z[i - j] += v * Math.pow(x, j) * c;\n    }\n  } // bias term\n\n\n  z[0] += y;\n  return z;\n} // Given an array for a two-dimensional matrix and the polynomial order,\n// solve A * x = b using Gaussian elimination.\n\n\nfunction gaussianElimination(matrix) {\n  var n = matrix.length - 1,\n      coef = [];\n  var i, j, k, r, t;\n\n  for (i = 0; i < n; ++i) {\n    r = i; // max row\n\n    for (j = i + 1; j < n; ++j) {\n      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {\n        r = j;\n      }\n    }\n\n    for (k = i; k < n + 1; ++k) {\n      t = matrix[k][i];\n      matrix[k][i] = matrix[k][r];\n      matrix[k][r] = t;\n    }\n\n    for (j = i + 1; j < n; ++j) {\n      for (k = n; k >= i; k--) {\n        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];\n      }\n    }\n  }\n\n  for (j = n - 1; j >= 0; --j) {\n    t = 0;\n\n    for (k = j + 1; k < n; ++k) {\n      t += matrix[k][j] * coef[k];\n    }\n\n    coef[j] = (matrix[n][j] - t) / matrix[j][j];\n  }\n\n  return coef;\n}","map":null,"metadata":{},"sourceType":"module"}