{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { array } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { isScaleFieldDef, isTimeFormatFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression } from '../timeunit';\nimport { isText } from '../title';\nimport { QUANTITATIVE } from '../type';\nimport { getFirstDefined } from '../util';\nimport { deepEqual } from './../util';\nexport var BIN_RANGE_DELIMITER = \" \\u2013 \";\nexport function applyMarkConfig(e, model, propsList) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = propsList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n      var value = getMarkConfig(property, model.markDef, model.config);\n\n      if (value !== undefined) {\n        e[property] = {\n          value: value\n        };\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return e;\n}\nexport function getStyles(mark) {\n  var _a;\n\n  return [].concat(mark.type, (_a = mark.style, _a !== null && _a !== void 0 ? _a : []));\n}\nexport function getMarkPropOrConfig(channel, mark, config) {\n  return getFirstDefined(mark[channel], getMarkConfig(channel, mark, config));\n}\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\n\nexport function getMarkConfig(channel, mark, config) // Note: Ham: I use `any` here as it's too hard to make TS knows that MarkConfig[vgChannel] would have the same type as MarkConfig[P]\n{\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      vgChannel = _ref.vgChannel;\n\n  return getFirstDefined( // style config has highest precedence\n  vgChannel ? getStyleConfig(channel, mark, config.style) : undefined, getStyleConfig(channel, mark, config.style), // then mark-specific config\n  vgChannel ? config[mark.type][vgChannel] : undefined, config[mark.type][channel], // If there is vgChannel, skip vl channel.\n  // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n  vgChannel ? config.mark[vgChannel] : config.mark[channel]);\n}\nexport function getStyleConfig(prop, mark, styleConfigIndex) {\n  var styles = getStyles(mark);\n  var value;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = styles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var style = _step2.value;\n      var styleConfig = styleConfigIndex[style]; // MarkConfig extends VgMarkConfig so a prop may not be a valid property for style\n      // However here we also check if it is defined, so it is okay to cast here\n\n      var p = prop;\n\n      if (styleConfig && styleConfig[p] !== undefined) {\n        value = styleConfig[p];\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return value;\n}\nexport function formatSignalRef(fieldDef, specifiedFormat, expr, config) {\n  if (isTimeFormatFieldDef(fieldDef)) {\n    var isUTCScale = isScaleFieldDef(fieldDef) && fieldDef['scale'] && fieldDef['scale'].type === ScaleType.UTC;\n    return {\n      signal: timeFormatExpression(vgField(fieldDef, {\n        expr: expr\n      }), fieldDef.timeUnit, specifiedFormat, config.timeFormat, isUTCScale, true)\n    };\n  } else {\n    var format = numberFormat(fieldDef, specifiedFormat, config);\n\n    if (isBinning(fieldDef.bin)) {\n      var startField = vgField(fieldDef, {\n        expr: expr\n      });\n      var endField = vgField(fieldDef, {\n        expr: expr,\n        binSuffix: 'end'\n      });\n      return {\n        signal: binFormatExpression(startField, endField, format, config)\n      };\n    } else if (fieldDef.type === 'quantitative' || format) {\n      return {\n        signal: \"\".concat(formatExpr(vgField(fieldDef, {\n          expr: expr,\n          binSuffix: 'range'\n        }), format))\n      };\n    } else {\n      return {\n        signal: \"''+\".concat(vgField(fieldDef, {\n          expr: expr\n        }))\n      };\n    }\n  }\n}\n/**\n * Returns number format for a fieldDef\n */\n\nexport function numberFormat(fieldDef, specifiedFormat, config) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (fieldDef.type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return config.numberFormat;\n  }\n\n  return undefined;\n}\n\nfunction formatExpr(field, format) {\n  return \"format(\".concat(field, \", \\\"\").concat(format || '', \"\\\")\");\n}\n\nexport function numberFormatExpr(field, specifiedFormat, config) {\n  return formatExpr(field, specifiedFormat !== null && specifiedFormat !== void 0 ? specifiedFormat : config.numberFormat);\n}\nexport function binFormatExpression(startField, endField, format, config) {\n  return \"\".concat(fieldValidPredicate(startField, false), \" ? \\\"null\\\" : \").concat(numberFormatExpr(startField, format, config), \" + \\\"\").concat(BIN_RANGE_DELIMITER, \"\\\" + \").concat(numberFormatExpr(endField, format, config));\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\n\nexport function timeFormatExpression(field, timeUnit, format, rawTimeFormat, // should be provided only for actual text and headers, not axis/legend labels\nisUTCScale) {\n  var alwaysReturn = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    format = format !== null && format !== void 0 ? format : rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n\n    if (format || alwaysReturn) {\n      return \"\".concat(isUTCScale ? 'utc' : 'time', \"Format(\").concat(field, \", '\").concat(format, \"')\");\n    } else {\n      return undefined;\n    }\n  } else {\n    return formatExpression(timeUnit, field, isUTCScale);\n  }\n}\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\n\nexport function sortParams(orderDef, fieldRefOption) {\n  return array(orderDef).reduce(function (s, orderChannelDef) {\n    var _a;\n\n    s.field.push(vgField(orderChannelDef, fieldRefOption));\n    s.order.push((_a = orderChannelDef.sort, _a !== null && _a !== void 0 ? _a : 'ascending'));\n    return s;\n  }, {\n    field: [],\n    order: []\n  });\n}\nexport function mergeTitleFieldDefs(f1, f2) {\n  var merged = _toConsumableArray(f1);\n\n  f2.forEach(function (fdToMerge) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = merged[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var fieldDef1 = _step3.value;\n\n        // If already exists, no need to append to merged array\n        if (deepEqual(fieldDef1, fdToMerge)) {\n          return;\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\nexport function mergeTitle(title1, title2) {\n  if (deepEqual(title1, title2) || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    return [].concat(_toConsumableArray(array(title1)), _toConsumableArray(array(title2))).join(', ');\n  }\n}\nexport function mergeTitleComponent(v1, v2) {\n  var v1Val = v1.value;\n  var v2Val = v2.value;\n\n  if (v1Val == null || v2Val === null) {\n    return {\n      explicit: v1.explicit,\n      value: null\n    };\n  } else if (isText(v1Val) && isText(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1Val, v2Val)\n    };\n  } else if (!isText(v1Val) && !isText(v2Val)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1Val, v2Val)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n\n\n  throw new Error('It should never reach here');\n}","map":null,"metadata":{},"sourceType":"module"}