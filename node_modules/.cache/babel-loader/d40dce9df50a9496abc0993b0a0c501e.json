{"ast":null,"code":"import lookup from './lookup';\nimport { Transform } from 'vega-dataflow';\nimport { error, inherits, truthy } from 'vega-util';\nimport { stratify } from 'd3-hierarchy';\n/**\n * Stratify a collection of tuples into a tree structure based on\n * id and parent id fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.key - Unique key field for each tuple.\n * @param {function(object): *} params.parentKey - Field with key for parent tuple.\n */\n\nexport default function Stratify(params) {\n  Transform.call(this, null, params);\n}\nStratify.Definition = {\n  \"type\": \"Stratify\",\n  \"metadata\": {\n    \"treesource\": true\n  },\n  \"params\": [{\n    \"name\": \"key\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"parentKey\",\n    \"type\": \"field\",\n    \"required\": true\n  }]\n};\nvar prototype = inherits(Stratify, Transform);\n\nprototype.transform = function (_, pulse) {\n  if (!pulse.source) {\n    error('Stratify transform requires an upstream data source.');\n  }\n\n  var tree = this.value,\n      mod = _.modified(),\n      out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),\n      run = !this.value || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields); // prevent upstream source pollution\n\n\n  out.source = out.source.slice();\n\n  if (run) {\n    if (out.source.length) {\n      tree = lookup(stratify().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy);\n    } else {\n      tree = lookup(stratify()([{}]), _.key, _.key);\n    }\n  }\n\n  out.source.root = this.value = tree;\n  return out;\n};","map":null,"metadata":{},"sourceType":"module"}