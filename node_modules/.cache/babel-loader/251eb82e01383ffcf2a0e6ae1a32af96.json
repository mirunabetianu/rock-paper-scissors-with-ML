{"ast":null,"code":"import { hasCornerRadius, rectangle } from '../path/shapes';\nimport boundStroke from '../bound/boundStroke';\nimport { intersectRect } from '../util/intersect';\nimport { visit, pickVisit } from '../util/visit';\nimport { clipGroup } from '../util/canvas/clip';\nimport stroke from '../util/canvas/stroke';\nimport fill from '../util/canvas/fill';\nimport { hitPath } from '../util/canvas/pick';\nimport clip from '../util/svg/clip';\nimport { translateItem } from '../util/svg/transform';\n\nfunction offset(item) {\n  var sw = (sw = item.strokeWidth) != null ? sw : 1;\n  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;\n}\n\nfunction attr(emit, item) {\n  emit('transform', translateItem(item));\n}\n\nfunction emitRectangle(emit, item) {\n  var off = offset(item);\n  emit('d', rectangle(null, item, off, off));\n}\n\nfunction background(emit, item) {\n  emit('class', 'background');\n  emitRectangle(emit, item);\n}\n\nfunction foreground(emit, item) {\n  emit('class', 'foreground');\n\n  if (item.strokeForeground) {\n    emitRectangle(emit, item);\n  } else {\n    emit('d', '');\n  }\n}\n\nfunction content(emit, item, renderer) {\n  var url = item.clip ? clip(renderer, item, item) : null;\n  emit('clip-path', url);\n}\n\nfunction bound(bounds, group) {\n  if (!group.clip && group.items) {\n    var items = group.items;\n\n    for (var j = 0, m = items.length; j < m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n  }\n\n  if ((group.clip || group.width || group.height) && !group.noBound) {\n    bounds.add(0, 0).add(group.width || 0, group.height || 0);\n  }\n\n  boundStroke(bounds, group);\n  return bounds.translate(group.x || 0, group.y || 0);\n}\n\nfunction rectanglePath(context, group, x, y) {\n  var off = offset(group);\n  context.beginPath();\n  rectangle(context, group, (x || 0) + off, (y || 0) + off);\n}\n\nvar hitBackground = hitPath(rectanglePath);\nvar hitForeground = hitPath(rectanglePath, false);\n\nfunction draw(context, scene, bounds) {\n  var renderer = this;\n  visit(scene, function (group) {\n    var gx = group.x || 0,\n        gy = group.y || 0,\n        fore = group.strokeForeground,\n        opacity = group.opacity == null ? 1 : group.opacity; // draw group background\n\n    if ((group.stroke || group.fill) && opacity) {\n      rectanglePath(context, group, gx, gy);\n\n      if (group.fill && fill(context, group, opacity)) {\n        context.fill();\n      }\n\n      if (group.stroke && !fore && stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    } // setup graphics context, set clip and bounds\n\n\n    context.save();\n    context.translate(gx, gy);\n    if (group.clip) clipGroup(context, group);\n    if (bounds) bounds.translate(-gx, -gy); // draw group contents\n\n    visit(group, function (item) {\n      renderer.draw(context, item, bounds);\n    }); // restore graphics context\n\n    if (bounds) bounds.translate(gx, gy);\n    context.restore(); // draw group foreground\n\n    if (fore && group.stroke && opacity) {\n      rectanglePath(context, group, gx, gy);\n\n      if (stroke(context, group, opacity)) {\n        context.stroke();\n      }\n    }\n  });\n}\n\nfunction pick(context, scene, x, y, gx, gy) {\n  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\n    return null;\n  }\n\n  var handler = this,\n      cx = x * context.pixelRatio,\n      cy = y * context.pixelRatio;\n  return pickVisit(scene, function (group) {\n    var hit, fore, ix, dx, dy, dw, dh, b, c; // first hit test bounding box\n\n    b = group.bounds;\n    if (b && !b.contains(gx, gy)) return; // passed bounds check, test rectangular clip\n\n    dx = group.x || 0;\n    dy = group.y || 0;\n    dw = dx + (group.width || 0);\n    dh = dy + (group.height || 0);\n    c = group.clip;\n    if (c && (gx < dx || gx > dw || gy < dx || gy > dh)) return; // adjust coordinate system\n\n    context.save();\n    context.translate(dx, dy);\n    dx = gx - dx;\n    dy = gy - dy; // test background for rounded corner clip\n\n    if (c && hasCornerRadius(group) && !hitBackground(context, group, cx, cy)) {\n      context.restore();\n      return null;\n    }\n\n    fore = group.strokeForeground;\n    ix = scene.interactive !== false; // hit test against group foreground\n\n    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {\n      context.restore();\n      return group;\n    } // hit test against contained marks\n\n\n    hit = pickVisit(group, function (mark) {\n      return pickMark(mark, dx, dy) ? handler.pick(mark, x, y, dx, dy) : null;\n    }); // hit test against group background\n\n    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {\n      hit = group;\n    } // restore state and return\n\n\n    context.restore();\n    return hit || null;\n  });\n}\n\nfunction pickMark(mark, x, y) {\n  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);\n}\n\nexport default {\n  type: 'group',\n  tag: 'g',\n  nested: false,\n  attr: attr,\n  bound: bound,\n  draw: draw,\n  pick: pick,\n  isect: intersectRect,\n  content: content,\n  background: background,\n  foreground: foreground\n};","map":null,"metadata":{},"sourceType":"module"}