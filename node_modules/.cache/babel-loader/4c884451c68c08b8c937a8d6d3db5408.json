{"ast":null,"code":"import _regeneratorRuntime from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { extend, error, isFunction, stringValue } from 'vega-util'; // Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\n\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//; // Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://\n\nvar allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i; // eslint-disable-line no-useless-escape\n\nvar whitespace_re = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g; // eslint-disable-line no-control-regex\n// Special treatment in node.js for the file: protocol\n\nvar fileProtocol = 'file://';\n/**\n * Factory for a loader constructor that provides methods for requesting\n * files from either the network or disk, and for sanitizing request URIs.\n * @param {function} fetch - The Fetch API for HTTP network requests.\n *   If null or undefined, HTTP loading will be disabled.\n * @param {object} fs - The file system interface for file loading.\n *   If null or undefined, local file loading will be disabled.\n * @return {function} A loader constructor with the following signature:\n *   param {object} [options] - Optional default loading options to use.\n *   return {object} - A new loader instance.\n */\n\nexport default function (fetch, fs) {\n  return function (options) {\n    return {\n      options: options || {},\n      sanitize: sanitize,\n      load: load,\n      fileAccess: !!fs,\n      file: fileLoader(fs),\n      http: httpLoader(fetch)\n    };\n  };\n}\n/**\n * Load an external resource, typically either from the web or from the local\n * filesystem. This function uses {@link sanitize} to first sanitize the uri,\n * then calls either {@link http} (for web requests) or {@link file} (for\n * filesystem loading).\n * @param {string} uri - The resource indicator (e.g., URL or filename).\n * @param {object} [options] - Optional loading options. These options will\n *   override any existing default options.\n * @return {Promise} - A promise that resolves to the loaded content.\n */\n\nfunction load(_x, _x2) {\n  return _load.apply(this, arguments);\n}\n/**\n * URI sanitizer function.\n * @param {string} uri - The uri (url or filename) to sanity check.\n * @param {object} options - An options hash.\n * @return {Promise} - A promise that resolves to an object containing\n *  sanitized uri data, or rejects it the input uri is deemed invalid.\n *  The properties of the resolved object are assumed to be\n *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\n *  provided by the 'href' property of the returned object.\n */\n\n\nfunction _load() {\n  _load = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(uri, options) {\n    var opt, url;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return this.sanitize(uri, options);\n\n          case 2:\n            opt = _context2.sent;\n            url = opt.href;\n            return _context2.abrupt(\"return\", opt.localFile ? this.file(url) : this.http(url, options));\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n  return _load.apply(this, arguments);\n}\n\nfunction sanitize(_x3, _x4) {\n  return _sanitize.apply(this, arguments);\n}\n/**\n * File system loader factory.\n * @param {object} fs - The file system interface.\n * @return {function} - A file loader with the following signature:\n *   param {string} filename - The file system path to load.\n *   param {string} filename - The file system path to load.\n *   return {Promise} A promise that resolves to the file contents.\n */\n\n\nfunction _sanitize() {\n  _sanitize = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(uri, options) {\n    var fileAccess, result, isFile, loadFile, base, isAllowed, hasProtocol;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            options = extend({}, this.options, options);\n            fileAccess = this.fileAccess, result = {\n              href: null\n            };\n            isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));\n\n            if (uri == null || typeof uri !== 'string' || !isAllowed) {\n              error('Sanitize failure, invalid URI: ' + stringValue(uri));\n            }\n\n            hasProtocol = protocol_re.test(uri); // if relative url (no protocol/host), prepend baseURL\n\n            if ((base = options.baseURL) && !hasProtocol) {\n              // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n              if (!uri.startsWith('/') && base[base.length - 1] !== '/') {\n                uri = '/' + uri;\n              }\n\n              uri = base + uri;\n            } // should we load from file system?\n\n\n            loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;\n\n            if (isFile) {\n              // strip file protocol\n              uri = uri.slice(fileProtocol.length);\n            } else if (uri.startsWith('//')) {\n              if (options.defaultProtocol === 'file') {\n                // if is file, strip protocol and set loadFile flag\n                uri = uri.slice(2);\n                loadFile = true;\n              } else {\n                // if relative protocol (starts with '//'), prepend default protocol\n                uri = (options.defaultProtocol || 'http') + ':' + uri;\n              }\n            } // set non-enumerable mode flag to indicate local file load\n\n\n            Object.defineProperty(result, 'localFile', {\n              value: !!loadFile\n            }); // set uri\n\n            result.href = uri; // set default result target, if specified\n\n            if (options.target) {\n              result.target = options.target + '';\n            } // set default result rel, if specified (#1542)\n\n\n            if (options.rel) {\n              result.rel = options.rel + '';\n            } // return\n\n\n            return _context3.abrupt(\"return\", result);\n\n          case 13:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this);\n  }));\n  return _sanitize.apply(this, arguments);\n}\n\nfunction fileLoader(fs) {\n  return fs ? function (filename) {\n    return new Promise(function (accept, reject) {\n      fs.readFile(filename, function (error, data) {\n        if (error) reject(error);else accept(data);\n      });\n    });\n  } : fileReject;\n}\n/**\n * Default file system loader that simply rejects.\n */\n\n\nfunction fileReject() {\n  return _fileReject.apply(this, arguments);\n}\n/**\n * HTTP request handler factory.\n * @param {function} fetch - The Fetch API method.\n * @return {function} - An http loader with the following signature:\n *   param {string} url - The url to request.\n *   param {object} options - An options hash.\n *   return {Promise} - A promise that resolves to the file contents.\n */\n\n\nfunction _fileReject() {\n  _fileReject = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4() {\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            error('No file system access.');\n\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _fileReject.apply(this, arguments);\n}\n\nfunction httpLoader(fetch) {\n  return fetch ?\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(url, options) {\n      var opt, type, response;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              opt = extend({}, this.options.http, options);\n              type = options && options.response;\n              _context.next = 4;\n              return fetch(url, opt);\n\n            case 4:\n              response = _context.sent;\n              return _context.abrupt(\"return\", !response.ok ? error(response.status + '' + response.statusText) : isFunction(response[type]) ? response[type]() : response.text());\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function (_x5, _x6) {\n      return _ref.apply(this, arguments);\n    };\n  }() : httpReject;\n}\n/**\n * Default http request handler that simply rejects.\n */\n\n\nfunction httpReject() {\n  return _httpReject.apply(this, arguments);\n}\n\nfunction _httpReject() {\n  _httpReject = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5() {\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            error('No HTTP fetch method available.');\n\n          case 1:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _httpReject.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}