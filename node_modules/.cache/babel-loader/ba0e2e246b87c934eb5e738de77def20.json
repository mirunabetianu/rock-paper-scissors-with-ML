{"ast":null,"code":"import { isArray, isNumber } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLOR, FILL, FILLOPACITY, OPACITY, SCALE_CHANNELS, SHAPE, SIZE, STROKE, STROKEOPACITY, STROKEWIDTH, X, Y } from '../../channel';\nimport { getViewConfigDiscreteSize, getViewConfigDiscreteStep } from '../../config';\nimport * as log from '../../log';\nimport { channelScalePropertyIncompatability, hasContinuousDomain, hasDiscreteDomain, isContinuousToDiscrete, isExtendedScheme, scaleTypeSupportProperty } from '../../scale';\nimport { isStep } from '../../spec/base';\nimport * as util from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { getBinSignalName } from '../data/bin';\nimport { SignalRefWrapper } from '../signal';\nimport { makeExplicit, makeImplicit } from '../split';\nexport var RANGE_PROPERTIES = ['range', 'scheme'];\n\nfunction getSizeType(channel) {\n  return channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n}\n\nexport function parseUnitScaleRange(model) {\n  var localScaleComponents = model.component.scales; // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n\n  SCALE_CHANNELS.forEach(function (channel) {\n    var localScaleCmpt = localScaleComponents[channel];\n\n    if (!localScaleCmpt) {\n      return;\n    }\n\n    var rangeWithExplicit = parseRangeForChannel(channel, model);\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  });\n}\n\nfunction getBinStepSignal(model, channel) {\n  var fieldDef = model.fieldDef(channel);\n\n  if (fieldDef && fieldDef.bin && isBinning(fieldDef.bin)) {\n    var binSignal = getBinSignalName(model, fieldDef.field, fieldDef.bin); // TODO: extract this to be range step signal\n\n    var sizeType = getSizeType(channel);\n    var sizeSignal = model.getName(sizeType);\n    return new SignalRefWrapper(function () {\n      var updatedName = model.getSignalName(binSignal);\n      var binCount = \"(\".concat(updatedName, \".stop - \").concat(updatedName, \".start) / \").concat(updatedName, \".step\");\n      return \"\".concat(model.getSignalName(sizeSignal), \" / (\").concat(binCount, \")\");\n    });\n  }\n\n  return undefined;\n}\n/**\n * Return mixins that includes one of the Vega range types (explicit range, range.step, range.scheme).\n */\n\n\nexport function parseRangeForChannel(channel, model) {\n  var specifiedScale = model.specifiedScales[channel];\n  var size = model.size;\n  var mergedScaleCmpt = model.getScaleComponent(channel);\n  var scaleType = mergedScaleCmpt.get('type'); // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = RANGE_PROPERTIES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      if (specifiedScale[property] !== undefined) {\n        var supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n        var channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n        if (!supportedByScaleType) {\n          log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n        } else if (channelIncompatability) {\n          // channel\n          log.warn(channelIncompatability);\n        } else {\n          switch (property) {\n            case 'range':\n              return makeExplicit(specifiedScale[property]);\n\n            case 'scheme':\n              return makeExplicit(parseScheme(specifiedScale[property]));\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (channel === X || channel === Y) {\n    var sizeChannel = channel === X ? 'width' : 'height';\n    var sizeValue = size[sizeChannel];\n\n    if (isStep(sizeValue)) {\n      if (hasDiscreteDomain(scaleType)) {\n        return makeExplicit({\n          step: sizeValue.step\n        });\n      } else {\n        log.warn(log.message.stepDropped(sizeChannel));\n      }\n    }\n  }\n\n  return makeImplicit(defaultRange(channel, model));\n}\n\nfunction parseScheme(scheme) {\n  if (isExtendedScheme(scheme)) {\n    return Object.assign({\n      scheme: scheme.name\n    }, util.omit(scheme, ['name']));\n  }\n\n  return {\n    scheme: scheme\n  };\n}\n\nfunction defaultRange(channel, model) {\n  var size = model.size,\n      config = model.config,\n      mark = model.mark;\n  var getSignalName = model.getSignalName.bind(model);\n\n  var _model$fieldDef = model.fieldDef(channel),\n      type = _model$fieldDef.type;\n\n  var mergedScaleCmpt = model.getScaleComponent(channel);\n  var scaleType = mergedScaleCmpt.get('type');\n  var domain = model.specifiedScales[channel].domain;\n\n  switch (channel) {\n    case X:\n    case Y:\n      {\n        // If there is no explicit width/height for discrete x/y scales\n        if (util.contains(['point', 'band'], scaleType)) {\n          if (channel === X && !size.width) {\n            var w = getViewConfigDiscreteSize(config.view, 'width');\n\n            if (isStep(w)) {\n              return w;\n            }\n          } else if (channel === Y && !size.height) {\n            var h = getViewConfigDiscreteSize(config.view, 'height');\n\n            if (isStep(h)) {\n              return h;\n            }\n          }\n        } // If step is null, use zero to width or height.\n        // Note that these range signals are temporary\n        // as they can be merged and renamed.\n        // (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)\n        // We will later replace these temporary names with\n        // the final name in assembleScaleRange()\n\n\n        var sizeType = getSizeType(channel);\n        var sizeSignal = model.getName(sizeType);\n\n        if (channel === Y && hasContinuousDomain(scaleType)) {\n          // For y continuous scale, we have to start from the height as the bottom part has the max value.\n          return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n        } else {\n          return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n        }\n      }\n\n    case SIZE:\n      {\n        // TODO: support custom rangeMin, rangeMax\n        var zero = model.component.scales[channel].get('zero');\n        var rangeMin = sizeRangeMin(mark, zero, config);\n        var rangeMax = sizeRangeMax(mark, size, model, config);\n\n        if (isContinuousToDiscrete(scaleType)) {\n          return interpolateRange(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType, config, domain, channel));\n        } else {\n          return [rangeMin, rangeMax];\n        }\n      }\n\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n\n    case SHAPE:\n      return 'symbol';\n\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n      }\n\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n  /* istanbul ignore next: should never reach here */\n\n\n  throw new Error(\"Scale range undefined for channel \".concat(channel));\n}\n\nexport function defaultContinuousToDiscreteCount(scaleType, config, domain, channel) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n\n    case 'quantize':\n      return config.scale.quantizeCount;\n\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel)); // default threshold boundaries for threshold scale since domain has cardinality of 2\n\n        return 3;\n      }\n\n  }\n}\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\n\nexport function interpolateRange(rangeMin, rangeMax, cardinality) {\n  // always return a signal since it's better to compute the sequence in Vega later\n  var f = function f() {\n    var rMax = isSignalRef(rangeMax) ? rangeMax.signal : rangeMax;\n    var step = \"(\".concat(rMax, \" - \").concat(rangeMin, \") / (\").concat(cardinality, \" - 1)\");\n    return \"sequence(\".concat(rangeMin, \", \").concat(rangeMax, \" + \").concat(step, \", \").concat(step, \")\");\n  };\n\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {\n      signal: f()\n    };\n  }\n}\n\nfunction sizeRangeMin(mark, zero, config) {\n  if (zero) {\n    return 0;\n  }\n\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n\n    case 'text':\n      return config.scale.minFontSize;\n\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n\n\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nexport var MAX_SIZE_RANGE_STEP_RATIO = 0.95;\n\nfunction sizeRangeMax(mark, size, model, config) {\n  var xyStepSignals = {\n    x: getBinStepSignal(model, 'x'),\n    y: getBinStepSignal(model, 'y')\n  };\n\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      {\n        if (config.scale.maxBandSize !== undefined) {\n          return config.scale.maxBandSize;\n        }\n\n        var min = minXYStep(size, xyStepSignals, config.view);\n\n        if (isNumber(min)) {\n          return min - 1;\n        } else {\n          return new SignalRefWrapper(function () {\n            return \"\".concat(min.signal, \" - 1\");\n          });\n        }\n      }\n\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n\n    case 'text':\n      return config.scale.maxFontSize;\n\n    case 'point':\n    case 'square':\n    case 'circle':\n      {\n        if (config.scale.maxSize) {\n          return config.scale.maxSize;\n        }\n\n        var pointStep = minXYStep(size, xyStepSignals, config.view);\n\n        if (isNumber(pointStep)) {\n          return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n        } else {\n          return new SignalRefWrapper(function () {\n            return \"pow(\".concat(MAX_SIZE_RANGE_STEP_RATIO, \" * \").concat(pointStep.signal, \", 2)\");\n          });\n        }\n      }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n\n\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\n\n\nfunction minXYStep(size, xyStepSignals, viewConfig) {\n  var widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, 'width');\n  var heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, 'height');\n\n  if (xyStepSignals.x || xyStepSignals.y) {\n    return new SignalRefWrapper(function () {\n      var exprs = [xyStepSignals.x ? xyStepSignals.x.signal : widthStep, xyStepSignals.y ? xyStepSignals.y.signal : heightStep];\n      return \"min(\".concat(exprs.join(', '), \")\");\n    });\n  }\n\n  return Math.min(widthStep, heightStep);\n}","map":null,"metadata":{},"sourceType":"module"}