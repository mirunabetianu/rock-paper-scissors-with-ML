{"ast":null,"code":"export function isLogicalOr(op) {\n  return !!op.or;\n}\nexport function isLogicalAnd(op) {\n  return !!op.and;\n}\nexport function isLogicalNot(op) {\n  return !!op.not;\n}\nexport function forEachLeaf(op, fn) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = op.and[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var subop = _step.value;\n        forEachLeaf(subop, fn);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } else if (isLogicalOr(op)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = op.or[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _subop = _step2.value;\n        forEachLeaf(_subop, fn);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  } else {\n    fn(op);\n  }\n}\nexport function normalizeLogicalOperand(op, normalizer) {\n  if (isLogicalNot(op)) {\n    return {\n      not: normalizeLogicalOperand(op.not, normalizer)\n    };\n  } else if (isLogicalAnd(op)) {\n    return {\n      and: op.and.map(function (o) {\n        return normalizeLogicalOperand(o, normalizer);\n      })\n    };\n  } else if (isLogicalOr(op)) {\n    return {\n      or: op.or.map(function (o) {\n        return normalizeLogicalOperand(o, normalizer);\n      })\n    };\n  } else {\n    return normalizer(op);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}