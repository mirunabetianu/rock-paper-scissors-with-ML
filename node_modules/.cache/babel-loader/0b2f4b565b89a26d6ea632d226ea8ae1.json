{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar _regeneratorRuntime = require(\"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nvar dom_1 = require(\"../util/dom\");\n\nvar render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a confusion matrix.\n *\n * Can optionally exclude the diagonal from being shaded if one wants the visual\n * focus to be on the incorrect classifications. Note that if the classification\n * is perfect (i.e. only the diagonal has values) then the diagonal will always\n * be shaded.\n *\n * ```js\n * const rows = 5;\n * const cols = 5;\n * const values = [];\n * for (let i = 0; i < rows; i++) {\n *   const row = []\n *   for (let j = 0; j < cols; j++) {\n *     row.push(Math.round(Math.random() * 50));\n *   }\n *   values.push(row);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Confusion Matrix', tab: 'Charts' };\n * tfvis.render.confusionMatrix(surface, data);\n * ```\n *\n * ```js\n * // The diagonal can be excluded from shading.\n *\n * const data = {\n *   values: [[4, 2, 8], [1, 7, 2], [3, 3, 20]],\n * }\n *\n * // Render to visor\n * const surface = {\n *  name: 'Confusion Matrix with Excluded Diagonal', tab: 'Charts'\n * };\n *\n * tfvis.render.confusionMatrix(surface, data, {\n *   shadeDiagonal: false\n * });\n * ```\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\n\nfunction confusionMatrix(container, data) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return __awaiter(this, void 0, void 0,\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var options, drawArea, values, inputArray, tickLabels, generateLabels, nonDiagonalIsAllZeroes, i, label, j, prediction, count, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, val, embedOpts, spec;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = Object.assign({}, defaultOpts, opts);\n            drawArea = render_utils_1.getDrawArea(container); // Format data for vega spec; an array of objects, one for for each cell\n            // in the matrix.\n\n            values = [];\n            inputArray = data.values;\n            tickLabels = data.tickLabels || [];\n            generateLabels = tickLabels.length === 0;\n            nonDiagonalIsAllZeroes = true;\n\n            for (i = 0; i < inputArray.length; i++) {\n              label = generateLabels ? \"Class \".concat(i) : tickLabels[i];\n\n              if (generateLabels) {\n                tickLabels.push(label);\n              }\n\n              for (j = 0; j < inputArray[i].length; j++) {\n                prediction = generateLabels ? \"Class \".concat(j) : tickLabels[j];\n                count = inputArray[i][j];\n\n                if (i === j && !options.shadeDiagonal) {\n                  values.push({\n                    label: label,\n                    prediction: prediction,\n                    count: count,\n                    noFill: true\n                  });\n                } else {\n                  values.push({\n                    label: label,\n                    prediction: prediction,\n                    count: count,\n                    scaleCount: count\n                  }); // When not shading the diagonal we want to check if there is a non\n                  // zero value. If all values are zero we will not color them as the\n                  // scale will be invalid.\n\n                  if (count !== 0) {\n                    nonDiagonalIsAllZeroes = false;\n                  }\n                }\n              }\n            }\n\n            if (!(!options.shadeDiagonal && nonDiagonalIsAllZeroes)) {\n              _context.next = 28;\n              break;\n            }\n\n            // User has specified requested not to shade the diagonal but all the other\n            // values are zero. We have two choices, don't shade the anything or only\n            // shade the diagonal. We choose to shade the diagonal as that is likely\n            // more helpful even if it is not what the user specified.\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _iteratorError = undefined;\n            _context.prev = 12;\n\n            for (_iterator = values[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              val = _step.value;\n\n              if (val.noFill === true) {\n                val.noFill = false;\n                val.scaleCount = val.count;\n              }\n            }\n\n            _context.next = 20;\n            break;\n\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](12);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 20:\n            _context.prev = 20;\n            _context.prev = 21;\n\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n\n          case 23:\n            _context.prev = 23;\n\n            if (!_didIteratorError) {\n              _context.next = 26;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 26:\n            return _context.finish(23);\n\n          case 27:\n            return _context.finish(20);\n\n          case 28:\n            embedOpts = {\n              actions: false,\n              mode: 'vega-lite',\n              defaultStyle: false\n            };\n            spec = {\n              'width': options.width || dom_1.getDefaultWidth(drawArea),\n              'height': options.height || dom_1.getDefaultHeight(drawArea),\n              'padding': 0,\n              'autosize': {\n                'type': 'fit',\n                'contains': 'padding',\n                'resize': true\n              },\n              'config': {\n                'axis': {\n                  'labelFontSize': options.fontSize,\n                  'titleFontSize': options.fontSize\n                },\n                'text': {\n                  'fontSize': options.fontSize\n                },\n                'legend': {\n                  'labelFontSize': options.fontSize,\n                  'titleFontSize': options.fontSize\n                }\n              },\n              'data': {\n                'values': values\n              },\n              'encoding': {\n                'x': {\n                  'field': 'prediction',\n                  'type': 'ordinal',\n                  // Maintain sort order of the axis if labels is passed in\n                  'scale': {\n                    'domain': tickLabels\n                  }\n                },\n                'y': {\n                  'field': 'label',\n                  'type': 'ordinal',\n                  // Maintain sort order of the axis if labels is passed in\n                  'scale': {\n                    'domain': tickLabels\n                  }\n                }\n              },\n              'layer': [{\n                // The matrix\n                'transform': [{\n                  'filter': 'datum.noFill != true'\n                }],\n                'mark': {\n                  'type': 'rect'\n                },\n                'encoding': {\n                  'color': {\n                    'field': 'scaleCount',\n                    'type': 'quantitative',\n                    'scale': {\n                      'range': ['#f7fbff', '#4292c6']\n                    }\n                  },\n                  'tooltip': [{\n                    'field': 'label',\n                    'type': 'nominal'\n                  }, {\n                    'field': 'prediction',\n                    'type': 'nominal'\n                  }, {\n                    'field': 'count',\n                    'type': 'quantitative'\n                  }]\n                }\n              }]\n            };\n\n            if (options.shadeDiagonal === false) {\n              spec.layer.push({\n                // render unfilled rects for the diagonal\n                'transform': [{\n                  'filter': 'datum.noFill == true'\n                }],\n                'mark': {\n                  'type': 'rect',\n                  'fill': 'white'\n                },\n                'encoding': {\n                  'tooltip': [{\n                    'field': 'label',\n                    'type': 'nominal'\n                  }, {\n                    'field': 'prediction',\n                    'type': 'nominal'\n                  }, {\n                    'field': 'count',\n                    'type': 'quantitative'\n                  }]\n                }\n              });\n            }\n\n            if (options.showTextOverlay) {\n              spec.layer.push({\n                // The text labels\n                'mark': {\n                  'type': 'text',\n                  'baseline': 'middle'\n                },\n                'encoding': {\n                  'text': {\n                    'field': 'count',\n                    'type': 'nominal'\n                  }\n                }\n              });\n            }\n\n            _context.next = 34;\n            return vega_embed_1.default(drawArea, spec, embedOpts);\n\n          case 34:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[12, 16, 20, 28], [21,, 23, 27]]);\n  }));\n}\n\nexports.confusionMatrix = confusionMatrix;\nvar defaultOpts = {\n  xLabel: null,\n  yLabel: null,\n  xType: 'nominal',\n  yType: 'nominal',\n  shadeDiagonal: true,\n  fontSize: 12,\n  showTextOverlay: true,\n  height: 400\n};","map":null,"metadata":{},"sourceType":"script"}