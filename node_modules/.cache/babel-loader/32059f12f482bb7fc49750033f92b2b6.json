{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { keys, replaceAll, stringify, vals } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { mergeLegendComponent } from './parse';\n\nfunction setLegendEncode(legend, part, vgProp, vgRef) {\n  var _a, _b, _c;\n\n  legend.encode = (_a = legend.encode, _a !== null && _a !== void 0 ? _a : {});\n  legend.encode[part] = (_b = legend.encode[part], _b !== null && _b !== void 0 ? _b : {});\n  legend.encode[part].update = (_c = legend.encode[part].update, _c !== null && _c !== void 0 ? _c : {}); // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n\n  legend.encode[part].update[vgProp] = vgRef;\n}\n\nexport function assembleLegends(model) {\n  var legendComponentIndex = model.component.legends;\n  var legendByDomain = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = keys(legendComponentIndex)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var channel = _step.value;\n      var scaleComponent = model.getScaleComponent(channel);\n      var domainHash = stringify(scaleComponent.get('domains'));\n\n      if (legendByDomain[domainHash]) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = legendByDomain[domainHash][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var mergedLegendComponent = _step2.value;\n            var merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n\n            if (!merged) {\n              // If cannot merge, need to add this legend separately\n              legendByDomain[domainHash].push(legendComponentIndex[channel]);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } else {\n        legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return vals(legendByDomain).flat().map(function (legendCmpt) {\n    var _a, _b, _c, _d;\n\n    var _e = legendCmpt.combine(),\n        labelExpr = _e.labelExpr,\n        selections = _e.selections,\n        legend = __rest(_e, [\"labelExpr\", \"selections\"]);\n\n    if ((_a = legend.encode) === null || _a === void 0 ? void 0 : _a.symbols) {\n      var out = legend.encode.symbols.update;\n\n      if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke && !legend.stroke) {\n        // For non color channel's legend, we need to override symbol stroke config from Vega config if stroke channel is not used.\n        out.stroke = {\n          value: 'transparent'\n        };\n      }\n\n      if (legend.fill) {\n        // If top-level fill is defined, for non color channel's legend, we need remove fill.\n        delete out.fill;\n      }\n    }\n\n    if (labelExpr !== undefined) {\n      var expr = labelExpr;\n\n      if (((_d = (_c = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.update) === null || _d === void 0 ? void 0 : _d.text) && isSignalRef(legend.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', legend.encode.labels.update.text.signal);\n      }\n\n      setLegendEncode(legend, 'labels', 'text', {\n        signal: expr\n      });\n    }\n\n    return legend;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}