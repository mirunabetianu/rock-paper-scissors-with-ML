{"ast":null,"code":"import { Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\n/**\n * Invokes a function for each data tuple and saves the results as a new field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.expr - The formula function to invoke for each tuple.\n * @param {string} params.as - The field name under which to save the result.\n * @param {boolean} [params.initonly=false] - If true, the formula is applied to\n *   added tuples only, and does not update in response to modifications.\n */\n\nexport default function Formula(params) {\n  Transform.call(this, null, params);\n}\nFormula.Definition = {\n  \"type\": \"Formula\",\n  \"metadata\": {\n    \"modifies\": true\n  },\n  \"params\": [{\n    \"name\": \"expr\",\n    \"type\": \"expr\",\n    \"required\": true\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"required\": true\n  }, {\n    \"name\": \"initonly\",\n    \"type\": \"boolean\"\n  }]\n};\nvar prototype = inherits(Formula, Transform);\n\nprototype.transform = function (_, pulse) {\n  var func = _.expr,\n      as = _.as,\n      mod = _.modified(),\n      flag = _.initonly ? pulse.ADD : mod ? pulse.SOURCE : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD : pulse.ADD;\n\n  if (mod) {\n    // parameters updated, need to reflow\n    pulse = pulse.materialize().reflow(true);\n  }\n\n  if (!_.initonly) {\n    pulse.modifies(as);\n  }\n\n  return pulse.visit(flag, function (t) {\n    return t[as] = func(t, _);\n  });\n};","map":null,"metadata":{},"sourceType":"module"}