{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { keys } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { isConcatModel, isLayerModel, isRepeatModel } from '../model';\nimport { assembleSelectionScaleDomain } from '../selection/assemble';\nimport { assembleDomain } from './domain';\nexport function assembleScales(model) {\n  if (isLayerModel(model) || isConcatModel(model) || isRepeatModel(model)) {\n    // For concat / layer / repeat, include scales of children too\n    return model.children.reduce(function (scales, child) {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\nexport function assembleScalesForModel(model) {\n  return keys(model.component.scales).reduce(function (scales, channel) {\n    var scaleComponent = model.component.scales[channel];\n\n    if (scaleComponent.merged) {\n      // Skipped merged scales\n      return scales;\n    }\n\n    var scale = scaleComponent.combine();\n\n    var name = scale.name,\n        type = scale.type,\n        selectionExtent = scale.selectionExtent,\n        _d = scale.domains,\n        _r = scale.range,\n        otherScaleProps = __rest(scale, [\"name\", \"type\", \"selectionExtent\", \"domains\", \"range\"]);\n\n    var range = assembleScaleRange(scale.range, name, channel);\n    var domainRaw;\n\n    if (selectionExtent) {\n      domainRaw = assembleSelectionScaleDomain(model, selectionExtent);\n    }\n\n    var domain = assembleDomain(model, channel);\n    scales.push(Object.assign(Object.assign(Object.assign(Object.assign({\n      name: name,\n      type: type\n    }, domain ? {\n      domain: domain\n    } : {}), domainRaw ? {\n      domainRaw: domainRaw\n    } : {}), {\n      range: range\n    }), otherScaleProps));\n    return scales;\n  }, []);\n}\nexport function assembleScaleRange(scaleRange, scaleName, channel) {\n  // add signals to x/y range\n  if (channel === 'x' || channel === 'y') {\n    if (isVgRangeStep(scaleRange)) {\n      // For width/height step, use a signal created in layout assemble instead of a constant step.\n      return {\n        step: {\n          signal: scaleName + '_step'\n        }\n      };\n    }\n  }\n\n  return scaleRange;\n}","map":null,"metadata":{},"sourceType":"module"}