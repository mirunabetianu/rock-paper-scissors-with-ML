{"ast":null,"code":"import { Transform } from 'vega-dataflow';\nimport { timeBin, timeUnits, timeFloor, utcFloor, timeInterval, utcInterval } from 'vega-time';\nimport { accessorFields, extent, inherits, peek } from 'vega-util';\n/**\n * Discretize dates to specific time units.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The data field containing date/time values.\n */\n\nexport default function TimeUnit(params) {\n  Transform.call(this, null, params);\n}\nvar OUTPUT = ['unit0', 'unit1'];\nTimeUnit.Definition = {\n  \"type\": \"TimeUnit\",\n  \"metadata\": {\n    \"modifies\": true\n  },\n  \"params\": [{\n    \"name\": \"field\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"interval\",\n    \"type\": \"boolean\",\n    \"default\": true\n  }, {\n    \"name\": \"units\",\n    \"type\": \"string\",\n    \"array\": true\n  }, {\n    \"name\": \"step\",\n    \"type\": \"number\",\n    \"default\": 1\n  }, {\n    \"name\": \"timezone\",\n    \"type\": \"enum\",\n    \"default\": \"local\",\n    \"values\": [\"local\", \"utc\"]\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"array\": true,\n    \"length\": 2,\n    \"default\": OUTPUT\n  }]\n};\nvar prototype = inherits(TimeUnit, Transform);\n\nprototype.transform = function (_, pulse) {\n  var field = _.field,\n      band = _.interval !== false,\n      utc = _.timezone === 'utc',\n      floor = this._floor(_, pulse),\n      offset = (utc ? utcInterval : timeInterval)(floor.unit).offset,\n      as = _.as || OUTPUT,\n      u0 = as[0],\n      u1 = as[1],\n      min = floor.start || Infinity,\n      max = floor.stop || -Infinity,\n      step = floor.step,\n      flag = pulse.ADD;\n\n  if (_.modified() || pulse.modified(accessorFields(_.field))) {\n    pulse = pulse.reflow(true);\n    flag = pulse.SOURCE;\n    min = Infinity;\n    max = -Infinity;\n  }\n\n  pulse.visit(flag, function (t) {\n    var v = field(t),\n        a,\n        b;\n\n    if (v == null) {\n      t[u0] = null;\n      if (band) t[u1] = null;\n    } else {\n      t[u0] = a = b = floor(v);\n      if (band) t[u1] = b = offset(a, step);\n      if (a < min) min = a;\n      if (b > max) max = b;\n    }\n  });\n  floor.start = min;\n  floor.stop = max;\n  return pulse.modifies(band ? as : u0);\n};\n\nprototype._floor = function (_, pulse) {\n  var utc = _.timezone === 'utc'; // get parameters\n\n  var _ref = _.units ? {\n    units: _.units,\n    step: _.step || 1\n  } : timeBin({\n    extent: extent(pulse.materialize(pulse.SOURCE).source, _.field),\n    maxbins: _.maxbins\n  }),\n      units = _ref.units,\n      step = _ref.step; // check / standardize time units\n\n\n  units = timeUnits(units);\n  var prev = this.value || {},\n      floor = (utc ? utcFloor : timeFloor)(units, step);\n  floor.unit = peek(units);\n  floor.units = units;\n  floor.step = step;\n  floor.start = prev.start;\n  floor.stop = prev.stop;\n  return this.value = floor;\n};","map":null,"metadata":{},"sourceType":"module"}