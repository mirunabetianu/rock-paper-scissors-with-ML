{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { Union, VlMulti, Or, And } from './constants';\nimport { array, toNumber } from 'vega-util';\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @returns {object} An object of selected fields and values.\n */\n\nexport function selectionResolve(name, op, isMulti) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      resolved = {},\n      multiRes = {},\n      types = {},\n      entry,\n      fields,\n      values,\n      unit,\n      field,\n      res,\n      resUnit,\n      type,\n      union,\n      n = entries.length,\n      i = 0,\n      j,\n      m; // First union all entries within the same unit.\n\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    for (j = 0, m = fields.length; j < m; ++j) {\n      field = fields[j];\n      res = resolved[field.field] || (resolved[field.field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      types[field.field] = type = field.type.charAt(0);\n      union = ops[type + '_union'];\n      res[unit] = union(resUnit, array(values[j]));\n    } // If the same multi-selection is repeated over views and projected over\n    // an encoding, it may operate over different fields making it especially\n    // tricky to reliably resolve it. At best, we can de-dupe identical entries\n    // but doing so may be more computationally expensive than it is worth.\n    // Instead, for now, we simply transform our store representation into\n    // a more human-friendly one.\n\n\n    if (isMulti) {\n      resUnit = multiRes[unit] || (multiRes[unit] = []);\n      resUnit.push(array(values).reduce(function (obj, curr, j) {\n        return obj[fields[j].field] = curr, obj;\n      }, {}));\n    }\n  } // Then resolve fields across units as per the op.\n\n\n  op = op || Union;\n  Object.keys(resolved).forEach(function (field) {\n    resolved[field] = Object.keys(resolved[field]).map(function (unit) {\n      return resolved[field][unit];\n    }).reduce(function (acc, curr) {\n      return acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr);\n    });\n  });\n  entries = Object.keys(multiRes);\n\n  if (isMulti && entries.length) {\n    resolved[VlMulti] = op === Union ? _defineProperty({}, Or, entries.reduce(function (acc, k) {\n      return acc.push.apply(acc, multiRes[k]), acc;\n    }, [])) : _defineProperty({}, And, entries.map(function (k) {\n      return _defineProperty({}, Or, multiRes[k]);\n    }));\n  }\n\n  return resolved;\n}\nvar ops = {\n  E_union: function E_union(base, value) {\n    if (!base.length) return value;\n    var i = 0,\n        n = value.length;\n\n    for (; i < n; ++i) {\n      if (base.indexOf(value[i]) < 0) base.push(value[i]);\n    }\n\n    return base;\n  },\n  E_intersect: function E_intersect(base, value) {\n    return !base.length ? value : base.filter(function (v) {\n      return value.indexOf(v) >= 0;\n    });\n  },\n  R_union: function R_union(base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n  R_intersect: function R_intersect(base, value) {\n    var lo = toNumber(value[0]),\n        hi = toNumber(value[1]);\n\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n\n    return base;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}