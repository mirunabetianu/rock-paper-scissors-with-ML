{"ast":null,"code":"import Renderer from './Renderer';\nimport { gradientRef, isGradient, patternPrefix } from './Gradient';\nimport marks from './marks/index';\nimport { cssClass } from './util/dom';\nimport { openTag, closeTag } from './util/tags';\nimport { fontFamily, fontSize, lineHeight, textLines, textValue } from './util/text';\nimport { visit } from './util/visit';\nimport clip from './util/svg/clip';\nimport metadata from './util/svg/metadata';\nimport { styles, styleProperties } from './util/svg/styles';\nimport { inherits, isArray } from 'vega-util';\nexport default function SVGStringRenderer(loader) {\n  Renderer.call(this, loader);\n  this._text = {\n    head: '',\n    bg: '',\n    root: '',\n    foot: '',\n    defs: '',\n    body: ''\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n}\nvar prototype = inherits(SVGStringRenderer, Renderer);\nvar base = Renderer.prototype;\n\nprototype.resize = function (width, height, origin, scaleFactor) {\n  base.resize.call(this, width, height, origin, scaleFactor);\n  var o = this._origin,\n      t = this._text;\n  var attr = {\n    class: 'marks',\n    width: this._width * this._scale,\n    height: this._height * this._scale,\n    viewBox: '0 0 ' + this._width + ' ' + this._height\n  };\n\n  for (var key in metadata) {\n    attr[key] = metadata[key];\n  }\n\n  t.head = openTag('svg', attr);\n  var bg = this._bgcolor;\n  if (bg === 'transparent' || bg === 'none') bg = null;\n\n  if (bg) {\n    t.bg = openTag('rect', {\n      width: this._width,\n      height: this._height,\n      style: 'fill: ' + bg + ';'\n    }) + closeTag('rect');\n  } else {\n    t.bg = '';\n  }\n\n  t.root = openTag('g', {\n    transform: 'translate(' + o + ')'\n  });\n  t.foot = closeTag('g') + closeTag('svg');\n  return this;\n};\n\nprototype.background = function () {\n  var rv = base.background.apply(this, arguments);\n\n  if (arguments.length && this._text.head) {\n    this.resize(this._width, this._height, this._origin, this._scale);\n  }\n\n  return rv;\n};\n\nprototype.svg = function () {\n  var t = this._text;\n  return t.head + t.bg + t.defs + t.root + t.body + t.foot;\n};\n\nprototype._render = function (scene) {\n  this._text.body = this.mark(scene);\n  this._text.defs = this.buildDefs();\n  return this;\n};\n\nprototype.buildDefs = function () {\n  var all = this._defs,\n      defs = '',\n      i,\n      id,\n      def,\n      tag,\n      stops;\n\n  for (id in all.gradient) {\n    def = all.gradient[id];\n    stops = def.stops;\n\n    if (def.gradient === 'radial') {\n      // SVG radial gradients automatically transform to normalized bbox\n      // coordinates, in a way that is cumbersome to replicate in canvas.\n      // So we wrap the radial gradient in a pattern element, allowing us\n      // to mantain a circular gradient that matches what canvas provides.\n      defs += openTag(tag = 'pattern', {\n        id: patternPrefix + id,\n        viewBox: '0,0,1,1',\n        width: '100%',\n        height: '100%',\n        preserveAspectRatio: 'xMidYMid slice'\n      });\n      defs += openTag('rect', {\n        width: '1',\n        height: '1',\n        fill: 'url(#' + id + ')'\n      }) + closeTag('rect');\n      defs += closeTag(tag);\n      defs += openTag(tag = 'radialGradient', {\n        id: id,\n        fx: def.x1,\n        fy: def.y1,\n        fr: def.r1,\n        cx: def.x2,\n        cy: def.y2,\n        r: def.r2\n      });\n    } else {\n      defs += openTag(tag = 'linearGradient', {\n        id: id,\n        x1: def.x1,\n        x2: def.x2,\n        y1: def.y1,\n        y2: def.y2\n      });\n    }\n\n    for (i = 0; i < stops.length; ++i) {\n      defs += openTag('stop', {\n        offset: stops[i].offset,\n        'stop-color': stops[i].color\n      }) + closeTag('stop');\n    }\n\n    defs += closeTag(tag);\n  }\n\n  for (id in all.clipping) {\n    def = all.clipping[id];\n    defs += openTag('clipPath', {\n      id: id\n    });\n\n    if (def.path) {\n      defs += openTag('path', {\n        d: def.path\n      }) + closeTag('path');\n    } else {\n      defs += openTag('rect', {\n        x: 0,\n        y: 0,\n        width: def.width,\n        height: def.height\n      }) + closeTag('rect');\n    }\n\n    defs += closeTag('clipPath');\n  }\n\n  return defs.length > 0 ? openTag('defs') + defs + closeTag('defs') : '';\n};\n\nvar object;\n\nfunction emit(name, value, ns, prefixed) {\n  object[prefixed || name] = value;\n}\n\nprototype.attributes = function (attr, item) {\n  object = {};\n  attr(emit, item, this);\n  return object;\n};\n\nprototype.href = function (item) {\n  var that = this,\n      href = item.href,\n      attr;\n\n  if (href) {\n    if (attr = that._hrefs && that._hrefs[href]) {\n      return attr;\n    } else {\n      that.sanitizeURL(href).then(function (attr) {\n        // rewrite to use xlink namespace\n        // note that this will be deprecated in SVG 2.0\n        attr['xlink:href'] = attr.href;\n        attr.href = null;\n        (that._hrefs || (that._hrefs = {}))[href] = attr;\n      });\n    }\n  }\n\n  return null;\n};\n\nprototype.mark = function (scene) {\n  var renderer = this,\n      mdef = marks[scene.marktype],\n      tag = mdef.tag,\n      defs = this._defs,\n      str = '',\n      style;\n\n  if (tag !== 'g' && scene.interactive === false) {\n    style = 'style=\"pointer-events: none;\"';\n  } // render opening group tag\n\n\n  str += openTag('g', {\n    'class': cssClass(scene),\n    'clip-path': scene.clip ? clip(renderer, scene, scene.group) : null\n  }, style); // render contained elements\n\n  function process(item) {\n    var href = renderer.href(item);\n    if (href) str += openTag('a', href);\n    style = tag !== 'g' ? applyStyles(item, scene, tag, defs) : null;\n    str += openTag(tag, renderer.attributes(mdef.attr, item), style);\n\n    if (tag === 'text') {\n      var tl = textLines(item);\n\n      if (isArray(tl)) {\n        // multi-line text\n        var attrs = {\n          x: 0,\n          dy: lineHeight(item)\n        };\n\n        for (var i = 0; i < tl.length; ++i) {\n          str += openTag('tspan', i ? attrs : null) + escape_text(textValue(item, tl[i])) + closeTag('tspan');\n        }\n      } else {\n        // single-line text\n        str += escape_text(textValue(item, tl));\n      }\n    } else if (tag === 'g') {\n      var fore = item.strokeForeground,\n          fill = item.fill,\n          stroke = item.stroke;\n\n      if (fore && stroke) {\n        item.stroke = null;\n      }\n\n      str += openTag('path', renderer.attributes(mdef.background, item), applyStyles(item, scene, 'bgrect', defs)) + closeTag('path');\n      str += openTag('g', renderer.attributes(mdef.content, item)) + renderer.markGroup(item) + closeTag('g');\n\n      if (fore && stroke) {\n        if (fill) item.fill = null;\n        item.stroke = stroke;\n        str += openTag('path', renderer.attributes(mdef.foreground, item), applyStyles(item, scene, 'bgrect', defs)) + closeTag('path');\n        if (fill) item.fill = fill;\n      } else {\n        str += openTag('path', renderer.attributes(mdef.foreground, item), applyStyles({}, scene, 'bgfore', defs)) + closeTag('path');\n      }\n    }\n\n    str += closeTag(tag);\n    if (href) str += closeTag('a');\n  }\n\n  if (mdef.nested) {\n    if (scene.items && scene.items.length) process(scene.items[0]);\n  } else {\n    visit(scene, process);\n  } // render closing group tag\n\n\n  return str + closeTag('g');\n};\n\nprototype.markGroup = function (scene) {\n  var renderer = this,\n      str = '';\n  visit(scene, function (item) {\n    str += renderer.mark(item);\n  });\n  return str;\n};\n\nfunction applyStyles(o, mark, tag, defs) {\n  if (o == null) return '';\n  var i,\n      n,\n      prop,\n      name,\n      value,\n      s = '';\n\n  if (tag === 'bgrect' && mark.interactive === false) {\n    s += 'pointer-events: none; ';\n  }\n\n  if (tag === 'bgfore') {\n    if (mark.interactive === false) {\n      s += 'pointer-events: none; ';\n    }\n\n    s += 'display: none; ';\n  }\n\n  if (tag === 'image') {\n    if (o.smooth === false) {\n      s += 'image-rendering: optimizeSpeed; image-rendering: pixelated; ';\n    }\n  }\n\n  if (tag === 'text') {\n    s += 'font-family: ' + fontFamily(o) + '; ';\n    s += 'font-size: ' + fontSize(o) + 'px; ';\n    if (o.fontStyle) s += 'font-style: ' + o.fontStyle + '; ';\n    if (o.fontVariant) s += 'font-variant: ' + o.fontVariant + '; ';\n    if (o.fontWeight) s += 'font-weight: ' + o.fontWeight + '; ';\n  }\n\n  for (i = 0, n = styleProperties.length; i < n; ++i) {\n    prop = styleProperties[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === 'fill') {\n        s += 'fill: none; ';\n      }\n    } else if (value === 'transparent' && (name === 'fill' || name === 'stroke')) {\n      // transparent is not a legal SVG value, so map to none instead\n      s += name + ': none; ';\n    } else {\n      if (isGradient(value)) {\n        value = gradientRef(value, defs.gradient, '');\n      }\n\n      s += name + ': ' + value + '; ';\n    }\n  }\n\n  return s ? 'style=\"' + s.trim() + '\"' : null;\n}\n\nfunction escape_text(s) {\n  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}","map":null,"metadata":{},"sourceType":"module"}