{"ast":null,"code":"import { labelFormat, labelFraction, labelValues } from './labels';\nimport { Symbols, Gradient } from './legend-types';\nimport { tickCount } from './ticks';\nimport { Transform, ingest } from 'vega-dataflow';\nimport { scaleFraction } from 'vega-scale';\nimport { constant, inherits, isFunction, peek } from 'vega-util';\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {*} [params.limit] - The maximum number of entries to\n *   include in a symbol legend.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\n\nexport default function LegendEntries(params) {\n  Transform.call(this, [], params);\n}\nvar prototype = inherits(LegendEntries, Transform);\n\nprototype.transform = function (_, pulse) {\n  if (this.value != null && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      items = this.value,\n      type = _.type || Symbols,\n      scale = _.scale,\n      limit = +_.limit,\n      count = tickCount(scale, _.count == null ? 5 : _.count, _.minstep),\n      format = _.format || labelFormat(scale, count, type, _.formatSpecifier, _.formatType, !!_.values),\n      values = _.values || labelValues(scale, count, type),\n      domain,\n      fraction,\n      size,\n      offset,\n      ellipsis;\n  if (items) out.rem = items;\n\n  if (type === Symbols) {\n    if (limit && values.length > limit) {\n      pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');\n      items = values.slice(0, limit - 1);\n      ellipsis = true;\n    } else {\n      items = values;\n    }\n\n    if (isFunction(size = _.size)) {\n      // if first value maps to size zero, remove from list (vega#717)\n      if (!_.values && scale(items[0]) === 0) {\n        items = items.slice(1);\n      } // compute size offset for legend entries\n\n\n      offset = items.reduce(function (max, value) {\n        return Math.max(max, size(value, _));\n      }, 0);\n    } else {\n      size = constant(offset = size || 8);\n    }\n\n    items = items.map(function (value, index) {\n      return ingest({\n        index: index,\n        label: format(value, index, items),\n        value: value,\n        offset: offset,\n        size: size(value, _)\n      });\n    });\n\n    if (ellipsis) {\n      ellipsis = values[items.length];\n      items.push(ingest({\n        index: items.length,\n        label: \"\\u2026\".concat(values.length - items.length, \" entries\"),\n        value: ellipsis,\n        offset: offset,\n        size: size(ellipsis, _)\n      }));\n    }\n  } else if (type === Gradient) {\n    domain = scale.domain(), fraction = scaleFraction(scale, domain[0], peek(domain)); // if automatic label generation produces 2 or fewer values,\n    // use the domain end points instead (fixes vega/vega#1364)\n\n    if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n      values = [domain[0], peek(domain)];\n    }\n\n    items = values.map(function (value, index) {\n      return ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: fraction(value)\n      });\n    });\n  } else {\n    size = values.length - 1;\n    fraction = labelFraction(scale);\n    items = values.map(function (value, index) {\n      return ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc: index ? fraction(value) : 0,\n        perc2: index === size ? 1 : fraction(values[index + 1])\n      });\n    });\n  }\n\n  out.source = items;\n  out.add = items;\n  this.value = items;\n  return out;\n};","map":null,"metadata":{},"sourceType":"module"}