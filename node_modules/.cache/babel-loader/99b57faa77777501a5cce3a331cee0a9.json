{"ast":null,"code":"import _slicedToArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport * as tf from '@tensorflow/tfjs';\nimport * as tfvis from '@tensorflow/tfjs-vis';\nimport { IMAGE_WIDTH, IMAGE_HEIGHT, NUM_CHANNELS } from './constants';\nvar classNames = ['Rock', 'Paper', 'Scissors'];\nexport var doSinglePrediction =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(model, img) {\n    var options,\n        resized,\n        logits,\n        values,\n        feedbackCanvas,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n            // First get input tensor\n            resized = tf.tidy(function () {\n              img = tf.browser.fromPixels(img);\n\n              if (NUM_CHANNELS === 1) {\n                // Bring it down to gray\n                var gray_mid = img.mean(2);\n                img = gray_mid.expandDims(2); // back to (width, height, 1)\n              } // assure (img.shape[0] === IMAGE_WIDTH && img.shape[1] === IMAGE_WIDTH\n\n\n              var alignCorners = true;\n              return tf.image.resizeBilinear(img, [IMAGE_WIDTH, IMAGE_HEIGHT], alignCorners);\n            });\n            logits = tf.tidy(function () {\n              // Singe-element batch\n              var batched = resized.reshape([1, IMAGE_WIDTH, IMAGE_HEIGHT, NUM_CHANNELS]); // return the logits\n\n              return model.predict(batched);\n            });\n            _context.next = 5;\n            return logits.data();\n\n          case 5:\n            values = _context.sent;\n            // if we want a visual\n            feedbackCanvas = options.feedbackCanvas;\n\n            if (!feedbackCanvas) {\n              _context.next = 10;\n              break;\n            }\n\n            _context.next = 10;\n            return tf.browser.toPixels(resized.div(tf.scalar(255)), feedbackCanvas);\n\n          case 10:\n            // cleanup tensors\n            resized.dispose();\n            logits.dispose(); // return class + prediction of all\n\n            return _context.abrupt(\"return\", classNames.map(function (className, idx) {\n              return {\n                className: className,\n                probability: values[idx]\n              };\n            }));\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function doSinglePrediction(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar doPrediction = function doPrediction(model, data) {\n  var testDataSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 420;\n  var testData = data.nextTestBatch(testDataSize);\n  var testxs = testData.xs.reshape([testDataSize, IMAGE_WIDTH, IMAGE_HEIGHT, NUM_CHANNELS]);\n  var labels = testData.labels.argMax([-1]);\n  var preds = model.predict(testxs).argMax([-1]);\n  testxs.dispose();\n  return [preds, labels];\n};\n\nexport var showAccuracy =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(model, data) {\n    var title,\n        _doPrediction,\n        _doPrediction2,\n        preds,\n        labels,\n        classAccuracy,\n        container,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            title = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : 'Accuracy';\n            _doPrediction = doPrediction(model, data), _doPrediction2 = _slicedToArray(_doPrediction, 2), preds = _doPrediction2[0], labels = _doPrediction2[1];\n            _context2.next = 4;\n            return tfvis.metrics.perClassAccuracy(labels, preds);\n\n          case 4:\n            classAccuracy = _context2.sent;\n            container = {\n              name: title,\n              tab: 'Evaluation'\n            };\n            tfvis.show.perClassAccuracy(container, classAccuracy, classNames);\n            tfvis.visor().setActiveTab('Evaluation');\n            labels.dispose();\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function showAccuracy(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var showConfusion =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(model, data) {\n    var title,\n        _doPrediction3,\n        _doPrediction4,\n        preds,\n        labels,\n        confusionMatrix,\n        container,\n        _args3 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            title = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : 'Confusion Matrix';\n            _doPrediction3 = doPrediction(model, data), _doPrediction4 = _slicedToArray(_doPrediction3, 2), preds = _doPrediction4[0], labels = _doPrediction4[1];\n            _context3.next = 4;\n            return tfvis.metrics.confusionMatrix(labels, preds);\n\n          case 4:\n            confusionMatrix = _context3.sent;\n            container = {\n              name: title,\n              tab: 'Evaluation'\n            };\n            tfvis.render.confusionMatrix(container, {\n              values: confusionMatrix,\n              tickLabels: classNames\n            });\n            labels.dispose();\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function showConfusion(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport var showExamples =\n/*#__PURE__*/\nfunction () {\n  var _ref4 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5(data) {\n    var surface, examples;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            // Create a container in the visor\n            surface = tfvis.visor().surface({\n              name: 'RPS Data Examples',\n              tab: 'Input Data'\n            }); // Get the examples\n\n            examples = data.nextTestBatch(42);\n            tf.unstack(examples.xs).forEach(\n            /*#__PURE__*/\n            function () {\n              var _ref5 = _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee4(tensor) {\n                var imageTensor, canvas;\n                return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        imageTensor = tensor.reshape([IMAGE_WIDTH, IMAGE_HEIGHT, NUM_CHANNELS]); // Re-organize to be num_channels last\n\n                        canvas = document.createElement('canvas');\n                        canvas.width = IMAGE_WIDTH;\n                        canvas.height = IMAGE_HEIGHT;\n                        canvas.style = 'margin: 4px;';\n                        _context4.next = 7;\n                        return tf.browser.toPixels(imageTensor, canvas);\n\n                      case 7:\n                        surface.drawArea.appendChild(canvas);\n                        tensor.dispose();\n                        imageTensor.dispose();\n\n                      case 10:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, _callee4);\n              }));\n\n              return function (_x8) {\n                return _ref5.apply(this, arguments);\n              };\n            }());\n\n          case 3:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function showExamples(_x7) {\n    return _ref4.apply(this, arguments);\n  };\n}(); // provided by https://github.com/cloud-annotations/object-detection-react\n// trained via IBM cloud https://cloud-annotations.github.io/training/object-detection/cli/index.html\n\nexport var TFWrapper = function TFWrapper(model) {\n  var calculateMaxScores = function calculateMaxScores(scores, numBoxes, numClasses) {\n    var maxes = [];\n    var classes = [];\n\n    for (var i = 0; i < numBoxes; i++) {\n      var max = Number.MIN_VALUE;\n      var index = -1;\n\n      for (var j = 0; j < numClasses; j++) {\n        if (scores[i * numClasses + j] > max) {\n          max = scores[i * numClasses + j];\n          index = j;\n        }\n      }\n\n      maxes[i] = max;\n      classes[i] = index;\n    }\n\n    return [maxes, classes];\n  };\n\n  var buildDetectedObjects = function buildDetectedObjects(width, height, boxes, scores, indexes, classes) {\n    var count = indexes.length;\n    var objects = [];\n\n    for (var i = 0; i < count; i++) {\n      var bbox = [];\n\n      for (var j = 0; j < 4; j++) {\n        bbox[j] = boxes[indexes[i] * 4 + j];\n      }\n\n      var minY = bbox[0] * height;\n      var minX = bbox[1] * width;\n      var maxY = bbox[2] * height;\n      var maxX = bbox[3] * width;\n      bbox[0] = minX;\n      bbox[1] = minY;\n      bbox[2] = maxX - minX;\n      bbox[3] = maxY - minY;\n      objects.push({\n        bbox: bbox,\n        class: classes[indexes[i]],\n        score: scores[indexes[i]]\n      });\n    }\n\n    return objects;\n  };\n\n  var detect = function detect(input) {\n    var batched = tf.tidy(function () {\n      var img = tf.browser.fromPixels(input); // Reshape to a single-element batch so we can pass it to executeAsync.\n\n      return img.expandDims(0);\n    });\n    var height = batched.shape[1];\n    var width = batched.shape[2];\n    return model.executeAsync(batched).then(function (result) {\n      var scores = result[0].dataSync();\n      var boxes = result[1].dataSync(); // clean the webgl tensors\n\n      batched.dispose();\n      tf.dispose(result);\n\n      var _calculateMaxScores = calculateMaxScores(scores, result[0].shape[1], result[0].shape[2]),\n          _calculateMaxScores2 = _slicedToArray(_calculateMaxScores, 2),\n          maxScores = _calculateMaxScores2[0],\n          classes = _calculateMaxScores2[1];\n\n      var prevBackend = tf.getBackend(); // run post process in cpu\n\n      tf.setBackend('cpu');\n      var indexTensor = tf.tidy(function () {\n        var boxes2 = tf.tensor2d(boxes, [result[1].shape[1], result[1].shape[3]]);\n        return tf.image.nonMaxSuppression(boxes2, maxScores, 20, // maxNumBoxes\n        0.5, // iou_threshold\n        0.5 // score_threshold\n        );\n      });\n      var indexes = indexTensor.dataSync();\n      indexTensor.dispose(); // restore previous backend\n\n      tf.setBackend(prevBackend);\n      return buildDetectedObjects(width, height, boxes, maxScores, indexes, classes);\n    });\n  };\n\n  return {\n    detect: detect\n  };\n};","map":{"version":3,"sources":["/Users/mirunabetianu/WebstormProjects/rps/src/tfjs/evaluationHelpers.js"],"names":["tf","tfvis","IMAGE_WIDTH","IMAGE_HEIGHT","NUM_CHANNELS","classNames","doSinglePrediction","model","img","options","resized","tidy","browser","fromPixels","gray_mid","mean","expandDims","alignCorners","image","resizeBilinear","logits","batched","reshape","predict","data","values","feedbackCanvas","toPixels","div","scalar","dispose","map","className","idx","probability","doPrediction","testDataSize","testData","nextTestBatch","testxs","xs","labels","argMax","preds","showAccuracy","title","metrics","perClassAccuracy","classAccuracy","container","name","tab","show","visor","setActiveTab","showConfusion","confusionMatrix","render","tickLabels","showExamples","surface","examples","unstack","forEach","tensor","imageTensor","canvas","document","createElement","width","height","style","drawArea","appendChild","TFWrapper","calculateMaxScores","scores","numBoxes","numClasses","maxes","classes","i","max","Number","MIN_VALUE","index","j","buildDetectedObjects","boxes","indexes","count","length","objects","bbox","minY","minX","maxY","maxX","push","class","score","detect","input","shape","executeAsync","then","result","dataSync","maxScores","prevBackend","getBackend","setBackend","indexTensor","boxes2","tensor2d","nonMaxSuppression"],"mappings":"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","sourcesContent":["import * as tf from '@tensorflow/tfjs'\nimport * as tfvis from '@tensorflow/tfjs-vis'\nimport { IMAGE_WIDTH, IMAGE_HEIGHT, NUM_CHANNELS } from './constants'\n\nconst classNames = ['Rock', 'Paper', 'Scissors']\n\nexport const doSinglePrediction = async (model, img, options = {}) => {\n  // First get input tensor\n  const resized = tf.tidy(() => {\n    img = tf.browser.fromPixels(img)\n    if (NUM_CHANNELS === 1) {\n      // Bring it down to gray\n      const gray_mid = img.mean(2)\n      img = gray_mid.expandDims(2) // back to (width, height, 1)\n    }\n    // assure (img.shape[0] === IMAGE_WIDTH && img.shape[1] === IMAGE_WIDTH\n    const alignCorners = true\n    return tf.image.resizeBilinear(\n      img,\n      [IMAGE_WIDTH, IMAGE_HEIGHT],\n      alignCorners\n    )\n  })\n\n  const logits = tf.tidy(() => {\n    // Singe-element batch\n    const batched = resized.reshape([\n      1,\n      IMAGE_WIDTH,\n      IMAGE_HEIGHT,\n      NUM_CHANNELS\n    ])\n\n    // return the logits\n    return model.predict(batched)\n  })\n\n  const values = await logits.data()\n\n  // if we want a visual\n  const { feedbackCanvas } = options\n  if (feedbackCanvas) {\n    await tf.browser.toPixels(resized.div(tf.scalar(255)), feedbackCanvas)\n  }\n  // cleanup tensors\n  resized.dispose()\n  logits.dispose()\n  // return class + prediction of all\n  return classNames.map((className, idx) => ({\n    className,\n    probability: values[idx]\n  }))\n}\n\nconst doPrediction = (model, data, testDataSize = 420) => {\n  const testData = data.nextTestBatch(testDataSize)\n  const testxs = testData.xs.reshape([\n    testDataSize,\n    IMAGE_WIDTH,\n    IMAGE_HEIGHT,\n    NUM_CHANNELS\n  ])\n  const labels = testData.labels.argMax([-1])\n  const preds = model.predict(testxs).argMax([-1])\n\n  testxs.dispose()\n  return [preds, labels]\n}\n\nexport const showAccuracy = async (model, data, title = 'Accuracy') => {\n  const [preds, labels] = doPrediction(model, data)\n  const classAccuracy = await tfvis.metrics.perClassAccuracy(labels, preds)\n  const container = { name: title, tab: 'Evaluation' }\n  tfvis.show.perClassAccuracy(container, classAccuracy, classNames)\n  tfvis.visor().setActiveTab('Evaluation')\n\n  labels.dispose()\n}\n\nexport const showConfusion = async (\n  model,\n  data,\n  title = 'Confusion Matrix'\n) => {\n  const [preds, labels] = doPrediction(model, data)\n  const confusionMatrix = await tfvis.metrics.confusionMatrix(labels, preds)\n  const container = { name: title, tab: 'Evaluation' }\n  tfvis.render.confusionMatrix(container, {\n    values: confusionMatrix,\n    tickLabels: classNames\n  })\n\n  labels.dispose()\n}\n\nexport const showExamples = async data => {\n  // Create a container in the visor\n  const surface = tfvis\n    .visor()\n    .surface({ name: 'RPS Data Examples', tab: 'Input Data' })\n\n  // Get the examples\n  const examples = data.nextTestBatch(42)\n\n  tf.unstack(examples.xs).forEach(async tensor => {\n    const imageTensor = tensor.reshape([\n      IMAGE_WIDTH,\n      IMAGE_HEIGHT,\n      NUM_CHANNELS\n    ])\n    // Re-organize to be num_channels last\n    const canvas = document.createElement('canvas')\n    canvas.width = IMAGE_WIDTH\n    canvas.height = IMAGE_HEIGHT\n    canvas.style = 'margin: 4px;'\n    await tf.browser.toPixels(imageTensor, canvas)\n    surface.drawArea.appendChild(canvas)\n\n    tensor.dispose()\n    imageTensor.dispose()\n  })\n}\n\n// provided by https://github.com/cloud-annotations/object-detection-react\n// trained via IBM cloud https://cloud-annotations.github.io/training/object-detection/cli/index.html\nexport const TFWrapper = model => {\n  const calculateMaxScores = (scores, numBoxes, numClasses) => {\n    const maxes = []\n    const classes = []\n    for (let i = 0; i < numBoxes; i++) {\n      let max = Number.MIN_VALUE\n      let index = -1\n      for (let j = 0; j < numClasses; j++) {\n        if (scores[i * numClasses + j] > max) {\n          max = scores[i * numClasses + j]\n          index = j\n        }\n      }\n      maxes[i] = max\n      classes[i] = index\n    }\n    return [maxes, classes]\n  }\n\n  const buildDetectedObjects = (\n    width,\n    height,\n    boxes,\n    scores,\n    indexes,\n    classes\n  ) => {\n    const count = indexes.length\n    const objects = []\n    for (let i = 0; i < count; i++) {\n      const bbox = []\n      for (let j = 0; j < 4; j++) {\n        bbox[j] = boxes[indexes[i] * 4 + j]\n      }\n      const minY = bbox[0] * height\n      const minX = bbox[1] * width\n      const maxY = bbox[2] * height\n      const maxX = bbox[3] * width\n      bbox[0] = minX\n      bbox[1] = minY\n      bbox[2] = maxX - minX\n      bbox[3] = maxY - minY\n      objects.push({\n        bbox: bbox,\n        class: classes[indexes[i]],\n        score: scores[indexes[i]]\n      })\n    }\n    return objects\n  }\n\n  const detect = input => {\n    const batched = tf.tidy(() => {\n      const img = tf.browser.fromPixels(input)\n      // Reshape to a single-element batch so we can pass it to executeAsync.\n      return img.expandDims(0)\n    })\n\n    const height = batched.shape[1]\n    const width = batched.shape[2]\n\n    return model.executeAsync(batched).then(result => {\n      const scores = result[0].dataSync()\n      const boxes = result[1].dataSync()\n\n      // clean the webgl tensors\n      batched.dispose()\n      tf.dispose(result)\n\n      const [maxScores, classes] = calculateMaxScores(\n        scores,\n        result[0].shape[1],\n        result[0].shape[2]\n      )\n\n      const prevBackend = tf.getBackend()\n      // run post process in cpu\n      tf.setBackend('cpu')\n      const indexTensor = tf.tidy(() => {\n        const boxes2 = tf.tensor2d(boxes, [\n          result[1].shape[1],\n          result[1].shape[3]\n        ])\n        return tf.image.nonMaxSuppression(\n          boxes2,\n          maxScores,\n          20, // maxNumBoxes\n          0.5, // iou_threshold\n          0.5 // score_threshold\n        )\n      })\n      const indexes = indexTensor.dataSync()\n      indexTensor.dispose()\n      // restore previous backend\n      tf.setBackend(prevBackend)\n\n      return buildDetectedObjects(\n        width,\n        height,\n        boxes,\n        maxScores,\n        indexes,\n        classes\n      )\n    })\n  }\n  return {\n    detect: detect\n  }\n}\n"]},"metadata":{},"sourceType":"module"}