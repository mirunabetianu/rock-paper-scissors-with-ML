{"ast":null,"code":"import { array, hasOwnProperty, toSet } from 'vega-util';\nimport invertRange from './scales/invertRange';\nimport invertRangeExtent from './scales/invertRangeExtent';\nimport { Identity, Linear, Log, Pow, Sqrt, Symlog, Time, UTC, Sequential, Diverging, Quantile, Quantize, Threshold, BinOrdinal, Ordinal, Band, Point, Continuous as C, Discrete as D, Discretizing as Z, Interpolating as I, Temporal as T } from './scales/types';\nimport { band as scaleBand, point as scalePoint } from './scales/scaleBand';\nimport { scaleBinOrdinal } from './scales/scaleBinOrdinal';\nimport * as $ from 'd3-scale'; // scale registry\n\nvar scales = {};\n/**\n * Augment scales with their type and needed inverse methods.\n */\n\nfunction create(type, constructor, metadata) {\n  var ctr = function scale() {\n    var s = constructor();\n\n    if (!s.invertRange) {\n      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : undefined;\n    }\n\n    s.type = type;\n    return s;\n  };\n\n  ctr.metadata = toSet(array(metadata));\n  return ctr;\n}\n\nexport function scale(type, scale, metadata) {\n  if (arguments.length > 1) {\n    scales[type] = create(type, scale, metadata);\n    return this;\n  } else {\n    return isValidScaleType(type) ? scales[type] : undefined;\n  }\n} // identity scale\n\nscale(Identity, $.scaleIdentity); // continuous scales\n\nscale(Linear, $.scaleLinear, C);\nscale(Log, $.scaleLog, [C, Log]);\nscale(Pow, $.scalePow, C);\nscale(Sqrt, $.scaleSqrt, C);\nscale(Symlog, $.scaleSymlog, C);\nscale(Time, $.scaleTime, [C, T]);\nscale(UTC, $.scaleUtc, [C, T]); // sequential scales\n\nscale(Sequential, $.scaleSequential, [C, I]); // backwards compat\n\nscale(\"\".concat(Sequential, \"-\").concat(Linear), $.scaleSequential, [C, I]);\nscale(\"\".concat(Sequential, \"-\").concat(Log), $.scaleSequentialLog, [C, I, Log]);\nscale(\"\".concat(Sequential, \"-\").concat(Pow), $.scaleSequentialPow, [C, I]);\nscale(\"\".concat(Sequential, \"-\").concat(Sqrt), $.scaleSequentialSqrt, [C, I]);\nscale(\"\".concat(Sequential, \"-\").concat(Symlog), $.scaleSequentialSymlog, [C, I]); // diverging scales\n\nscale(\"\".concat(Diverging, \"-\").concat(Linear), $.scaleDiverging, [C, I]);\nscale(\"\".concat(Diverging, \"-\").concat(Log), $.scaleDivergingLog, [C, I, Log]);\nscale(\"\".concat(Diverging, \"-\").concat(Pow), $.scaleDivergingPow, [C, I]);\nscale(\"\".concat(Diverging, \"-\").concat(Sqrt), $.scaleDivergingSqrt, [C, I]);\nscale(\"\".concat(Diverging, \"-\").concat(Symlog), $.scaleDivergingSymlog, [C, I]); // discretizing scales\n\nscale(Quantile, $.scaleQuantile, [Z, Quantile]);\nscale(Quantize, $.scaleQuantize, Z);\nscale(Threshold, $.scaleThreshold, Z); // discrete scales\n\nscale(BinOrdinal, scaleBinOrdinal, [D, Z]);\nscale(Ordinal, $.scaleOrdinal, D);\nscale(Band, scaleBand, D);\nscale(Point, scalePoint, D);\nexport function isValidScaleType(type) {\n  return hasOwnProperty(scales, type);\n}\n\nfunction hasType(key, type) {\n  var s = scales[key];\n  return s && s.metadata[type];\n}\n\nexport function isContinuous(key) {\n  return hasType(key, C);\n}\nexport function isDiscrete(key) {\n  return hasType(key, D);\n}\nexport function isDiscretizing(key) {\n  return hasType(key, Z);\n}\nexport function isLogarithmic(key) {\n  return hasType(key, Log);\n}\nexport function isTemporal(key) {\n  return hasType(key, T);\n}\nexport function isInterpolating(key) {\n  return hasType(key, I);\n}\nexport function isQuantile(key) {\n  return hasType(key, Quantile);\n}","map":null,"metadata":{},"sourceType":"module"}