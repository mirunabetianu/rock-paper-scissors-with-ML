{"ast":null,"code":"import { Epsilon, HalfPi, Tau } from '../util/constants';\nvar bounds,\n    lx,\n    ly,\n    circleThreshold = Tau - 1e-8;\nexport default function context(_) {\n  bounds = _;\n  return context;\n}\n\nfunction noop() {}\n\nfunction add(x, y) {\n  bounds.add(x, y);\n}\n\nfunction addL(x, y) {\n  add(lx = x, ly = y);\n}\n\nfunction addX(x) {\n  add(x, bounds.y1);\n}\n\nfunction addY(y) {\n  add(bounds.x1, y);\n}\n\ncontext.beginPath = noop;\ncontext.closePath = noop;\ncontext.moveTo = addL;\ncontext.lineTo = addL;\n\ncontext.rect = function (x, y, w, h) {\n  add(x + w, y + h);\n  addL(x, y);\n};\n\ncontext.quadraticCurveTo = function (x1, y1, x2, y2) {\n  quadExtrema(lx, x1, x2, addX);\n  quadExtrema(ly, y1, y2, addY);\n  addL(x2, y2);\n};\n\nfunction quadExtrema(x0, x1, x2, cb) {\n  var t = (x0 - x1) / (x0 + x2 - 2 * x1);\n  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);\n}\n\ncontext.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {\n  cubicExtrema(lx, x1, x2, x3, addX);\n  cubicExtrema(ly, y1, y2, y3, addY);\n  addL(x3, y3);\n};\n\nfunction cubicExtrema(x0, x1, x2, x3, cb) {\n  var a = x3 - x0 + 3 * x1 - 3 * x2,\n      b = x0 + x2 - 2 * x1,\n      c = x0 - x1;\n  var t0 = 0,\n      t1 = 0,\n      r; // solve for parameter t\n\n  if (Math.abs(a) > Epsilon) {\n    // quadratic equation\n    r = b * b + c * a;\n\n    if (r >= 0) {\n      r = Math.sqrt(r);\n      t0 = (-b + r) / a;\n      t1 = (-b - r) / a;\n    }\n  } else {\n    // linear equation\n    t0 = 0.5 * c / b;\n  } // calculate position\n\n\n  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));\n  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));\n}\n\nfunction cubic(t, x0, x1, x2, x3) {\n  var s = 1 - t,\n      s2 = s * s,\n      t2 = t * t;\n  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;\n}\n\ncontext.arc = function (cx, cy, r, sa, ea, ccw) {\n  // store last point on path\n  lx = r * Math.cos(ea) + cx;\n  ly = r * Math.sin(ea) + cy;\n\n  if (Math.abs(ea - sa) > circleThreshold) {\n    // treat as full circle\n    add(cx - r, cy - r);\n    add(cx + r, cy + r);\n  } else {\n    var update = function update(a) {\n      return add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);\n    };\n\n    var s, i; // sample end points\n\n    update(sa);\n    update(ea); // sample interior points aligned with 90 degrees\n\n    if (ea !== sa) {\n      sa = sa % Tau;\n      if (sa < 0) sa += Tau;\n      ea = ea % Tau;\n      if (ea < 0) ea += Tau;\n\n      if (ea < sa) {\n        ccw = !ccw; // flip direction\n\n        s = sa;\n        sa = ea;\n        ea = s; // swap end-points\n      }\n\n      if (ccw) {\n        ea -= Tau;\n        s = sa - sa % HalfPi;\n\n        for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) {\n          update(s);\n        }\n      } else {\n        s = sa - sa % HalfPi + HalfPi;\n\n        for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) {\n          update(s);\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}