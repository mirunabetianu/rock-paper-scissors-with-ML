{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getTypedFieldDef, hasConditionalFieldDef, isFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { normalizeEncoding } from '../encoding';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { stack } from '../stack';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { parseData as _parseData } from './data/parse';\nimport { assembleLayoutSignals as _assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { normalizeMarkDef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { replaceRepeaterInEncoding } from './repeater';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\n\nexport var UnitModel =\n/*#__PURE__*/\nfunction (_ModelWithField) {\n  _inherits(UnitModel, _ModelWithField);\n\n  function UnitModel(spec, parent, parentGivenName) {\n    var _this;\n\n    var parentGivenSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var repeater = arguments.length > 4 ? arguments[4] : undefined;\n    var config = arguments.length > 5 ? arguments[5] : undefined;\n\n    _classCallCheck(this, UnitModel);\n\n    var _a;\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(UnitModel).call(this, spec, 'unit', parent, parentGivenName, config, repeater, undefined, spec.view));\n    _this.specifiedScales = {};\n    _this.specifiedAxes = {};\n    _this.specifiedLegends = {};\n    _this.specifiedProjection = {};\n    _this.selection = {};\n    _this.children = [];\n    var mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n    var encodingWithRepeaterReplaced = replaceRepeaterInEncoding((_a = spec.encoding, _a !== null && _a !== void 0 ? _a : {}), repeater);\n    _this.markDef = normalizeMarkDef(spec.mark, encodingWithRepeaterReplaced, config, {\n      graticule: spec.data && isGraticuleGenerator(spec.data)\n    });\n    var encoding = _this.encoding = normalizeEncoding(encodingWithRepeaterReplaced, _this.markDef);\n    _this.size = initLayoutSize({\n      encoding: encoding,\n      size: Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {\n        width: spec.width\n      } : {}), spec.height ? {\n        height: spec.height\n      } : {})\n    }); // calculate stack properties\n\n    _this.stack = stack(mark, encoding);\n    _this.specifiedScales = _this.initScales(mark, encoding);\n    _this.specifiedAxes = _this.initAxes(encoding);\n    _this.specifiedLegends = _this.initLegend(encoding);\n    _this.specifiedProjection = spec.projection; // Selections will be initialized upon parse.\n\n    _this.selection = spec.selection;\n    return _this;\n  }\n\n  _createClass(UnitModel, [{\n    key: \"scaleDomain\",\n\n    /**\n     * Return specified Vega-Lite scale domain for a particular channel\n     * @param channel\n     */\n    value: function scaleDomain(channel) {\n      var scale = this.specifiedScales[channel];\n      return scale ? scale.domain : undefined;\n    }\n  }, {\n    key: \"axis\",\n    value: function axis(channel) {\n      return this.specifiedAxes[channel];\n    }\n  }, {\n    key: \"legend\",\n    value: function legend(channel) {\n      return this.specifiedLegends[channel];\n    }\n  }, {\n    key: \"initScales\",\n    value: function initScales(mark, encoding) {\n      return SCALE_CHANNELS.reduce(function (scales, channel) {\n        var fieldDef;\n        var specifiedScale;\n        var channelDef = encoding[channel];\n\n        if (isFieldDef(channelDef)) {\n          fieldDef = channelDef;\n          specifiedScale = channelDef.scale;\n        } else if (hasConditionalFieldDef(channelDef)) {\n          // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n          fieldDef = channelDef.condition;\n          specifiedScale = channelDef.condition['scale'];\n        }\n\n        if (fieldDef) {\n          scales[channel] = specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : {};\n        }\n\n        return scales;\n      }, {});\n    }\n  }, {\n    key: \"initAxes\",\n    value: function initAxes(encoding) {\n      return [X, Y].reduce(function (_axis, channel) {\n        // Position Axis\n        // TODO: handle ConditionFieldDef\n        var channelDef = encoding[channel];\n\n        if (isFieldDef(channelDef) || channel === X && isFieldDef(encoding.x2) || channel === Y && isFieldDef(encoding.y2)) {\n          var axisSpec = isFieldDef(channelDef) ? channelDef.axis : null;\n\n          if (axisSpec !== null) {\n            _axis[channel] = Object.assign({}, axisSpec);\n          }\n        }\n\n        return _axis;\n      }, {});\n    }\n  }, {\n    key: \"initLegend\",\n    value: function initLegend(encoding) {\n      return NONPOSITION_SCALE_CHANNELS.reduce(function (_legend, channel) {\n        var channelDef = encoding[channel];\n\n        if (channelDef) {\n          var legend = isFieldDef(channelDef) ? channelDef.legend : hasConditionalFieldDef(channelDef) // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n          ? channelDef.condition['legend'] : null;\n\n          if (legend !== null && legend !== false && supportLegend(channel)) {\n            _legend[channel] = Object.assign({}, legend);\n          }\n        }\n\n        return _legend;\n      }, {});\n    }\n  }, {\n    key: \"parseData\",\n    value: function parseData() {\n      this.component.data = _parseData(this);\n    }\n  }, {\n    key: \"parseLayoutSize\",\n    value: function parseLayoutSize() {\n      parseUnitLayoutSize(this);\n    }\n  }, {\n    key: \"parseSelections\",\n    value: function parseSelections() {\n      this.component.selection = parseUnitSelection(this, this.selection);\n    }\n  }, {\n    key: \"parseMarkGroup\",\n    value: function parseMarkGroup() {\n      this.component.mark = parseMarkGroups(this);\n    }\n  }, {\n    key: \"parseAxesAndHeaders\",\n    value: function parseAxesAndHeaders() {\n      this.component.axes = parseUnitAxes(this);\n    }\n  }, {\n    key: \"assembleSelectionTopLevelSignals\",\n    value: function assembleSelectionTopLevelSignals(signals) {\n      return assembleTopLevelSignals(this, signals);\n    }\n  }, {\n    key: \"assembleSignals\",\n    value: function assembleSignals() {\n      return [].concat(_toConsumableArray(assembleAxisSignals(this)), _toConsumableArray(assembleUnitSelectionSignals(this, [])));\n    }\n  }, {\n    key: \"assembleSelectionData\",\n    value: function assembleSelectionData(data) {\n      return assembleUnitSelectionData(this, data);\n    }\n  }, {\n    key: \"assembleLayout\",\n    value: function assembleLayout() {\n      return null;\n    }\n  }, {\n    key: \"assembleLayoutSignals\",\n    value: function assembleLayoutSignals() {\n      return _assembleLayoutSignals(this);\n    }\n  }, {\n    key: \"assembleMarks\",\n    value: function assembleMarks() {\n      var _a;\n\n      var marks = (_a = this.component.mark, _a !== null && _a !== void 0 ? _a : []); // If this unit is part of a layer, selections should augment\n      // all in concert rather than each unit individually. This\n      // ensures correct interleaving of clipping and brushed marks.\n\n      if (!this.parent || !isLayerModel(this.parent)) {\n        marks = assembleUnitSelectionMarks(this, marks);\n      }\n\n      return marks.map(this.correctDataNames);\n    }\n  }, {\n    key: \"getMapping\",\n    value: function getMapping() {\n      return this.encoding;\n    }\n  }, {\n    key: \"channelHasField\",\n    value: function channelHasField(channel) {\n      return vlEncoding.channelHasField(this.encoding, channel);\n    }\n  }, {\n    key: \"fieldDef\",\n    value: function fieldDef(channel) {\n      var channelDef = this.encoding[channel];\n      return getTypedFieldDef(channelDef);\n    }\n  }, {\n    key: \"hasProjection\",\n    get: function get() {\n      var encoding = this.encoding;\n      var isGeoShapeMark = this.mark === GEOSHAPE;\n      var hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(function (channel) {\n        return isFieldDef(encoding[channel]);\n      });\n      return isGeoShapeMark || hasGeoPosition;\n    }\n  }, {\n    key: \"mark\",\n    get: function get() {\n      return this.markDef.type;\n    }\n  }]);\n\n  return UnitModel;\n}(ModelWithField);","map":null,"metadata":{},"sourceType":"module"}