{"ast":null,"code":"import partition from './partition';\nimport { regressionLoess } from 'vega-statistics';\nimport { ingest, Transform } from 'vega-dataflow';\nimport { accessorName, inherits } from 'vega-util';\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\n\nexport default function Loess(params) {\n  Transform.call(this, null, params);\n}\nLoess.Definition = {\n  \"type\": \"Loess\",\n  \"metadata\": {\n    \"generates\": true\n  },\n  \"params\": [{\n    \"name\": \"x\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"y\",\n    \"type\": \"field\",\n    \"required\": true\n  }, {\n    \"name\": \"groupby\",\n    \"type\": \"field\",\n    \"array\": true\n  }, {\n    \"name\": \"bandwidth\",\n    \"type\": \"number\",\n    \"default\": 0.3\n  }, {\n    \"name\": \"as\",\n    \"type\": \"string\",\n    \"array\": true\n  }]\n};\nvar prototype = inherits(Loess, Transform);\n\nprototype.transform = function (_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n  if (!this.value || pulse.changed() || _.modified()) {\n    var source = pulse.materialize(pulse.SOURCE).source,\n        groups = partition(source, _.groupby),\n        names = (_.groupby || []).map(accessorName),\n        m = names.length,\n        as = _.as || [accessorName(_.x), accessorName(_.y)],\n        values = [];\n    groups.forEach(function (g) {\n      regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(function (p) {\n        var t = {};\n\n        for (var i = 0; i < m; ++i) {\n          t[names[i]] = g.dims[i];\n        }\n\n        t[as[0]] = p[0];\n        t[as[1]] = p[1];\n        values.push(ingest(t));\n      });\n    });\n    if (this.value) out.rem = this.value;\n    this.value = out.add = out.source = values;\n  }\n\n  return out;\n};","map":null,"metadata":{},"sourceType":"module"}