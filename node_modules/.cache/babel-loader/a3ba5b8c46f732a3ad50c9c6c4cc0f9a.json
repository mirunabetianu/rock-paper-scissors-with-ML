{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { COLOR, FILL, FILLOPACITY, OPACITY, SHAPE, SIZE, STROKE, STROKEOPACITY, STROKEWIDTH } from '../../channel';\nimport { getTypedFieldDef, isFieldDef, isTimeFormatFieldDef, title as fieldDefTitle } from '../../channeldef';\nimport { GEOJSON } from '../../type';\nimport { deleteNestedProperty, getFirstDefined, keys } from '../../util';\nimport { mergeTitleComponent, numberFormat } from '../common';\nimport { guideEncodeEntry } from '../guide';\nimport { isUnitModel } from '../model';\nimport { parseGuideResolve } from '../resolve';\nimport { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';\nimport { LegendComponent, LEGEND_COMPONENT_PROPERTIES } from './component';\nimport * as encode from './encode';\nimport * as properties from './properties';\nimport { direction, type } from './properties';\nimport { parseInteractiveLegend } from '../selection/transforms/legends';\nexport function parseLegend(model) {\n  if (isUnitModel(model)) {\n    model.component.legends = parseUnitLegend(model);\n  } else {\n    model.component.legends = parseNonUnitLegend(model);\n  }\n}\n\nfunction parseUnitLegend(model) {\n  var encoding = model.encoding;\n  return [COLOR, FILL, STROKE, STROKEWIDTH, SIZE, SHAPE, OPACITY, FILLOPACITY, STROKEOPACITY].reduce(function (legendComponent, channel) {\n    var def = encoding[channel];\n\n    if (model.legend(channel) && model.getScaleComponent(channel) && !(isFieldDef(def) && channel === SHAPE && def.type === GEOJSON)) {\n      legendComponent[channel] = parseLegendForChannel(model, channel);\n    }\n\n    return legendComponent;\n  }, {});\n}\n\nfunction getLegendDefWithScale(model, channel) {\n  var scale = model.scaleName(COLOR);\n\n  if (channel === 'color') {\n    return model.markDef.filled ? {\n      fill: scale\n    } : {\n      stroke: scale\n    };\n  }\n\n  return _defineProperty({}, channel, model.scaleName(channel));\n}\n\nfunction isExplicit(value, property, legend, fieldDef) {\n  switch (property) {\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!legend.values;\n\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === fieldDef.title) {\n        return true;\n      }\n\n  } // Otherwise, things are explicit if the returned value matches the specified property\n\n\n  return value === legend[property];\n}\n\nexport function parseLegendForChannel(model, channel) {\n  var _a;\n\n  var fieldDef = model.fieldDef(channel);\n  var legend = model.legend(channel);\n  var legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n  parseInteractiveLegend(model, channel, legendCmpt);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = LEGEND_COMPONENT_PROPERTIES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n      var value = getProperty(property, legend, channel, model);\n\n      if (value !== undefined) {\n        var explicit = isExplicit(value, property, legend, fieldDef);\n\n        if (explicit || model.config.legend[property] === undefined) {\n          legendCmpt.set(property, value, explicit);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var legendEncoding = (_a = legend.encoding, _a !== null && _a !== void 0 ? _a : {});\n  var selections = legendCmpt.get('selections');\n  var legendEncode = ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries'].reduce(function (e, part) {\n    var _a, _b, _c;\n\n    var legendEncodingPart = guideEncodeEntry((_a = legendEncoding[part], _a !== null && _a !== void 0 ? _a : {}), model);\n    var value = encode[part] ? encode[part](fieldDef, legendEncodingPart, model, channel, legendCmpt) // apply rule\n    : legendEncodingPart; // no rule -- just default values\n\n    if (value !== undefined && keys(value).length > 0) {\n      e[part] = Object.assign(Object.assign(Object.assign({}, ((_b = selections) === null || _b === void 0 ? void 0 : _b.length) ? {\n        name: \"\".concat(fieldDef.field, \"_legend_\").concat(part)\n      } : {}), ((_c = selections) === null || _c === void 0 ? void 0 : _c.length) ? {\n        interactive: !!selections\n      } : {}), {\n        update: value\n      });\n    }\n\n    return e;\n  }, {});\n\n  if (keys(legendEncode).length > 0) {\n    legendCmpt.set('encode', legendEncode, !!legend.encoding);\n  }\n\n  return legendCmpt;\n}\n\nfunction getProperty(property, legend, channel, model) {\n  var encoding = model.encoding,\n      mark = model.mark;\n  var fieldDef = getTypedFieldDef(encoding[channel]);\n  var legendConfig = model.config.legend;\n  var timeUnit = fieldDef.timeUnit;\n  var scaleType = model.getScaleComponent(channel).get('type');\n\n  switch (property) {\n    // TODO: enable when https://github.com/vega/vega/issues/1351 is fixed\n    // case 'clipHeight':\n    //   return getFirstDefined(specifiedLegend.clipHeight, properties.clipHeight(properties.type(...)));\n    case 'direction':\n      return direction({\n        legend: legend,\n        legendConfig: legendConfig,\n        timeUnit: timeUnit,\n        channel: channel,\n        scaleType: scaleType\n      });\n\n    case 'format':\n      // We don't include temporal field here as we apply format in encode block\n      if (isTimeFormatFieldDef(fieldDef)) {\n        return undefined;\n      }\n\n      return numberFormat(fieldDef, legend.format, model.config);\n\n    case 'formatType':\n      // As with format, we don't include temporal field here as we apply format in encode block\n      if (isTimeFormatFieldDef(fieldDef)) {\n        return undefined;\n      }\n\n      return legend.formatType;\n\n    case 'gradientLength':\n      return getFirstDefined( // do specified gradientLength first\n      legend.gradientLength, legendConfig.gradientLength, // Otherwise, use smart default based on plot height\n      properties.defaultGradientLength({\n        model: model,\n        legend: legend,\n        legendConfig: legendConfig,\n        channel: channel,\n        scaleType: scaleType\n      }));\n\n    case 'labelOverlap':\n      return getFirstDefined(legend.labelOverlap, properties.defaultLabelOverlap(scaleType));\n\n    case 'symbolType':\n      return getFirstDefined(legend.symbolType, properties.defaultSymbolType(mark, channel, encoding.shape, model.markDef.shape));\n\n    case 'title':\n      return fieldDefTitle(fieldDef, model.config, {\n        allowDisabling: true\n      }) || undefined;\n\n    case 'type':\n      return type({\n        legend: legend,\n        channel: channel,\n        timeUnit: timeUnit,\n        scaleType: scaleType,\n        alwaysReturn: false\n      });\n\n    case 'values':\n      return properties.values(legend, fieldDef);\n  } // Otherwise, return specified property.\n\n\n  return legend[property];\n}\n\nfunction parseNonUnitLegend(model) {\n  var _model$component = model.component,\n      legends = _model$component.legends,\n      resolve = _model$component.resolve;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var child = _step2.value;\n      parseLegend(child);\n      keys(child.component.legends).forEach(function (channel) {\n        resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n        if (resolve.legend[channel] === 'shared') {\n          // If the resolve says shared (and has not been overridden)\n          // We will try to merge and see if there is a conflict\n          legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n          if (!legends[channel]) {\n            // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n            // Thus, mark legend as independent and remove the legend component.\n            resolve.legend[channel] = 'independent';\n            delete legends[channel];\n          }\n        }\n      });\n    };\n\n    for (var _iterator2 = model.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      _loop();\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  keys(legends).forEach(function (channel) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = model.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var child = _step3.value;\n\n        if (!child.component.legends[channel]) {\n          // skip if the child does not have a particular legend\n          continue;\n        }\n\n        if (resolve.legend[channel] === 'shared') {\n          // After merging shared legend, make sure to remove legend from child\n          delete child.component.legends[channel];\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  });\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend, childLegend) {\n  var _a, _b, _c, _d, _e, _f;\n\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n\n  var mergedOrient = mergedLegend.getWithExplicit('orient');\n  var childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  var typeMerged = false; // Otherwise, let's merge\n\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    var _loop2 = function _loop2() {\n      var prop = _step4.value;\n      var mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend', // Tie breaker function\n      function (v1, v2) {\n        switch (prop) {\n          case 'symbolType':\n            return mergeSymbolType(v1, v2);\n\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n\n          case 'type':\n            // There are only two types. If we have different types, then prefer symbol over gradient.\n            typeMerged = true;\n            return makeImplicit('symbol');\n        }\n\n        return defaultTieBreaker(v1, v2, prop, 'legend');\n      });\n      mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n    };\n\n    for (var _iterator4 = LEGEND_COMPONENT_PROPERTIES[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      _loop2();\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  if (typeMerged) {\n    if (_c = (_b = (_a = mergedLegend.implicit) === null || _a === void 0 ? void 0 : _a.encode) === null || _b === void 0 ? void 0 : _b.gradient, _c !== null && _c !== void 0 ? _c : {}) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n\n    if (_f = (_e = (_d = mergedLegend.explicit) === null || _d === void 0 ? void 0 : _d.encode) === null || _e === void 0 ? void 0 : _e.gradient, _f !== null && _f !== void 0 ? _f : {}) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n\nfunction mergeSymbolType(st1, st2) {\n  if (st2.value === 'circle') {\n    // prefer \"circle\" over \"stroke\"\n    return st2;\n  }\n\n  return st1;\n}","map":null,"metadata":{},"sourceType":"module"}