{"ast":null,"code":"import { selector as parseSelector } from 'vega-event-selector';\nimport { forEachSelection, TUPLE } from '..';\nimport { array, isString } from 'vega-util';\nimport { SELECTION_ID, isLegendBinding, isLegendStreamBinding } from '../../../selection';\nimport * as log from '../../../log';\nimport { duplicate, varName } from '../../../util';\nimport { TUPLE_FIELDS } from './project';\nimport { TOGGLE } from './toggle';\nvar legendBindings = {\n  has: function has(selCmpt) {\n    var spec = selCmpt.resolve === 'global' && selCmpt.bind && isLegendBinding(selCmpt.bind);\n    var projLen = selCmpt.project.items.length === 1 && selCmpt.project.items[0].field !== SELECTION_ID;\n\n    if (spec && !projLen) {\n      log.warn(log.message.LEGEND_BINDINGS_PROJECT_LENGTH);\n    }\n\n    return spec && projLen;\n  },\n  parse: function parse(model, selCmpt, selDef, origDef) {\n    var _a; // Binding a selection to a legend disables default direct manipulation interaction.\n    // A user can choose to re-enable it by explicitly specifying triggering input events.\n\n\n    if (!origDef.on) delete selCmpt.events;\n    if (!origDef.clear) delete selCmpt.clear;\n\n    if (origDef.on || origDef.clear) {\n      var legendFilter = 'event.item && indexof(event.item.mark.role, \"legend\") < 0';\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = selCmpt.events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _evt = _step.value;\n          _evt.filter = array((_a = _evt.filter, _a !== null && _a !== void 0 ? _a : []));\n\n          if (_evt.filter.indexOf(legendFilter) < 0) {\n            _evt.filter.push(legendFilter);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    var evt = isLegendStreamBinding(selCmpt.bind) ? selCmpt.bind.legend : 'click';\n    var stream = isString(evt) ? parseSelector(evt, 'view') : array(evt);\n    selCmpt.bind = {\n      legend: {\n        merge: stream\n      }\n    };\n  },\n  topLevelSignals: function topLevelSignals(model, selCmpt, signals) {\n    var selName = selCmpt.name;\n    var stream = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;\n\n    var markName = function markName(name) {\n      return function (s) {\n        var ds = duplicate(s);\n        ds.markname = name;\n        return ds;\n      };\n    };\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      var _loop = function _loop() {\n        var proj = _step2.value;\n        if (!proj.hasLegend) return \"continue\";\n        var prefix = \"\".concat(proj.field, \"_legend\");\n        var sgName = \"\".concat(selName, \"_\").concat(prefix);\n        var hasSignal = signals.filter(function (s) {\n          return s.name === sgName;\n        });\n\n        if (hasSignal.length === 0) {\n          var events = stream.merge.map(markName(\"\".concat(prefix, \"_symbols\"))).concat(stream.merge.map(markName(\"\".concat(prefix, \"_labels\")))).concat(stream.merge.map(markName(\"\".concat(prefix, \"_entries\"))));\n          signals.unshift(Object.assign(Object.assign({\n            name: sgName\n          }, !selCmpt.init ? {\n            value: null\n          } : {}), {\n            on: [// Legend entries do not store values, so we need to walk the scenegraph to the symbol datum.\n            {\n              events: events,\n              update: 'datum.value || item().items[0].items[0].datum.value',\n              force: true\n            }, {\n              events: stream.merge,\n              update: \"!event.item || !datum ? null : \".concat(sgName),\n              force: true\n            }]\n          }));\n        }\n      };\n\n      for (var _iterator2 = selCmpt.project.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return signals;\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var name = selCmpt.name;\n    var proj = selCmpt.project;\n\n    var tuple = _signals.find(function (s) {\n      return s.name === name + TUPLE;\n    });\n\n    var fields = name + TUPLE_FIELDS;\n    var values = proj.items.filter(function (p) {\n      return p.hasLegend;\n    }).map(function (p) {\n      return varName(\"\".concat(name, \"_\").concat(p.field, \"_legend\"));\n    });\n    var valid = values.map(function (v) {\n      return \"\".concat(v, \" !== null\");\n    }).join(' && ');\n    var update = \"\".concat(valid, \" ? {fields: \").concat(fields, \", values: [\").concat(values.join(', '), \"]} : null\");\n\n    if (selCmpt.events && values.length > 0) {\n      tuple.on.push({\n        events: values.map(function (signal) {\n          return {\n            signal: signal\n          };\n        }),\n        update: update\n      });\n    } else if (values.length > 0) {\n      tuple.update = update;\n      delete tuple.value;\n      delete tuple.on;\n    }\n\n    var toggle = _signals.find(function (s) {\n      return s.name === name + TOGGLE;\n    });\n\n    var events = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;\n\n    if (toggle) {\n      if (!selCmpt.events) toggle.on[0].events = events;else toggle.on.push(Object.assign(Object.assign({}, toggle.on[0]), {\n        events: events\n      }));\n    }\n\n    return _signals;\n  }\n};\nexport default legendBindings;\nexport function parseInteractiveLegend(model, channel, legendCmpt) {\n  var field = model.fieldDef(channel).field;\n  forEachSelection(model, function (selCmpt) {\n    var _a, _b;\n\n    var proj = (_a = selCmpt.project.hasField[field], _a !== null && _a !== void 0 ? _a : selCmpt.project.hasChannel[channel]);\n\n    if (proj && legendBindings.has(selCmpt)) {\n      var legendSelections = (_b = legendCmpt.get('selections'), _b !== null && _b !== void 0 ? _b : []);\n      legendSelections.push(selCmpt.name);\n      legendCmpt.set('selections', legendSelections, false);\n      proj.hasLegend = true;\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module"}