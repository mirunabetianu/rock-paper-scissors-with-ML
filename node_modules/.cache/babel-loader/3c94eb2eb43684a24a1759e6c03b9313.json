{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { getMainRangeChannel, X, X2, Y2 } from '../../../channel';\nimport { isFieldDef, isPositionFieldDef } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { ScaleType } from '../../../scale';\nimport { contains, getFirstDefined } from '../../../util';\nimport { getMarkConfig } from '../../common';\nimport { getOffset } from './offset';\nimport * as ref from './valueref';\n/**\n * Return encode for point (non-band) position channels.\n */\n\nexport function pointPosition(channel, model, _ref) {\n  var defaultPos = _ref.defaultPos,\n      vgChannel = _ref.vgChannel;\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n  var encoding = model.encoding,\n      mark = model.mark,\n      markDef = model.markDef,\n      config = model.config,\n      stack = model.stack;\n  var channelDef = encoding[channel];\n  var channel2Def = encoding[channel === X ? X2 : Y2];\n  var scaleName = model.scaleName(channel);\n  var scale = model.getScaleComponent(channel);\n  var offset = getOffset(channel, model.markDef);\n  var defaultRef = pointPositionDefaultRef({\n    model: model,\n    markDef: markDef,\n    config: config,\n    defaultPos: defaultPos,\n    channel: channel,\n    scaleName: scaleName,\n    scale: scale,\n    mark: mark,\n    checkBarAreaWithoutZero: !channel2Def // only check for non-ranged marks\n\n  });\n  var valueRef = !channelDef && (encoding.latitude || encoding.longitude) ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n  {\n    field: model.getName(channel)\n  } : positionRef({\n    channel: channel,\n    channelDef: channelDef,\n    channel2Def: channel2Def,\n    markDef: markDef,\n    config: config,\n    scaleName: scaleName,\n    scale: scale,\n    stack: stack,\n    offset: offset,\n    defaultRef: defaultRef\n  });\n  return _defineProperty({}, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, valueRef);\n} // TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated. For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\n\nfunction positionRef(params) {\n  var channel = params.channel,\n      channelDef = params.channelDef,\n      scaleName = params.scaleName,\n      stack = params.stack,\n      offset = params.offset; // This isn't a part of midPoint because we use midPoint for non-position too\n\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isPositionFieldDef(channelDef) && channelDef.band !== undefined) {\n      return ref.interpolatedSignalRef({\n        scaleName: scaleName,\n        fieldDef: channelDef,\n        startSuffix: 'start',\n        band: channelDef.band,\n        offset: 0\n      });\n    } // x or y use stack_end so that stacked line's point mark use stack_end too.\n\n\n    return ref.fieldRef(channelDef, scaleName, {\n      suffix: 'end'\n    }, {\n      offset: offset\n    });\n  }\n\n  return ref.midPointRefWithPositionInvalidTest(params);\n}\n\nexport function pointPositionDefaultRef(_ref3) {\n  var model = _ref3.model,\n      markDef = _ref3.markDef,\n      config = _ref3.config,\n      defaultPos = _ref3.defaultPos,\n      channel = _ref3.channel,\n      scaleName = _ref3.scaleName,\n      scale = _ref3.scale,\n      mark = _ref3.mark,\n      checkBarAreaWithZero = _ref3.checkBarAreaWithoutZero;\n  return function () {\n    var mainChannel = getMainRangeChannel(channel);\n    var definedValueOrConfig = getFirstDefined(markDef[channel], getMarkConfig(channel, markDef, config));\n\n    if (definedValueOrConfig !== undefined) {\n      return ref.widthHeightValueRef(channel, definedValueOrConfig);\n    }\n\n    if (defaultPos === 'zeroOrMin' || defaultPos === 'zeroOrMax') {\n      if (scaleName) {\n        var scaleType = scale.get('type');\n\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {\n              scaleType: scaleType\n            }));\n          }\n        } else {\n          if (scale.domainDefinitelyIncludesZero()) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {\n              zeroFalse: scale.explicit.zero === false\n            }));\n          }\n        }\n      }\n\n      if (defaultPos === 'zeroOrMin') {\n        return mainChannel === 'x' ? {\n          value: 0\n        } : {\n          field: {\n            group: 'height'\n          }\n        };\n      } else {\n        // zeroOrMax\n        return mainChannel === 'x' ? {\n          field: {\n            group: 'width'\n          }\n        } : {\n          value: 0\n        };\n      }\n    } else {\n      // mid\n      var sizeRef = model[mainChannel === 'x' ? 'width' : 'height'];\n      return Object.assign(Object.assign({}, sizeRef), {\n        mult: 0.5\n      });\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}