{"ast":null,"code":"import { getFirstDefined } from '../../../util';\nimport { getMarkConfig } from '../../common';\nimport { wrapCondition } from './conditional';\nimport * as ref from './valueref';\n/**\n * Return encodoing encode for non-positional channels with scales. (Text doesn't have scale.)\n */\n\nexport function nonPosition(channel, model) {\n  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var markDef = model.markDef,\n      encoding = model.encoding,\n      config = model.config;\n  var _opt$vgChannel = opt.vgChannel,\n      vgChannel = _opt$vgChannel === void 0 ? channel : _opt$vgChannel;\n  var defaultRef = opt.defaultRef,\n      defaultValue = opt.defaultValue;\n\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : vgChannel === channel ? // When vl channel is the same as Vega's, no need to read from config as Vega will apply them correctly\n    markDef[channel] : // However, when they are different (e.g, vl's text size is vg fontSize), need to read \"size\" from configs\n    getFirstDefined(markDef[channel], markDef[vgChannel], getMarkConfig(channel, markDef, config, {\n      vgChannel: vgChannel\n    }));\n    defaultRef = defaultValue ? {\n      value: defaultValue\n    } : undefined;\n  }\n\n  var channelDef = encoding[channel];\n  return wrapCondition(model, channelDef, vgChannel, function (cDef) {\n    return ref.midPoint({\n      channel: channel,\n      channelDef: cDef,\n      markDef: markDef,\n      config: config,\n      scaleName: model.scaleName(channel),\n      scale: model.getScaleComponent(channel),\n      stack: null,\n      defaultRef: defaultRef\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"module"}