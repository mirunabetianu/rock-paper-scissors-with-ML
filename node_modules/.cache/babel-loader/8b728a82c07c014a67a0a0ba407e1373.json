{"ast":null,"code":"import * as log from '../../../log';\nimport { isPathMark } from '../../../mark';\nimport { tooltip } from '../../mark/encode';\nvar VORONOI = 'voronoi';\nvar nearest = {\n  has: function has(selCmpt) {\n    return selCmpt.type !== 'interval' && selCmpt.nearest;\n  },\n  parse: function parse(model, selCmpt) {\n    // Scope selection events to the voronoi mark to prevent capturing\n    // events that occur on the group mark (https://github.com/vega/vega/issues/2112).\n    if (selCmpt.events) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = selCmpt.events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var s = _step.value;\n          s.markname = model.getName(VORONOI);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  },\n  marks: function marks(model, selCmpt, _marks) {\n    var _selCmpt$project$hasC = selCmpt.project.hasChannel,\n        x = _selCmpt$project$hasC.x,\n        y = _selCmpt$project$hasC.y;\n    var markType = model.mark;\n\n    if (isPathMark(markType)) {\n      log.warn(log.message.nearestNotSupportForContinuous(markType));\n      return _marks;\n    }\n\n    var cellDef = {\n      name: model.getName(VORONOI),\n      type: 'path',\n      interactive: true,\n      from: {\n        data: model.getName('marks')\n      },\n      encode: {\n        update: Object.assign({\n          fill: {\n            value: 'transparent'\n          },\n          strokeWidth: {\n            value: 0.35\n          },\n          stroke: {\n            value: 'transparent'\n          },\n          isVoronoi: {\n            value: true\n          }\n        }, tooltip(model, {\n          reactiveGeom: true\n        }))\n      },\n      transform: [{\n        type: 'voronoi',\n        x: {\n          expr: x || !y ? 'datum.datum.x || 0' : '0'\n        },\n        y: {\n          expr: y || !x ? 'datum.datum.y || 0' : '0'\n        },\n        size: [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')]\n      }]\n    };\n    var index = 0;\n    var exists = false;\n\n    _marks.forEach(function (mark, i) {\n      var _a;\n\n      var name = (_a = mark.name, _a !== null && _a !== void 0 ? _a : '');\n\n      if (name === model.component.mark[0].name) {\n        index = i;\n      } else if (name.indexOf(VORONOI) >= 0) {\n        exists = true;\n      }\n    });\n\n    if (!exists) {\n      _marks.splice(index + 1, 0, cellDef);\n    }\n\n    return _marks;\n  }\n};\nexport default nearest;","map":null,"metadata":{},"sourceType":"module"}