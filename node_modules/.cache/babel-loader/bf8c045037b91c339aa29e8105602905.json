{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { __rest } from \"tslib\";\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { forEachSelection, MODIFY, STORE, unitName, VL_SELECTION_RESOLVE, TUPLE } from '.';\nimport { dateTimeExpr, isDateTime } from '../../datetime';\nimport { keys, varName } from '../../util';\nimport { isUnitModel } from '../model';\nimport { forEachTransform } from './transforms/transforms';\nimport { parseSelectionBinExtent } from './parse';\nexport function assembleInit(init) {\n  var isExpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n\n  if (isArray(init)) {\n    var assembled = init.map(function (v) {\n      return assembleInit(v, isExpr, wrap);\n    });\n    return isExpr ? \"[\".concat(assembled.join(', '), \"]\") : assembled;\n  } else if (isDateTime(init)) {\n    return wrap(dateTimeExpr(init, false, !isExpr));\n  }\n\n  return isExpr ? wrap(JSON.stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n  forEachSelection(model, function (selCmpt, selCompiler) {\n    var _signals;\n\n    var name = selCmpt.name;\n    var modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n\n    (_signals = signals).push.apply(_signals, _toConsumableArray(selCompiler.signals(model, selCmpt)));\n\n    forEachTransform(selCmpt, function (txCompiler) {\n      if (txCompiler.signals) {\n        signals = txCompiler.signals(model, selCmpt, signals);\n      }\n\n      if (txCompiler.modifyExpr) {\n        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n      }\n    });\n    signals.push({\n      name: name + MODIFY,\n      on: [{\n        events: {\n          signal: selCmpt.name + TUPLE\n        },\n        update: \"modify(\".concat(stringValue(selCmpt.name + STORE), \", \").concat(modifyExpr, \")\")\n      }]\n    });\n  });\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    var name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('mousemove', 'scope'),\n        update: \"isTuple(facet) ? facet : group(\".concat(name, \").datum\")\n      }]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n  var hasSelections = false;\n  forEachSelection(model, function (selCmpt, selCompiler) {\n    var name = selCmpt.name;\n    var store = stringValue(name + STORE);\n    var hasSg = signals.filter(function (s) {\n      return s.name === name;\n    });\n\n    if (hasSg.length === 0) {\n      var resolve = selCmpt.resolve === 'global' ? 'union' : selCmpt.resolve;\n      var isMulti = selCmpt.type === 'multi' ? ', true)' : ')';\n      signals.push({\n        name: selCmpt.name,\n        update: \"\".concat(VL_SELECTION_RESOLVE, \"(\").concat(store, \", \").concat(stringValue(resolve)).concat(isMulti)\n      });\n    }\n\n    hasSelections = true;\n\n    if (selCompiler.topLevelSignals) {\n      signals = selCompiler.topLevelSignals(model, selCmpt, signals);\n    }\n\n    forEachTransform(selCmpt, function (txCompiler) {\n      if (txCompiler.topLevelSignals) {\n        signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n      }\n    });\n  });\n\n  if (hasSelections) {\n    var hasUnit = signals.filter(function (s) {\n      return s.name === 'unit';\n    });\n\n    if (hasUnit.length === 0) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{\n          events: 'mousemove',\n          update: 'isTuple(group()) ? group() : unit'\n        }]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n  var dataCopy = _toConsumableArray(data);\n\n  forEachSelection(model, function (selCmpt) {\n    var init = {\n      name: selCmpt.name + STORE\n    };\n\n    if (selCmpt.init) {\n      var fields = selCmpt.project.items.map(function (proj) {\n        var signals = proj.signals,\n            rest = __rest(proj, [\"signals\"]);\n\n        return rest;\n      });\n      var insert = selCmpt.init.map(function (i) {\n        return assembleInit(i, false);\n      });\n      init.values = selCmpt.type === 'interval' ? [{\n        unit: unitName(model, {\n          escape: false\n        }),\n        fields: fields,\n        values: insert\n      }] : insert.map(function (i) {\n        return {\n          unit: unitName(model, {\n            escape: false\n          }),\n          fields: fields,\n          values: i\n        };\n      });\n    }\n\n    var contains = dataCopy.filter(function (d) {\n      return d.name === selCmpt.name + STORE;\n    });\n\n    if (!contains.length) {\n      dataCopy.push(init);\n    }\n  });\n  return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n  forEachSelection(model, function (selCmpt, selCompiler) {\n    marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;\n    forEachTransform(selCmpt, function (txCompiler) {\n      if (txCompiler.marks) {\n        marks = txCompiler.marks(model, selCmpt, marks);\n      }\n    });\n  });\n  return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = model.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var child = _step.value;\n\n      if (isUnitModel(child)) {\n        marks = assembleUnitSelectionMarks(child, marks);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return marks;\n}\nexport function assembleSelectionScaleDomain(model, extent) {\n  var name = extent.selection;\n  var selCmpt = model.getSelectionComponent(name, varName(name));\n  return {\n    signal: parseSelectionBinExtent(selCmpt, extent)\n  };\n}\n\nfunction cleanupEmptyOnArray(signals) {\n  return signals.map(function (s) {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}