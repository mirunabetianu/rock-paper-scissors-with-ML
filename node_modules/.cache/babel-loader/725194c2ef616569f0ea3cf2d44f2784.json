{"ast":null,"code":"import _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { uniqueId } from '../../util';\n/**\n * A node in the dataflow tree.\n */\n\nexport var DataFlowNode =\n/*#__PURE__*/\nfunction () {\n  function DataFlowNode(parent, debugName) {\n    _classCallCheck(this, DataFlowNode);\n\n    this.debugName = debugName;\n    this._children = [];\n    this._parent = null;\n\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n\n\n  _createClass(DataFlowNode, [{\n    key: \"clone\",\n    value: function clone() {\n      throw new Error('Cannot clone node');\n    }\n  }, {\n    key: \"numChildren\",\n    value: function numChildren() {\n      return this._children.length;\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(child, loc) {\n      // do not add the same child twice\n      if (this._children.indexOf(child) > -1) {\n        console.warn('Attempt to add the same child twice.');\n        return;\n      }\n\n      if (loc !== undefined) {\n        this._children.splice(loc, 0, child);\n      } else {\n        this._children.push(child);\n      }\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(oldChild) {\n      var loc = this._children.indexOf(oldChild);\n\n      this._children.splice(loc, 1);\n\n      return loc;\n    }\n    /**\n     * Remove node from the dataflow.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var loc = this._parent.removeChild(this);\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n          // do not use the set method because we want to insert at a particular location\n          child._parent = this._parent;\n\n          this._parent.addChild(child, loc++);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Insert another node as a parent of this node.\n     */\n\n  }, {\n    key: \"insertAsParentOf\",\n    value: function insertAsParentOf(other) {\n      var parent = other.parent;\n      parent.removeChild(this);\n      this.parent = parent;\n      other.parent = this;\n    }\n  }, {\n    key: \"swapWithParent\",\n    value: function swapWithParent() {\n      var parent = this._parent;\n      var newParent = parent.parent; // reconnect the children\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var child = _step2.value;\n          child.parent = parent;\n        } // remove old links\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this._children = []; // equivalent to removing every child link one by one\n\n      parent.removeChild(this);\n      parent.parent.removeChild(parent); // swap two nodes\n\n      this.parent = newParent;\n      parent.parent = this;\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent;\n    }\n    /**\n     * Set the parent of the node and also add this node to the parent's children.\n     */\n    ,\n    set: function set(parent) {\n      this._parent = parent;\n\n      if (parent) {\n        parent.addChild(this);\n      }\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this._children;\n    }\n  }]);\n\n  return DataFlowNode;\n}();\nexport var OutputNode =\n/*#__PURE__*/\nfunction (_DataFlowNode) {\n  _inherits(OutputNode, _DataFlowNode);\n\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  function OutputNode(parent, source, type, refCounts) {\n    var _this;\n\n    _classCallCheck(this, OutputNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OutputNode).call(this, parent, source));\n    _this.type = type;\n    _this.refCounts = refCounts;\n    _this._source = _this._name = source;\n\n    if (_this.refCounts && !(_this._name in _this.refCounts)) {\n      _this.refCounts[_this._name] = 0;\n    }\n\n    return _this;\n  }\n\n  _createClass(OutputNode, [{\n    key: \"clone\",\n    value: function clone() {\n      var cloneObj = new this.constructor();\n      cloneObj.debugName = 'clone_' + this.debugName;\n      cloneObj._source = this._source;\n      cloneObj._name = 'clone_' + this._name;\n      cloneObj.type = this.type;\n      cloneObj.refCounts = this.refCounts;\n      cloneObj.refCounts[cloneObj._name] = 0;\n      return cloneObj;\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set();\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set();\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      if (this._hash === undefined) {\n        this._hash = \"Output \".concat(uniqueId());\n      }\n\n      return this._hash;\n    }\n    /**\n     * Request the datasource name and increase the ref counter.\n     *\n     * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n     * It is crucial to request the name from an output node to mark it as a required node.\n     * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n     *\n     * In the assemble phase, this will return the correct name.\n     */\n\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      this.refCounts[this._name]++;\n      return this._source;\n    }\n  }, {\n    key: \"isRequired\",\n    value: function isRequired() {\n      return !!this.refCounts[this._name];\n    }\n  }, {\n    key: \"setSource\",\n    value: function setSource(source) {\n      this._source = source;\n    }\n  }]);\n\n  return OutputNode;\n}(DataFlowNode);","map":null,"metadata":{},"sourceType":"module"}