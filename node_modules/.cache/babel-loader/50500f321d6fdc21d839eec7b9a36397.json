{"ast":null,"code":"/**\n * Utility files for producing Vega ValueRef for marks\n */\nimport { isFunction, isString } from 'vega-util';\nimport { isCountingAggregateOp } from '../../../aggregate';\nimport { isBinned, isBinning } from '../../../bin';\nimport { getMainRangeChannel, X, X2, Y, Y2 } from '../../../channel';\nimport { binRequiresRange, getBand, isFieldDef, isPositionFieldDef, isTypedFieldDef, isValueDef, vgField } from '../../../channeldef';\nimport * as log from '../../../log';\nimport { isPathMark } from '../../../mark';\nimport { fieldValidPredicate } from '../../../predicate';\nimport { hasDiscreteDomain, isContinuousToContinuous } from '../../../scale';\nimport { QUANTITATIVE, TEMPORAL } from '../../../type';\nimport { contains, getFirstDefined } from '../../../util';\nexport function midPointRefWithPositionInvalidTest(params) {\n  var channel = params.channel,\n      channelDef = params.channelDef,\n      markDef = params.markDef,\n      scale = params.scale;\n  var ref = midPoint(params); // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n\n  if ( // Only this for field def without counting aggregate (as count wouldn't be null)\n  isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && // and only for continuous scale without zero (otherwise, null / invalid will be interpreted as zero, which doesn't cause layout problem)\n  scale && isContinuousToContinuous(scale.get('type')) && scale.get('zero') === false) {\n    return wrapPositionInvalidTest({\n      fieldDef: channelDef,\n      channel: channel,\n      markDef: markDef,\n      ref: ref\n    });\n  }\n\n  return ref;\n}\nexport function wrapPositionInvalidTest(_ref) {\n  var fieldDef = _ref.fieldDef,\n      channel = _ref.channel,\n      markDef = _ref.markDef,\n      ref = _ref.ref;\n\n  if (!isPathMark(markDef.type)) {\n    // Only do this for non-path mark (as path marks will already use \"defined\" to skip points)\n    return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n  }\n\n  return ref;\n}\nexport function fieldInvalidTestValueRef(fieldDef, channel) {\n  var test = fieldInvalidPredicate(fieldDef, true);\n  var mainChannel = getMainRangeChannel(channel);\n  var zeroValueRef = mainChannel === 'x' ? {\n    value: 0\n  } : {\n    field: {\n      group: 'height'\n    }\n  };\n  return Object.assign({\n    test: test\n  }, zeroValueRef);\n}\nexport function fieldInvalidPredicate(field) {\n  var invalid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return fieldValidPredicate(isString(field) ? field : vgField(field, {\n    expr: 'datum'\n  }), !invalid);\n}\nexport function fieldRef(fieldDef, scaleName, opt, encode) {\n  var ref = Object.assign(Object.assign({}, scaleName ? {\n    scale: scaleName\n  } : {}), {\n    field: vgField(fieldDef, opt)\n  });\n\n  if (encode) {\n    var offset = encode.offset,\n        band = encode.band;\n    return Object.assign(Object.assign(Object.assign({}, ref), offset ? {\n      offset: offset\n    } : {}), band ? {\n      band: band\n    } : {});\n  }\n\n  return ref;\n}\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\n\nexport function interpolatedSignalRef(_ref2) {\n  var scaleName = _ref2.scaleName,\n      fieldDef = _ref2.fieldDef,\n      fieldDef2 = _ref2.fieldDef2,\n      offset = _ref2.offset,\n      startSuffix = _ref2.startSuffix,\n      _ref2$band = _ref2.band,\n      band = _ref2$band === void 0 ? 0.5 : _ref2$band;\n  var expr = 0 < band && band < 1 ? 'datum' : undefined;\n  var start = vgField(fieldDef, {\n    expr: expr,\n    suffix: startSuffix\n  });\n  var end = fieldDef2 !== undefined ? vgField(fieldDef2, {\n    expr: expr\n  }) : vgField(fieldDef, {\n    suffix: 'end',\n    expr: expr\n  });\n\n  if (band === 0) {\n    return Object.assign({\n      scale: scaleName,\n      field: start\n    }, offset ? {\n      offset: offset\n    } : {});\n  } else if (band === 1) {\n    return Object.assign({\n      scale: scaleName,\n      field: end\n    }, offset ? {\n      offset: offset\n    } : {});\n  } else {\n    var datum = \"\".concat(band, \" * \").concat(start, \" + \").concat(1 - band, \" * \").concat(end);\n    return Object.assign({\n      signal: \"scale(\\\"\".concat(scaleName, \"\\\", \").concat(datum, \")\")\n    }, offset ? {\n      offset: offset\n    } : {});\n  }\n}\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\n\nexport function midPoint(_ref3) {\n  var channel = _ref3.channel,\n      channelDef = _ref3.channelDef,\n      channel2Def = _ref3.channel2Def,\n      markDef = _ref3.markDef,\n      config = _ref3.config,\n      scaleName = _ref3.scaleName,\n      scale = _ref3.scale,\n      stack = _ref3.stack,\n      offset = _ref3.offset,\n      defaultRef = _ref3.defaultRef;\n\n  // TODO: datum support\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldDef(channelDef)) {\n      if (isTypedFieldDef(channelDef)) {\n        var band = getBand(channel, channelDef, channel2Def, markDef, config, {\n          isMidPoint: true\n        });\n\n        if (isBinning(channelDef.bin) || band && channelDef.timeUnit) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (contains([X, Y], channel) && contains([QUANTITATIVE, TEMPORAL], channelDef.type)) {\n            if (stack && stack.impute) {\n              // For stack, we computed bin_mid so we can impute.\n              return fieldRef(channelDef, scaleName, {\n                binSuffix: 'mid'\n              }, {\n                offset: offset\n              });\n            } // For non-stack, we can just calculate bin mid on the fly using signal.\n\n\n            return interpolatedSignalRef({\n              scaleName: scaleName,\n              fieldDef: channelDef,\n              band: band,\n              offset: offset\n            });\n          }\n\n          return fieldRef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {\n            binSuffix: 'range'\n          } : {}, {\n            offset: offset\n          });\n        } else if (isBinned(channelDef.bin)) {\n          if (isFieldDef(channel2Def)) {\n            return interpolatedSignalRef({\n              scaleName: scaleName,\n              fieldDef: channelDef,\n              fieldDef2: channel2Def,\n              band: band,\n              offset: offset\n            });\n          } else {\n            var channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n\n      if (scale) {\n        var scaleType = scale.get('type');\n\n        if (hasDiscreteDomain(scaleType)) {\n          if (scaleType === 'band') {\n            // For band, to get mid point, need to offset by half of the band\n            var _band = getFirstDefined(isPositionFieldDef(channelDef) ? channelDef.band : undefined, 0.5);\n\n            return fieldRef(channelDef, scaleName, {\n              binSuffix: 'range'\n            }, {\n              band: _band,\n              offset: offset\n            });\n          }\n\n          return fieldRef(channelDef, scaleName, {\n            binSuffix: 'range'\n          }, {\n            offset: offset\n          });\n        }\n      }\n\n      return fieldRef(channelDef, scaleName, {}, {\n        offset: offset\n      }); // no need for bin suffix\n    } else if (isValueDef(channelDef)) {\n      var value = channelDef.value;\n      var offsetMixins = offset ? {\n        offset: offset\n      } : {};\n      return Object.assign(Object.assign({}, widthHeightValueRef(channel, value)), offsetMixins);\n    } // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n\n  }\n\n  var ref = isFunction(defaultRef) ? Object.assign(Object.assign({}, defaultRef()), offset ? {\n    offset: offset\n  } : {}) : defaultRef;\n\n  if (ref) {\n    // for non-position, ref could be undefined.\n    return Object.assign(Object.assign({}, ref), offset ? {\n      offset: offset\n    } : {});\n  }\n\n  return ref;\n}\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\n\nexport function widthHeightValueRef(channel, value) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {\n      field: {\n        group: 'width'\n      }\n    };\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {\n      field: {\n        group: 'height'\n      }\n    };\n  }\n\n  return {\n    value: value\n  };\n}","map":null,"metadata":{},"sourceType":"module"}