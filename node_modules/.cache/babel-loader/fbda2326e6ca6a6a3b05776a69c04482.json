{"ast":null,"code":"import { Index, Label, Offset, Size, Value, zero, one, Skip, GuideLabelStyle, LegendScales } from './constants';\nimport guideGroup from './guide-group';\nimport guideMark from './guide-mark';\nimport { lookup } from './guide-util';\nimport { SymbolMark, TextMark } from '../marks/marktypes';\nimport { ScopeRole, LegendSymbolRole, LegendLabelRole } from '../marks/roles';\nimport { addEncoders, encoder, extendEncode } from '../encode/encode-util'; // userEncode is top-level, includes entries, symbols, labels\n\nexport default function (spec, config, userEncode, dataRef, columns) {\n  var _ = lookup(spec, config),\n      entries = userEncode.entries,\n      interactive = !!(entries && entries.interactive),\n      name = entries ? entries.name : undefined,\n      height = _('clipHeight'),\n      symbolOffset = _('symbolOffset'),\n      valueRef = {\n    data: 'value'\n  },\n      encode = {},\n      xSignal = \"\".concat(columns, \" ? datum.\").concat(Offset, \" : datum.\").concat(Size),\n      yEncode = height ? encoder(height) : {\n    field: Size\n  },\n      index = \"datum.\".concat(Index),\n      ncols = \"max(1, \".concat(columns, \")\"),\n      enter,\n      update,\n      labelOffset,\n      symbols,\n      labels,\n      nrows,\n      sort;\n\n  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        mult: 0.5,\n        offset: symbolOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  var baseFill = null,\n      baseStroke = null;\n\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill: _('symbolFillColor', baseFill),\n    shape: _('symbolType'),\n    size: _('symbolSize'),\n    stroke: _('symbolStrokeColor', baseStroke),\n    strokeDash: _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth: _('symbolStrokeWidth')\n  }, {\n    // update\n    opacity: _('symbolOpacity')\n  });\n  LegendScales.forEach(function (scale) {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {\n        scale: spec[scale],\n        field: Value\n      };\n    }\n  });\n  symbols = guideMark(SymbolMark, LegendSymbolRole, null, Value, valueRef, encode, userEncode.symbols);\n  if (height) symbols.clip = true; // -- LEGEND LABELS --\n\n  labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {\n        signal: xSignal,\n        offset: labelOffset\n      },\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {\n        field: Label\n      },\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncoders(encode, {\n    align: _('labelAlign'),\n    baseline: _('labelBaseline'),\n    fill: _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font: _('labelFont'),\n    fontSize: _('labelFontSize'),\n    fontStyle: _('labelFontStyle'),\n    fontWeight: _('labelFontWeight'),\n    limit: _('labelLimit')\n  });\n  labels = guideMark(TextMark, LegendLabelRole, GuideLabelStyle, Value, valueRef, encode, userEncode.labels); // -- LEGEND ENTRY GROUPS --\n\n  encode = {\n    enter: {\n      noBound: {\n        value: !height\n      },\n      // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      row: {\n        signal: null\n      },\n      column: {\n        signal: null\n      }\n    }\n  }; // annotate and sort groups to ensure correct ordering\n\n  if (_.isVertical(true)) {\n    nrows = \"ceil(item.mark.items.length / \".concat(ncols, \")\");\n    update.row.signal = \"\".concat(index, \"%\").concat(nrows);\n    update.column.signal = \"floor(\".concat(index, \" / \").concat(nrows, \")\");\n    sort = {\n      field: ['row', index]\n    };\n  } else {\n    update.row.signal = \"floor(\".concat(index, \" / \").concat(ncols, \")\");\n    update.column.signal = \"\".concat(index, \" % \").concat(ncols);\n    sort = {\n      field: index\n    };\n  } // handle zero column case (implies infinite columns)\n\n\n  update.column.signal = \"\".concat(columns, \"?\").concat(update.column.signal, \":\").concat(index); // facet legend entries into sub-groups\n\n  dataRef = {\n    facet: {\n      data: dataRef,\n      name: 'value',\n      groupby: Index\n    }\n  };\n  spec = guideGroup(ScopeRole, null, name, dataRef, interactive, extendEncode(encode, entries, Skip), [symbols, labels]);\n  spec.sort = sort;\n  return spec;\n}\nexport function legendSymbolLayout(spec, config) {\n  var _ = lookup(spec, config); // layout parameters for legend entries\n\n\n  return {\n    align: _('gridAlign'),\n    columns: _.entryColumns(),\n    center: {\n      row: true,\n      column: false\n    },\n    padding: {\n      row: _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}