{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { FACET_CHANNELS } from '../../channel';\nimport { title as fieldDefTitle } from '../../channeldef';\nimport { contains, getFirstDefined } from '../../util';\nimport { assembleAxis } from '../axis/assemble';\nimport { parseGuideResolve } from '../resolve';\nimport { getHeaderProperty } from './common';\nimport { isArray } from 'vega-util';\nexport function getHeaderType(orient) {\n  if (orient === 'top' || orient === 'left') {\n    return 'header';\n  }\n\n  return 'footer';\n}\nexport function parseFacetHeaders(model) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = FACET_CHANNELS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var channel = _step.value;\n      parseFacetHeader(model, channel);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\n\nfunction parseFacetHeader(model, channel) {\n  var _a;\n\n  if (model.channelHasField(channel)) {\n    var fieldDef = model.facet[channel];\n    var titleConfig = getHeaderProperty('title', null, model.config, channel);\n    var title = fieldDefTitle(fieldDef, model.config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n\n    if (model.child.component.layoutHeaders[channel].title) {\n      // TODO: better handle multiline titles\n      title = isArray(title) ? title.join(', ') : title; // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n\n      title += ' / ' + model.child.component.layoutHeaders[channel].title;\n      model.child.component.layoutHeaders[channel].title = null;\n    }\n\n    var labelOrient = getHeaderProperty('labelOrient', fieldDef, model.config, channel);\n    var header = (_a = fieldDef.header, _a !== null && _a !== void 0 ? _a : {});\n    var labels = getFirstDefined(header.labels, true);\n    var headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n    model.component.layoutHeaders[channel] = _defineProperty({\n      title: title,\n      facetFieldDef: fieldDef\n    }, headerType, channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]);\n  }\n}\n\nfunction makeHeaderComponent(model, channel, labels) {\n  var sizeType = channel === 'row' ? 'height' : 'width';\n  return {\n    labels: labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\n\nfunction mergeChildAxis(model, channel) {\n  var _a;\n\n  var child = model.child;\n\n  if (child.component.axes[channel]) {\n    var _model$component = model.component,\n        layoutHeaders = _model$component.layoutHeaders,\n        resolve = _model$component.resolve;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      var headerChannel = channel === 'x' ? 'column' : 'row';\n      var layoutHeader = layoutHeaders[headerChannel];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = child.component.axes[channel][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var axisComponent = _step2.value;\n          var headerType = getHeaderType(axisComponent.get('orient'));\n          layoutHeader[headerType] = (_a = layoutHeader[headerType], _a !== null && _a !== void 0 ? _a : [makeHeaderComponent(model, headerChannel, false)]); // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n\n          var mainAxis = assembleAxis(axisComponent, 'main', model.config, {\n            header: true\n          }); // LayoutHeader no longer keep track of property precedence, thus let's combine.\n\n          layoutHeader[headerType][0].axes.push(mainAxis);\n          axisComponent.mainExtracted = true;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    } else {// Otherwise do nothing for independent axes\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}