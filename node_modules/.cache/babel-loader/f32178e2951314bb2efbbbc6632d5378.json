{"ast":null,"code":"import Marks from './marks/index';\nimport { error } from 'vega-util';\nimport Bounds from './Bounds';\nexport function intersect(scene, bounds, filter) {\n  var hits = [],\n      // intersection results\n  box = new Bounds().union(bounds),\n      // defensive copy\n  type = scene.marktype;\n  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : error('Intersect scene must be mark node or group item.');\n}\n\nfunction intersectMark(mark, box, filter, hits) {\n  if (visitMark(mark, box, filter)) {\n    var items = mark.items,\n        type = mark.marktype,\n        n = items.length;\n    var i = 0;\n\n    if (type === 'group') {\n      for (; i < n; ++i) {\n        intersectGroup(items[i], box, filter, hits);\n      }\n    } else {\n      for (var test = Marks[type].isect; i < n; ++i) {\n        var item = items[i];\n        if (intersectItem(item, box, test)) hits.push(item);\n      }\n    }\n  }\n\n  return hits;\n}\n\nfunction visitMark(mark, box, filter) {\n  // process if bounds intersect and if\n  // (1) mark is a group mark (so we must recurse), or\n  // (2) mark is interactive and passes filter\n  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));\n}\n\nfunction intersectGroup(group, box, filter, hits) {\n  // test intersect against group\n  // skip groups by default unless filter says otherwise\n  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {\n    hits.push(group);\n  } // recursively test children marks\n  // translate box to group coordinate space\n\n\n  var marks = group.items,\n      n = marks && marks.length;\n\n  if (n) {\n    var x = group.x || 0,\n        y = group.y || 0;\n    box.translate(-x, -y);\n\n    for (var i = 0; i < n; ++i) {\n      intersectMark(marks[i], box, filter, hits);\n    }\n\n    box.translate(x, y);\n  }\n\n  return hits;\n}\n\nfunction intersectItem(item, box, test) {\n  // test bounds enclosure, bounds intersection, then detailed test\n  var bounds = item.bounds;\n  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);\n}","map":null,"metadata":{},"sourceType":"module"}