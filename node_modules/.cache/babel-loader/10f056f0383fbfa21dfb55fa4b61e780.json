{"ast":null,"code":"import _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { isNumber, isString } from 'vega-util';\nimport { isMinMaxOp } from '../../aggregate';\nimport { getMainRangeChannel } from '../../channel';\nimport { isFieldDef, isScaleFieldDef, isTimeFormatFieldDef, isTypedFieldDef } from '../../channeldef';\nimport { isGenerator } from '../../data';\nimport { isDateTime } from '../../datetime';\nimport * as log from '../../log';\nimport { forEachLeaf } from '../../logical';\nimport { isPathMark } from '../../mark';\nimport { isFieldEqualPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate } from '../../predicate';\nimport { isSortField } from '../../sort';\nimport { accessPathDepth, accessPathWithDatum, duplicate, hash as _hash, keys, removePathFromField } from '../../util';\nimport { isFacetModel, isUnitModel } from '../model';\nimport { Split } from '../split';\nimport { DataFlowNode } from './dataflow';\n/**\n * Remove quotes from a string.\n */\n\nfunction unquote(pattern) {\n  if (pattern[0] === \"'\" && pattern[pattern.length - 1] === \"'\" || pattern[0] === '\"' && pattern[pattern.length - 1] === '\"') {\n    return pattern.slice(1, -1);\n  }\n\n  return pattern;\n}\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\n\n\nfunction parseExpression(field, parse) {\n  var f = accessPathWithDatum(field);\n\n  if (parse === 'number') {\n    return \"toNumber(\".concat(f, \")\");\n  } else if (parse === 'boolean') {\n    return \"toBoolean(\".concat(f, \")\");\n  } else if (parse === 'string') {\n    return \"toString(\".concat(f, \")\");\n  } else if (parse === 'date') {\n    return \"toDate(\".concat(f, \")\");\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.indexOf('date:') === 0) {\n    var specifier = unquote(parse.slice(5, parse.length));\n    return \"timeParse(\".concat(f, \",'\").concat(specifier, \"')\");\n  } else if (parse.indexOf('utc:') === 0) {\n    var _specifier = unquote(parse.slice(4, parse.length));\n\n    return \"utcParse(\".concat(f, \",'\").concat(_specifier, \"')\");\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport function getImplicitFromFilterTransform(transform) {\n  var implicit = {};\n  forEachLeaf(transform.filter, function (filter) {\n    var _a;\n\n    if (isFieldPredicate(filter)) {\n      // Automatically add a parse node for filters with filter objects\n      var val = null; // For EqualFilter, just use the equal property.\n      // For RangeFilter and OneOfFilter, all array members should have\n      // the same type, so we only use the first one.\n\n      if (isFieldEqualPredicate(filter)) {\n        val = filter.equal;\n      } else if (isFieldRangePredicate(filter)) {\n        val = filter.range[0];\n      } else if (isFieldOneOfPredicate(filter)) {\n        val = (_a = filter.oneOf, _a !== null && _a !== void 0 ? _a : filter['in'])[0];\n      } // else -- for filter expression, we can't infer anything\n\n\n      if (val) {\n        if (isDateTime(val)) {\n          implicit[filter.field] = 'date';\n        } else if (isNumber(val)) {\n          implicit[filter.field] = 'number';\n        } else if (isString(val)) {\n          implicit[filter.field] = 'string';\n        }\n      }\n\n      if (filter.timeUnit) {\n        implicit[filter.field] = 'date';\n      }\n    }\n  });\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\n\nexport function getImplicitFromEncoding(model) {\n  var implicit = {};\n\n  function add(fieldDef) {\n    if (isTimeFormatFieldDef(fieldDef)) {\n      implicit[fieldDef.field] = 'date';\n    } else if (fieldDef.type === 'quantitative' && isMinMaxOp(fieldDef.aggregate) // we need to parse numbers to support correct min and max\n    ) {\n        implicit[fieldDef.field] = 'number';\n      } else if (accessPathDepth(fieldDef.field) > 1) {\n      // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n      // (Parsing numbers / dates already flattens numeric and temporal fields.)\n      if (!(fieldDef.field in implicit)) {\n        implicit[fieldDef.field] = 'flatten';\n      }\n    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {\n      // Flatten fields that we sort by but that are not otherwise flattened.\n      if (!(fieldDef.sort.field in implicit)) {\n        implicit[fieldDef.sort.field] = 'flatten';\n      }\n    }\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    // Parse encoded fields\n    model.forEachFieldDef(function (fieldDef, channel) {\n      if (isTypedFieldDef(fieldDef)) {\n        add(fieldDef);\n      } else {\n        var mainChannel = getMainRangeChannel(channel);\n        var mainFieldDef = model.fieldDef(mainChannel);\n        add(Object.assign(Object.assign({}, fieldDef), {\n          type: mainFieldDef.type\n        }));\n      }\n    });\n  } // Parse quantitative dimension fields of path marks as numbers so that we sort them correctly.\n\n\n  if (isUnitModel(model)) {\n    var mark = model.mark,\n        markDef = model.markDef,\n        encoding = model.encoding;\n\n    if (isPathMark(mark) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)\n    !model.encoding.order) {\n      var dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n      var dimensionChannelDef = encoding[dimensionChannel];\n\n      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === 'quantitative' && !(dimensionChannelDef.field in implicit)) {\n        implicit[dimensionChannelDef.field] = 'number';\n      }\n    }\n  }\n\n  return implicit;\n}\n/**\n * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n */\n\nexport function getImplicitFromSelection(model) {\n  var implicit = {};\n\n  if (isUnitModel(model) && model.component.selection) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = keys(model.component.selection)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var name = _step.value;\n        var selCmpt = model.component.selection[name];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = selCmpt.project.items[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var proj = _step2.value;\n\n            if (!proj.channel && accessPathDepth(proj.field) > 1) {\n              implicit[proj.field] = 'flatten';\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return implicit;\n}\nexport var ParseNode =\n/*#__PURE__*/\nfunction (_DataFlowNode) {\n  _inherits(ParseNode, _DataFlowNode);\n\n  function ParseNode(parent, parse) {\n    var _this;\n\n    _classCallCheck(this, ParseNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ParseNode).call(this, parent));\n    _this._parse = parse;\n    return _this;\n  }\n\n  _createClass(ParseNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new ParseNode(null, duplicate(this._parse));\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"Parse \".concat(_hash(this._parse));\n    }\n    /**\n     * Creates a parse node from a data.format.parse and updates ancestorParse.\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      this._parse = Object.assign(Object.assign({}, this._parse), other.parse);\n      other.remove();\n    }\n    /**\n     * Assemble an object for Vega's format.parse property.\n     */\n\n  }, {\n    key: \"assembleFormatParse\",\n    value: function assembleFormatParse() {\n      var formatParse = {};\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = keys(this._parse)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var field = _step3.value;\n          var p = this._parse[field];\n\n          if (accessPathDepth(field) === 1) {\n            formatParse[field] = p;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return formatParse;\n    } // format parse depends and produces all fields in its parse\n\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(keys(this._parse));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(keys(this._parse));\n    }\n  }, {\n    key: \"assembleTransforms\",\n    value: function assembleTransforms() {\n      var _this2 = this;\n\n      var onlyNested = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return keys(this._parse).filter(function (field) {\n        return onlyNested ? accessPathDepth(field) > 1 : true;\n      }).map(function (field) {\n        var expr = parseExpression(field, _this2._parse[field]);\n\n        if (!expr) {\n          return null;\n        }\n\n        var formula = {\n          type: 'formula',\n          expr: expr,\n          as: removePathFromField(field) // Vega output is always flattened\n\n        };\n        return formula;\n      }).filter(function (t) {\n        return t !== null;\n      });\n    }\n  }, {\n    key: \"parse\",\n    get: function get() {\n      return this._parse;\n    }\n  }], [{\n    key: \"makeExplicit\",\n    value: function makeExplicit(parent, model, ancestorParse) {\n      // Custom parse\n      var explicit = {};\n      var data = model.data;\n\n      if (!isGenerator(data) && data && data.format && data.format.parse) {\n        explicit = data.format.parse;\n      }\n\n      return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n    }\n    /**\n     * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n     */\n\n  }, {\n    key: \"makeWithAncestors\",\n    value: function makeWithAncestors(parent, explicit, implicit, ancestorParse) {\n      // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = keys(implicit)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var field = _step4.value;\n          var parsedAs = ancestorParse.getWithExplicit(field);\n\n          if (parsedAs.value !== undefined) {\n            // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n            if (parsedAs.explicit || parsedAs.value === implicit[field] || parsedAs.value === 'derived' || implicit[field] === 'flatten') {\n              delete implicit[field];\n            } else {\n              log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = keys(explicit)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _field = _step5.value;\n\n          var _parsedAs = ancestorParse.get(_field);\n\n          if (_parsedAs !== undefined) {\n            // Don't parse a field again if it has been parsed with the same type already.\n            if (_parsedAs === explicit[_field]) {\n              delete explicit[_field];\n            } else {\n              log.warn(log.message.differentParse(_field, explicit[_field], _parsedAs));\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      var parse = new Split(explicit, implicit); // add the format parse from this model so that children don't parse the same field again\n\n      ancestorParse.copyAll(parse); // copy only non-null parses\n\n      var p = {};\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = keys(parse.combine())[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var key = _step6.value;\n          var val = parse.get(key);\n\n          if (val !== null) {\n            p[key] = val;\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (keys(p).length === 0 || ancestorParse.parseNothing) {\n        return null;\n      }\n\n      return new ParseNode(parent, p);\n    }\n  }]);\n\n  return ParseNode;\n}(DataFlowNode);","map":null,"metadata":{},"sourceType":"module"}