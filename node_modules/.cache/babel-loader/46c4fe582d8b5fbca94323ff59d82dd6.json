{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { hasOwnProperty, isString, stringValue } from 'vega-util';\nimport { STORE, forEachSelection } from '.';\nimport { duplicate, logicalExpr, varName } from '../../util';\nimport { OutputNode } from '../data/dataflow';\nimport { forEachTransform } from './transforms/transforms';\nimport { warn } from '../../log';\nimport { FilterNode } from '../data/filter';\nexport function parseUnitSelection(model, selDefs) {\n  var _a;\n\n  var selCmpts = {};\n  var selectionConfig = model.config.selection;\n\n  var _loop = function _loop(name) {\n    if (!hasOwnProperty(selDefs, name)) {\n      return \"continue\";\n    }\n\n    var selDef = duplicate(selDefs[name]);\n\n    var _b = selectionConfig[selDef.type],\n        fields = _b.fields,\n        encodings = _b.encodings,\n        cfg = __rest(_b, [\"fields\", \"encodings\"]); // Project transform applies its defaults.\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n\n\n    for (var key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if (key === 'encodings' && selDef.fields || key === 'fields' && selDef.encodings) {\n        continue;\n      }\n\n      if (key === 'mark') {\n        selDef[key] = Object.assign(Object.assign({}, cfg[key]), selDef[key]);\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = (_a = cfg[key], _a !== null && _a !== void 0 ? _a : selDef[key]);\n      }\n    }\n\n    var safeName = varName(name);\n    var selCmpt = selCmpts[safeName] = Object.assign(Object.assign({}, selDef), {\n      name: safeName,\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : duplicate(selDef.on)\n    });\n    forEachTransform(selCmpt, function (txCompiler) {\n      if (txCompiler.has(selCmpt) && txCompiler.parse) {\n        txCompiler.parse(model, selCmpt, selDef, selDefs[name]);\n      }\n    });\n  };\n\n  for (var name in selDefs) {\n    var _ret = _loop(name);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return selCmpts;\n}\nexport function parseSelectionPredicate(model, selections, dfnode) {\n  var datum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'datum';\n  var stores = [];\n\n  function expr(name) {\n    var vname = varName(name);\n    var selCmpt = model.getSelectionComponent(vname, name);\n    var store = stringValue(vname + STORE);\n\n    if (selCmpt.project.timeUnit) {\n      var child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;\n      var tunode = selCmpt.project.timeUnit.clone();\n\n      if (child.parent) {\n        tunode.insertAsParentOf(child);\n      } else {\n        child.parent = tunode;\n      }\n    }\n\n    if (selCmpt.empty !== 'none') {\n      stores.push(store);\n    }\n\n    return \"vlSelectionTest(\".concat(store, \", \").concat(datum) + (selCmpt.resolve === 'global' ? ')' : \", \".concat(stringValue(selCmpt.resolve), \")\"));\n  }\n\n  var predicateStr = logicalExpr(selections, expr);\n  return (stores.length ? '!(' + stores.map(function (s) {\n    return \"length(data(\".concat(s, \"))\");\n  }).join(' || ') + ') || ' : '') + \"(\".concat(predicateStr, \")\");\n}\nexport function parseSelectionBinExtent(selCmpt, extent) {\n  var encoding = extent['encoding'];\n  var field = extent['field'];\n\n  if (!encoding && !field) {\n    field = selCmpt.project.items[0].field;\n\n    if (selCmpt.project.items.length > 1) {\n      warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' + \"Using \\\"field\\\": \".concat(stringValue(field), \".\"));\n    }\n  } else if (encoding && !field) {\n    var encodings = selCmpt.project.items.filter(function (p) {\n      return p.channel === encoding;\n    });\n\n    if (!encodings.length || encodings.length > 1) {\n      field = selCmpt.project.items[0].field;\n      warn((!encodings.length ? 'No ' : 'Multiple ') + \"matching \".concat(stringValue(encoding), \" encoding found for selection \").concat(stringValue(extent.selection), \". \") + \"Using \\\"field\\\": \".concat(stringValue(field), \".\"));\n    } else {\n      field = encodings[0].field;\n    }\n  }\n\n  return \"\".concat(selCmpt.name, \"[\").concat(stringValue(field), \"]\");\n}\nexport function materializeSelections(model, main) {\n  forEachSelection(model, function (selCmpt) {\n    var selection = selCmpt.name;\n    var lookupName = model.getName(\"lookup_\".concat(selection));\n    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main, model, {\n      selection: selection\n    }), lookupName, 'lookup', model.component.data.outputNodeRefCounts);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}