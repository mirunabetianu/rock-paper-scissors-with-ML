{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { TUPLE } from '..';\nimport { varName } from '../../../util';\nimport { assembleInit } from '../assemble';\nimport nearest from './nearest';\nimport { TUPLE_FIELDS } from './project';\nimport { isLegendBinding } from '../../../selection';\nvar inputBindings = {\n  has: function has(selCmpt) {\n    return selCmpt.type === 'single' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind !== 'scales' && !isLegendBinding(selCmpt.bind);\n  },\n  parse: function parse(model, selCmpt, selDef, origDef) {\n    // Binding a selection to input widgets disables default direct manipulation interaction.\n    // A user can choose to re-enable it by explicitly specifying triggering input events.\n    if (!origDef.on) delete selCmpt.events;\n    if (!origDef.clear) delete selCmpt.clear;\n  },\n  topLevelSignals: function topLevelSignals(model, selCmpt, signals) {\n    var name = selCmpt.name;\n    var proj = selCmpt.project;\n    var bind = selCmpt.bind;\n    var init = selCmpt.init && selCmpt.init[0]; // Can only exist on single selections (one initial value).\n\n    var datum = nearest.has(selCmpt) ? '(item().isVoronoi ? datum.datum : datum)' : 'datum';\n    proj.items.forEach(function (p, i) {\n      var _a, _b;\n\n      var sgname = varName(\"\".concat(name, \"_\").concat(p.field));\n      var hasSignal = signals.filter(function (s) {\n        return s.name === sgname;\n      });\n\n      if (!hasSignal.length) {\n        signals.unshift(Object.assign(Object.assign({\n          name: sgname\n        }, init ? {\n          init: assembleInit(init[i])\n        } : {\n          value: null\n        }), {\n          on: selCmpt.events ? [{\n            events: selCmpt.events,\n            update: \"datum && item().mark.marktype !== 'group' ? \".concat(datum, \"[\").concat(stringValue(p.field), \"] : null\")\n          }] : [],\n          bind: (_b = (_a = bind[p.field], _a !== null && _a !== void 0 ? _a : bind[p.channel]), _b !== null && _b !== void 0 ? _b : bind)\n        }));\n      }\n    });\n    return signals;\n  },\n  signals: function signals(model, selCmpt, _signals) {\n    var name = selCmpt.name;\n    var proj = selCmpt.project;\n\n    var signal = _signals.filter(function (s) {\n      return s.name === name + TUPLE;\n    })[0];\n\n    var fields = name + TUPLE_FIELDS;\n    var values = proj.items.map(function (p) {\n      return varName(\"\".concat(name, \"_\").concat(p.field));\n    });\n    var valid = values.map(function (v) {\n      return \"\".concat(v, \" !== null\");\n    }).join(' && ');\n\n    if (values.length) {\n      signal.update = \"\".concat(valid, \" ? {fields: \").concat(fields, \", values: [\").concat(values.join(', '), \"]} : null\");\n    }\n\n    delete signal.value;\n    delete signal.on;\n    return _signals;\n  }\n};\nexport default inputBindings;","map":null,"metadata":{},"sourceType":"module"}