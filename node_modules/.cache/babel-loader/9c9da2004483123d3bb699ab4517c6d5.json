{"ast":null,"code":"import { ingest, tupleid, Transform } from 'vega-dataflow';\nimport { error, inherits } from 'vega-util';\n/**\n * Generate tuples representing links between tree nodes.\n * The resulting tuples will contain 'source' and 'target' fields,\n * which point to parent and child node tuples, respectively.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\n\nexport default function TreeLinks(params) {\n  Transform.call(this, [], params);\n}\nTreeLinks.Definition = {\n  \"type\": \"TreeLinks\",\n  \"metadata\": {\n    \"tree\": true,\n    \"generates\": true,\n    \"changes\": true\n  },\n  \"params\": []\n};\nvar prototype = inherits(TreeLinks, Transform);\n\nprototype.transform = function (_, pulse) {\n  var links = this.value,\n      tree = pulse.source && pulse.source.root,\n      out = pulse.fork(pulse.NO_SOURCE),\n      lut = {};\n  if (!tree) error('TreeLinks transform requires a tree data source.');\n\n  if (pulse.changed(pulse.ADD_REM)) {\n    // remove previous links\n    out.rem = links; // build lookup table of valid tuples\n\n    pulse.visit(pulse.SOURCE, function (t) {\n      lut[tupleid(t)] = 1;\n    }); // generate links for all edges incident on valid tuples\n\n    tree.each(function (node) {\n      var t = node.data,\n          p = node.parent && node.parent.data;\n\n      if (p && lut[tupleid(t)] && lut[tupleid(p)]) {\n        out.add.push(ingest({\n          source: p,\n          target: t\n        }));\n      }\n    });\n    this.value = out.add;\n  } else if (pulse.changed(pulse.MOD)) {\n    // build lookup table of modified tuples\n    pulse.visit(pulse.MOD, function (t) {\n      lut[tupleid(t)] = 1;\n    }); // gather links incident on modified tuples\n\n    links.forEach(function (link) {\n      if (lut[tupleid(link.source)] || lut[tupleid(link.target)]) {\n        out.mod.push(link);\n      }\n    });\n  }\n\n  return out;\n};","map":null,"metadata":{},"sourceType":"module"}