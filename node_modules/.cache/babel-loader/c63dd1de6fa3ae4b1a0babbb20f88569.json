{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { __rest } from \"tslib\";\nimport { array, isArray } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../../channel';\nimport * as log from '../../../log';\nimport { hasContinuousDomain } from '../../../scale';\nimport { hash, keys, varName, replacePathInField, duplicate } from '../../../util';\nimport { TimeUnitNode } from '../../data/timeunit';\nexport var TUPLE_FIELDS = '_tuple_fields';\nexport var SelectionProjectionComponent = function SelectionProjectionComponent() {\n  _classCallCheck(this, SelectionProjectionComponent);\n\n  for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n    items[_key] = arguments[_key];\n  }\n\n  this.items = items;\n  this.hasChannel = {};\n  this.hasField = {};\n};\nvar project = {\n  has: function has() {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n  parse: function parse(model, selCmpt, selDef) {\n    var _a, _b, _c;\n\n    var name = selCmpt.name;\n    var proj = (_a = selCmpt.project, _a !== null && _a !== void 0 ? _a : selCmpt.project = new SelectionProjectionComponent());\n    var parsed = {};\n    var timeUnits = {};\n    var signals = new Set();\n\n    var signalName = function signalName(p, range) {\n      var suffix = range === 'visual' ? p.channel : p.field;\n      var sg = varName(\"\".concat(name, \"_\").concat(suffix));\n\n      for (var counter = 1; signals.has(sg); counter++) {\n        sg = varName(\"\".concat(name, \"_\").concat(suffix, \"_\").concat(counter));\n      }\n\n      signals.add(sg);\n      return _defineProperty({}, range, sg);\n    }; // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    // Otherwise, use the default configuration.\n\n\n    if (!selDef.fields && !selDef.encodings) {\n      var cfg = model.config.selection[selDef.type];\n\n      if (selDef.init) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = array(selDef.init)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var init = _step.value;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = keys(init)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var key = _step2.value;\n\n                if (isSingleDefUnitChannel(key)) {\n                  (selDef.encodings || (selDef.encodings = [])).push(key);\n                } else {\n                  if (selDef.type === 'interval') {\n                    log.warn('Interval selections should be initialized using \"x\" and/or \"y\" keys.');\n                    selDef.encodings = cfg.encodings;\n                  } else {\n                    (selDef.fields || (selDef.fields = [])).push(key);\n                  }\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        selDef.encodings = cfg.encodings;\n        selDef.fields = cfg.fields;\n      }\n    } // TODO: find a possible channel mapping for these fields.\n\n\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = (_b = selDef.fields, _b !== null && _b !== void 0 ? _b : [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var field = _step3.value;\n        var p = {\n          type: 'E',\n          field: field\n        };\n        p.signals = Object.assign({}, signalName(p, 'data'));\n        proj.items.push(p);\n        proj.hasField[field] = p;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = (_c = selDef.encodings, _c !== null && _c !== void 0 ? _c : [])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var channel = _step4.value;\n        var fieldDef = model.fieldDef(channel);\n\n        if (fieldDef) {\n          var _field = fieldDef.field;\n\n          if (fieldDef.aggregate) {\n            log.warn(log.message.cannotProjectAggregate(channel, fieldDef.aggregate));\n            continue;\n          } else if (!_field) {\n            log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n            continue;\n          }\n\n          if (fieldDef.timeUnit) {\n            _field = model.vgField(channel); // Construct TimeUnitComponents which will be combined into a\n            // TimeUnitNode. This node may need to be inserted into the\n            // dataflow if the selection is used across views that do not\n            // have these time units defined.\n\n            var component = {\n              as: _field,\n              field: fieldDef.field,\n              timeUnit: fieldDef.timeUnit\n            };\n            timeUnits[hash(component)] = component;\n          } // Prevent duplicate projections on the same field.\n          // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n\n\n          if (!parsed[_field]) {\n            // Determine whether the tuple will store enumerated or ranged values.\n            // Interval selections store ranges for continuous scales, and enumerations otherwise.\n            // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n            var type = 'E';\n\n            if (selCmpt.type === 'interval') {\n              var scaleType = model.getScaleComponent(channel).get('type');\n\n              if (hasContinuousDomain(scaleType)) {\n                type = 'R';\n              }\n            } else if (fieldDef.bin) {\n              type = 'R-RE';\n            }\n\n            var _p = {\n              field: _field,\n              channel: channel,\n              type: type\n            };\n            _p.signals = Object.assign(Object.assign({}, signalName(_p, 'data')), signalName(_p, 'visual'));\n            proj.items.push(parsed[_field] = _p);\n            proj.hasField[_field] = proj.hasChannel[channel] = parsed[_field];\n          }\n        } else {\n          log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    if (selDef.init) {\n      var parseInit = function parseInit(i) {\n        return proj.items.map(function (p) {\n          return i[p.channel] !== undefined ? i[p.channel] : i[p.field];\n        });\n      };\n\n      if (selDef.type === 'interval') {\n        selCmpt.init = parseInit(selDef.init);\n      } else {\n        var _init = isArray(selDef.init) ? selDef.init : [selDef.init];\n\n        selCmpt.init = _init.map(parseInit);\n      }\n    }\n\n    if (keys(timeUnits).length > 0) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n  signals: function signals(model, selCmpt, allSignals) {\n    var name = selCmpt.name + TUPLE_FIELDS;\n    var hasSignal = allSignals.filter(function (s) {\n      return s.name === name;\n    });\n    return hasSignal.length > 0 ? allSignals : allSignals.concat({\n      name: name,\n      value: selCmpt.project.items.map(function (proj) {\n        var signals = proj.signals,\n            hasLegend = proj.hasLegend,\n            rest = __rest(proj, [\"signals\", \"hasLegend\"]);\n\n        var p = duplicate(rest);\n        p.field = replacePathInField(p.field);\n        return p;\n      })\n    });\n  }\n};\nexport default project;","map":null,"metadata":{},"sourceType":"module"}