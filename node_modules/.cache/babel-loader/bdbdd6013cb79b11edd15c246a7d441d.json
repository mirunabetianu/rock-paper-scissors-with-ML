{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { __rest } from \"tslib\";\nimport { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuous, isFieldDef } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined } from '../util';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n  var tooltip = oldEncoding.tooltip,\n      filteredEncoding = __rest(oldEncoding, [\"tooltip\"]);\n\n  if (!tooltip) {\n    return {\n      filteredEncoding: oldEncoding\n    };\n  }\n\n  var customTooltipWithAggregatedField;\n  var customTooltipWithoutAggregatedField;\n\n  if (isArray(tooltip)) {\n    tooltip.forEach(function (t) {\n      if (t.aggregate) {\n        if (!customTooltipWithAggregatedField) {\n          customTooltipWithAggregatedField = [];\n        }\n\n        customTooltipWithAggregatedField.push(t);\n      } else {\n        if (!customTooltipWithoutAggregatedField) {\n          customTooltipWithoutAggregatedField = [];\n        }\n\n        customTooltipWithoutAggregatedField.push(t);\n      }\n    });\n\n    if (customTooltipWithAggregatedField) {\n      filteredEncoding.tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if (tooltip['aggregate']) {\n      filteredEncoding.tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n\n  return {\n    customTooltipWithoutAggregatedField: customTooltipWithoutAggregatedField,\n    filteredEncoding: filteredEncoding\n  };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis) {\n  var withFieldName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {\n      tooltip: encodingWithoutContinuousAxis.tooltip\n    };\n  }\n\n  var fiveSummaryTooltip = tooltipSummary.map(function (_ref) {\n    var fieldPrefix = _ref.fieldPrefix,\n        titlePrefix = _ref.titlePrefix;\n    return {\n      field: fieldPrefix + continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type,\n      title: titlePrefix + (withFieldName ? ' of ' + continuousAxisChannelDef.field : '')\n    };\n  });\n  return {\n    tooltip: [].concat(_toConsumableArray(fiveSummaryTooltip), _toConsumableArray(fieldDefs(encodingWithoutContinuousAxis)))\n  };\n}\nexport function getTitle(continuousAxisChannelDef) {\n  var axis = continuousAxisChannelDef.axis,\n      title = continuousAxisChannelDef.title,\n      field = continuousAxisChannelDef.field;\n  return axis && axis.title !== undefined ? undefined : getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n  var scale = continuousAxisChannelDef.scale,\n      axis = continuousAxisChannelDef.axis;\n  return function (_ref2) {\n    var partName = _ref2.partName,\n        mark = _ref2.mark,\n        positionPrefix = _ref2.positionPrefix,\n        _ref2$endPositionPref = _ref2.endPositionPrefix,\n        endPositionPrefix = _ref2$endPositionPref === void 0 ? undefined : _ref2$endPositionPref,\n        _ref2$extraEncoding = _ref2.extraEncoding,\n        extraEncoding = _ref2$extraEncoding === void 0 ? {} : _ref2$extraEncoding;\n    var title = getTitle(continuousAxisChannelDef);\n    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n      mark: mark,\n      encoding: Object.assign(Object.assign(Object.assign(_defineProperty({}, continuousAxis, Object.assign(Object.assign(Object.assign({\n        field: positionPrefix + '_' + continuousAxisChannelDef.field,\n        type: continuousAxisChannelDef.type\n      }, title !== undefined ? {\n        title: title\n      } : {}), scale !== undefined ? {\n        scale: scale\n      } : {}), axis !== undefined ? {\n        axis: axis\n      } : {})), isString(endPositionPrefix) ? _defineProperty({}, continuousAxis + '2', {\n        field: endPositionPrefix + '_' + continuousAxisChannelDef.field,\n        type: continuousAxisChannelDef.type\n      }) : {}), sharedEncoding), extraEncoding)\n    });\n  };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n  var clip = markDef.clip,\n      color = markDef.color,\n      opacity = markDef.opacity;\n  var mark = markDef.type;\n\n  if (markDef[part] || markDef[part] === undefined && compositeMarkConfig[part]) {\n    return [Object.assign(Object.assign({}, partBaseSpec), {\n      mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip ? {\n        clip: clip\n      } : {}), color ? {\n        color: color\n      } : {}), opacity ? {\n        opacity: opacity\n      } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {\n        type: partBaseSpec.mark\n      }), {\n        style: \"\".concat(mark, \"-\").concat(part)\n      }), isBoolean(markDef[part]) ? {} : markDef[part])\n    })];\n  }\n\n  return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n  var encoding = spec.encoding;\n  var continuousAxis = orient === 'vertical' ? 'y' : 'x';\n  var continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n\n  var continuousAxisChannelDef2 = encoding[continuousAxis + '2'];\n  var continuousAxisChannelDefError = encoding[continuousAxis + 'Error'];\n  var continuousAxisChannelDefError2 = encoding[continuousAxis + 'Error2'];\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis: continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n  if (continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {\n    var aggregate = continuousAxisChannelDef.aggregate,\n        continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, [\"aggregate\"]);\n\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n\n    return continuousAxisWithoutAggregate;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient(spec, compositeMark) {\n  var mark = spec.mark,\n      encoding = spec.encoding;\n\n  if (isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // x is continuous\n    if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // both x and y are continuous\n      if (encoding.x.aggregate === undefined && encoding.y.aggregate === compositeMark) {\n        return 'vertical';\n      } else if (encoding.y.aggregate === undefined && encoding.x.aggregate === compositeMark) {\n        return 'horizontal';\n      } else if (encoding.x.aggregate === compositeMark && encoding.y.aggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isMarkDef(mark) && mark.orient) {\n          return mark.orient;\n        } // default orientation = vertical\n\n\n        return 'vertical';\n      }\n    } // x is continuous but y is not\n\n\n    return 'horizontal';\n  } else if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error('Need a valid continuous axis for ' + compositeMark + 's');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}