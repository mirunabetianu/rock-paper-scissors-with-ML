{"ast":null,"code":"import { isBoolean, isObject } from 'vega-util';\nimport { COLOR, COLUMN, FILL, FILLOPACITY, OPACITY, ROW, SHAPE, SIZE, STROKE, STROKEOPACITY, STROKEWIDTH } from './channel';\nimport { normalizeBin } from './channeldef';\nimport { keys, varName } from './util';\n/**\n * Create a key for the bin configuration. Not for prebinned bin.\n */\n\nexport function binToString(bin) {\n  if (isBoolean(bin)) {\n    bin = normalizeBin(bin, undefined);\n  }\n\n  return 'bin' + keys(bin).map(function (p) {\n    return isSelectionExtent(bin[p]) ? varName(\"_\".concat(p, \"_\").concat(Object.entries(bin[p]))) : varName(\"_\".concat(p, \"_\").concat(bin[p]));\n  }).join('');\n}\n/**\n * Vega-Lite should bin the data.\n */\n\nexport function isBinning(bin) {\n  return bin === true || isBinParams(bin) && !bin.binned;\n}\n/**\n * The data is already binned and so Vega-Lite should not bin it again.\n */\n\nexport function isBinned(bin) {\n  return bin === 'binned' || isBinParams(bin) && bin.binned === true;\n}\nexport function isBinParams(bin) {\n  return isObject(bin);\n}\nexport function isSelectionExtent(extent) {\n  var _a;\n\n  return (_a = extent) === null || _a === void 0 ? void 0 : _a['selection'];\n}\nexport function autoMaxBins(channel) {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY: // Facets and Size shouldn't have too many bins\n    // We choose 6 like shape to simplify the rule [falls through]\n\n    case SHAPE:\n      return 6;\n    // Vega's \"shape\" has 6 distinct values\n\n    default:\n      return 10;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}