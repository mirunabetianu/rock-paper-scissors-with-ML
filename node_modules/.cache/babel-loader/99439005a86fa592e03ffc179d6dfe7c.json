{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { contains } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { isConcatModel, isLayerModel, isRepeatModel } from '../model';\nexport function assembleProjections(model) {\n  if (isLayerModel(model) || isConcatModel(model) || isRepeatModel(model)) {\n    return assembleProjectionsForModelAndChildren(model);\n  } else {\n    return assembleProjectionForModel(model);\n  }\n}\nexport function assembleProjectionsForModelAndChildren(model) {\n  return model.children.reduce(function (projections, child) {\n    return projections.concat(child.assembleProjections());\n  }, assembleProjectionForModel(model));\n}\nexport function assembleProjectionForModel(model) {\n  var component = model.component.projection;\n\n  if (!component || component.merged) {\n    return [];\n  }\n\n  var projection = component.combine();\n\n  var name = projection.name,\n      rest = __rest(projection, [\"name\"]); // we need to extract name so that it is always present in the output and pass TS type validation\n\n\n  if (!component.data) {\n    // generate custom projection, no automatic fitting\n    return [Object.assign(Object.assign({\n      name: name\n    }, {\n      translate: {\n        signal: '[width / 2, height / 2]'\n      }\n    }), rest)];\n  } else {\n    // generate projection that uses extent fitting\n    var size = {\n      signal: \"[\".concat(component.size.map(function (ref) {\n        return ref.signal;\n      }).join(', '), \"]\")\n    };\n    var fit = component.data.reduce(function (sources, data) {\n      var source = isSignalRef(data) ? data.signal : \"data('\".concat(model.lookupDataSource(data), \"')\");\n\n      if (!contains(sources, source)) {\n        // build a unique list of sources\n        sources.push(source);\n      }\n\n      return sources;\n    }, []);\n\n    if (fit.length <= 0) {\n      throw new Error(\"Projection's fit didn't find any data sources\");\n    }\n\n    return [Object.assign({\n      name: name,\n      size: size,\n      fit: {\n        signal: fit.length > 1 ? \"[\".concat(fit.join(', '), \"]\") : fit[0]\n      }\n    }, rest)];\n  }\n}","map":null,"metadata":{},"sourceType":"module"}