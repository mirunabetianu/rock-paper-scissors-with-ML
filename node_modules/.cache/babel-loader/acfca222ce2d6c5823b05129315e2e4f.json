{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { __rest } from \"tslib\";\nimport { isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { getFirstDefined, keys, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { expression } from '../predicate';\nimport { isText } from '../../title';\n\nfunction assembleTitle(title, config) {\n  if (!title) {\n    return undefined;\n  }\n\n  if (!isText(title)) {\n    return title.map(function (fieldDef) {\n      return defaultTitle(fieldDef, config);\n    }).join(', ');\n  }\n\n  return title;\n}\n\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  var _a, _b, _c;\n\n  axis.encode = (_a = axis.encode, _a !== null && _a !== void 0 ? _a : {});\n  axis.encode[part] = (_b = axis.encode[part], _b !== null && _b !== void 0 ? _b : {});\n  axis.encode[part].update = (_c = axis.encode[part].update, _c !== null && _c !== void 0 ? _c : {}); // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n\n  axis.encode[part].update[vgProp] = vgRef;\n}\n\nexport function assembleAxis(axisCmpt, kind, config) {\n  var opt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    header: false\n  };\n\n  var _a, _b;\n\n  var _c = axisCmpt.combine(),\n      orient = _c.orient,\n      scale = _c.scale,\n      labelExpr = _c.labelExpr,\n      title = _c.title,\n      zindex = _c.zindex,\n      axis = __rest(_c, [\"orient\", \"scale\", \"labelExpr\", \"title\", \"zindex\"]); // Remove properties that are not valid for this kind of axis\n\n\n  keys(axis).forEach(function (prop) {\n    var propType = AXIS_PROPERTY_TYPE[prop];\n    var propValue = axis[prop];\n\n    if (propType && propType !== kind && propType !== 'both') {\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      var _CONDITIONAL_AXIS_PRO = CONDITIONAL_AXIS_PROP_INDEX[prop],\n          vgProp = _CONDITIONAL_AXIS_PRO.vgProp,\n          part = _CONDITIONAL_AXIS_PRO.part;\n      var condition = propValue.condition,\n          value = propValue.value;\n      var vgRef = [].concat(_toConsumableArray((isArray(condition) ? condition : [condition]).map(function (c) {\n        var v = c.value,\n            test = c.test;\n        return {\n          test: expression(null, test),\n          value: v\n        };\n      })), [{\n        value: value\n      }]);\n      setAxisEncode(axis, part, vgProp, vgRef);\n      delete axis[prop];\n    }\n  });\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      var grid = axis.encode.grid;\n      axis.encode = Object.assign({}, grid ? {\n        grid: grid\n      } : {});\n\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    return Object.assign(Object.assign({\n      scale: scale,\n      orient: orient\n    }, axis), {\n      domain: false,\n      labels: false,\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n\n    });\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      var expr = labelExpr;\n\n      if (((_b = (_a = axis.encode) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = AXIS_PARTS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var part = _step.value;\n\n          if (!axisCmpt.hasAxisPart(part)) {\n            delete axis.encode[part];\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    var titleString = assembleTitle(title, config);\n    return Object.assign(Object.assign(Object.assign({\n      scale: scale,\n      orient: orient,\n      grid: false\n    }, titleString ? {\n      title: titleString\n    } : {}), axis), {\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n\n    });\n  }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\n\nexport function assembleAxisSignals(model) {\n  var axes = model.component.axes;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = POSITION_SCALE_CHANNELS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var channel = _step2.value;\n\n      if (axes[channel]) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = axes[channel][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var axis = _step3.value;\n\n            if (!axis.get('gridScale')) {\n              // If there is x-axis but no y-scale for gridScale, need to set height/weight so x-axis can draw the grid with the right height. Same for y-axis and width.\n              var sizeType = channel === 'x' ? 'height' : 'width';\n              return [{\n                name: sizeType,\n                update: model.getSizeSignalRef(sizeType).signal\n              }];\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return [];\n}\nexport function assembleAxes(axisComponents, config) {\n  var _axisComponents$x = axisComponents.x,\n      x = _axisComponents$x === void 0 ? [] : _axisComponents$x,\n      _axisComponents$y = axisComponents.y,\n      y = _axisComponents$y === void 0 ? [] : _axisComponents$y;\n  return [].concat(_toConsumableArray(x.map(function (a) {\n    return assembleAxis(a, 'grid', config);\n  })), _toConsumableArray(y.map(function (a) {\n    return assembleAxis(a, 'grid', config);\n  })), _toConsumableArray(x.map(function (a) {\n    return assembleAxis(a, 'main', config);\n  })), _toConsumableArray(y.map(function (a) {\n    return assembleAxis(a, 'main', config);\n  }))).filter(function (a) {\n    return a;\n  }); // filter undefined\n}","map":null,"metadata":{},"sourceType":"module"}