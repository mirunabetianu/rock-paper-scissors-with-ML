{"ast":null,"code":"import { isString, toSet } from 'vega-util';\nimport { contains, keys } from './util';\nvar AGGREGATE_OP_INDEX = {\n  argmax: 1,\n  argmin: 1,\n  average: 1,\n  count: 1,\n  distinct: 1,\n  max: 1,\n  mean: 1,\n  median: 1,\n  min: 1,\n  missing: 1,\n  q1: 1,\n  q3: 1,\n  ci0: 1,\n  ci1: 1,\n  stderr: 1,\n  stdev: 1,\n  stdevp: 1,\n  sum: 1,\n  valid: 1,\n  values: 1,\n  variance: 1,\n  variancep: 1\n};\nexport var MULTIDOMAIN_SORT_OP_INDEX = {\n  count: 1,\n  min: 1,\n  max: 1\n};\nexport function isArgminDef(a) {\n  return !!a && !!a['argmin'];\n}\nexport function isArgmaxDef(a) {\n  return !!a && !!a['argmax'];\n}\nexport var AGGREGATE_OPS = keys(AGGREGATE_OP_INDEX);\nexport function isAggregateOp(a) {\n  return isString(a) && !!AGGREGATE_OP_INDEX[a];\n}\nexport var COUNTING_OPS = ['count', 'valid', 'missing', 'distinct'];\nexport function isCountingAggregateOp(aggregate) {\n  return isString(aggregate) && contains(COUNTING_OPS, aggregate);\n}\nexport function isMinMaxOp(aggregate) {\n  return isString(aggregate) && contains(['min', 'max'], aggregate);\n}\n/** Additive-based aggregation operations. These can be applied to stack. */\n\nexport var SUM_OPS = ['count', 'sum', 'distinct', 'valid', 'missing'];\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\n\nexport var SHARED_DOMAIN_OPS = ['mean', 'average', 'median', 'q1', 'q3', 'min', 'max'];\nexport var SHARED_DOMAIN_OP_INDEX = toSet(SHARED_DOMAIN_OPS);","map":null,"metadata":{},"sourceType":"module"}