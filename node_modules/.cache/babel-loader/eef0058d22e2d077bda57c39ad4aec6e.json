{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { __rest } from \"tslib\";\nimport { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isUnitSpec } from '../spec/unit';\nimport { keys, omit } from '../util';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { RangeStepNormalizer } from './rangestep';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport var CoreNormalizer =\n/*#__PURE__*/\nfunction (_SpecMapper) {\n  _inherits(CoreNormalizer, _SpecMapper);\n\n  function CoreNormalizer() {\n    var _this;\n\n    _classCallCheck(this, CoreNormalizer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CoreNormalizer).apply(this, arguments));\n    _this.nonFacetUnitNormalizers = [boxPlotNormalizer, errorBarNormalizer, errorBandNormalizer, new PathOverlayNormalizer(), new RuleForRangedLineNormalizer(), new RangeStepNormalizer()];\n    return _this;\n  }\n\n  _createClass(CoreNormalizer, [{\n    key: \"map\",\n    value: function map(spec, params) {\n      // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n      if (isUnitSpec(spec)) {\n        var hasRow = channelHasField(spec.encoding, ROW);\n        var hasColumn = channelHasField(spec.encoding, COLUMN);\n        var hasFacet = channelHasField(spec.encoding, FACET);\n\n        if (hasRow || hasColumn || hasFacet) {\n          return this.mapFacetedUnit(spec, params);\n        }\n      }\n\n      return _get(_getPrototypeOf(CoreNormalizer.prototype), \"map\", this).call(this, spec, params);\n    } // This is for normalizing non-facet unit\n\n  }, {\n    key: \"mapUnit\",\n    value: function mapUnit(spec, params) {\n      var parentEncoding = params.parentEncoding,\n          parentProjection = params.parentProjection;\n\n      if (parentEncoding || parentProjection) {\n        return this.mapUnitWithParentEncodingOrProjection(spec, params);\n      }\n\n      var normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.nonFacetUnitNormalizers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var unitNormalizer = _step.value;\n\n          if (unitNormalizer.hasMatchingType(spec, params.config)) {\n            return unitNormalizer.run(spec, params, normalizeLayerOrUnit);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return spec;\n    }\n  }, {\n    key: \"mapRepeat\",\n    value: function mapRepeat(spec, params) {\n      var _spec = spec,\n          repeat = _spec.repeat;\n\n      if (!isArray(repeat) && spec.columns) {\n        // is repeat with row/column\n        spec = omit(spec, ['columns']);\n        log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n      }\n\n      return Object.assign(Object.assign({}, spec), {\n        spec: this.map(spec.spec, params)\n      });\n    }\n  }, {\n    key: \"mapFacet\",\n    value: function mapFacet(spec, params) {\n      var _spec2 = spec,\n          facet = _spec2.facet;\n\n      if (isFacetMapping(facet) && spec.columns) {\n        // is facet with row/column\n        spec = omit(spec, ['columns']);\n        log.warn(log.message.columnsNotSupportByRowCol('facet'));\n      }\n\n      return _get(_getPrototypeOf(CoreNormalizer.prototype), \"mapFacet\", this).call(this, spec, params);\n    }\n  }, {\n    key: \"mapUnitWithParentEncodingOrProjection\",\n    value: function mapUnitWithParentEncodingOrProjection(spec, params) {\n      var encoding = spec.encoding,\n          projection = spec.projection;\n      var parentEncoding = params.parentEncoding,\n          parentProjection = params.parentProjection,\n          config = params.config;\n      var mergedProjection = mergeProjection({\n        parentProjection: parentProjection,\n        projection: projection\n      });\n      var mergedEncoding = mergeEncoding({\n        parentEncoding: parentEncoding,\n        encoding: encoding\n      });\n      return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? {\n        projection: mergedProjection\n      } : {}), mergedEncoding ? {\n        encoding: mergedEncoding\n      } : {}), {\n        config: config\n      });\n    }\n  }, {\n    key: \"mapFacetedUnit\",\n    value: function mapFacetedUnit(spec, params) {\n      // New encoding in the inside spec should not contain row / column\n      // as row/column should be moved to facet\n      var _a = spec.encoding,\n          row = _a.row,\n          column = _a.column,\n          facet = _a.facet,\n          encoding = __rest(_a, [\"row\", \"column\", \"facet\"]); // Mark and encoding should be moved into the inner spec\n\n\n      var mark = spec.mark,\n          width = spec.width,\n          projection = spec.projection,\n          height = spec.height,\n          selection = spec.selection,\n          _ = spec.encoding,\n          outerSpec = __rest(spec, [\"mark\", \"width\", \"projection\", \"height\", \"selection\", \"encoding\"]);\n\n      var _this$getFacetMapping = this.getFacetMappingAndLayout({\n        row: row,\n        column: column,\n        facet: facet\n      }),\n          facetMapping = _this$getFacetMapping.facetMapping,\n          layout = _this$getFacetMapping.layout;\n\n      return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {\n        // row / column has higher precedence than facet\n        facet: facetMapping,\n        spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, projection ? {\n          projection: projection\n        } : {}), {\n          mark: mark\n        }), width ? {\n          width: width\n        } : {}), height ? {\n          height: height\n        } : {}), {\n          encoding: encoding\n        }), selection ? {\n          selection: selection\n        } : {})\n      }), params);\n    }\n  }, {\n    key: \"getFacetMappingAndLayout\",\n    value: function getFacetMappingAndLayout(facets) {\n      var _a;\n\n      var row = facets.row,\n          column = facets.column,\n          facet = facets.facet;\n\n      if (row || column) {\n        if (facet) {\n          log.warn(log.message.facetChannelDropped([].concat(_toConsumableArray(row ? [ROW] : []), _toConsumableArray(column ? [COLUMN] : []))));\n        }\n\n        var facetMapping = {};\n        var layout = {};\n\n        for (var _i = 0, _arr = [ROW, COLUMN]; _i < _arr.length; _i++) {\n          var channel = _arr[_i];\n          var def = facets[channel];\n\n          if (def) {\n            var align = def.align,\n                center = def.center,\n                spacing = def.spacing,\n                columns = def.columns,\n                defWithoutLayout = __rest(def, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n            facetMapping[channel] = defWithoutLayout;\n\n            for (var _i2 = 0, _arr2 = ['align', 'center', 'spacing']; _i2 < _arr2.length; _i2++) {\n              var prop = _arr2[_i2];\n\n              if (def[prop] !== undefined) {\n                layout[prop] = (_a = layout[prop], _a !== null && _a !== void 0 ? _a : {});\n                layout[prop][channel] = def[prop];\n              }\n            }\n          }\n        }\n\n        return {\n          facetMapping: facetMapping,\n          layout: layout\n        };\n      } else {\n        var _align = facet.align,\n            _center = facet.center,\n            _spacing = facet.spacing,\n            _columns = facet.columns,\n            _facetMapping = __rest(facet, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n        return {\n          facetMapping: _facetMapping,\n          layout: Object.assign(Object.assign(Object.assign(Object.assign({}, _align ? {\n            align: _align\n          } : {}), _center ? {\n            center: _center\n          } : {}), _spacing ? {\n            spacing: _spacing\n          } : {}), _columns ? {\n            columns: _columns\n          } : {})\n        };\n      }\n    }\n  }, {\n    key: \"mapLayer\",\n    value: function mapLayer(spec, _a) {\n      // Special handling for extended layer spec\n      var parentEncoding = _a.parentEncoding,\n          parentProjection = _a.parentProjection,\n          otherParams = __rest(_a, [\"parentEncoding\", \"parentProjection\"]);\n\n      var encoding = spec.encoding,\n          projection = spec.projection,\n          rest = __rest(spec, [\"encoding\", \"projection\"]);\n\n      var params = Object.assign(Object.assign({}, otherParams), {\n        parentEncoding: mergeEncoding({\n          parentEncoding: parentEncoding,\n          encoding: encoding\n        }),\n        parentProjection: mergeProjection({\n          parentProjection: parentProjection,\n          projection: projection\n        })\n      });\n      return _get(_getPrototypeOf(CoreNormalizer.prototype), \"mapLayer\", this).call(this, rest, params);\n    }\n  }]);\n\n  return CoreNormalizer;\n}(SpecMapper);\n\nfunction mergeEncoding(opt) {\n  var parentEncoding = opt.parentEncoding,\n      encoding = opt.encoding;\n\n  if (parentEncoding && encoding) {\n    var overriden = keys(parentEncoding).reduce(function (o, key) {\n      if (encoding[key]) {\n        o.push(key);\n      }\n\n      return o;\n    }, []);\n\n    if (overriden.length > 0) {\n      log.warn(log.message.encodingOverridden(overriden));\n    }\n  }\n\n  var merged = Object.assign(Object.assign({}, parentEncoding !== null && parentEncoding !== void 0 ? parentEncoding : {}), encoding !== null && encoding !== void 0 ? encoding : {});\n  return keys(merged).length > 0 ? merged : undefined;\n}\n\nfunction mergeProjection(opt) {\n  var parentProjection = opt.parentProjection,\n      projection = opt.projection;\n\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({\n      parentProjection: parentProjection,\n      projection: projection\n    }));\n  }\n\n  return projection !== null && projection !== void 0 ? projection : parentProjection;\n}","map":null,"metadata":{},"sourceType":"module"}