{"ast":null,"code":"import _toConsumableArray from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { hasDiscreteDomain } from '../../scale';\nimport { getFirstDefined } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { isFacetModel } from '../model';\nimport { getViewConfigContinuousSize } from '../../config';\nexport function assembleLayoutSignals(model) {\n  return [].concat(_toConsumableArray(sizeSignals(model, 'width')), _toConsumableArray(sizeSignals(model, 'height')));\n}\nexport function sizeSignals(model, sizeType) {\n  var channel = sizeType === 'width' ? 'x' : 'y';\n  var size = model.component.layoutSize.get(sizeType);\n\n  if (!size || size === 'merged') {\n    return [];\n  } // Read size signal name from name map, just in case it is the top-level size signal that got renamed.\n\n\n  var name = model.getSizeSignalRef(sizeType).signal;\n\n  if (size === 'step') {\n    var scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      var type = scaleComponent.get('type');\n      var range = scaleComponent.get('range');\n\n      if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n        var scaleName = model.scaleName(channel);\n\n        if (isFacetModel(model.parent)) {\n          // If parent is facet and this is an independent scale, return only signal signal\n          // as the width/height will be calculated using the cardinality from\n          // facet's aggregate rather than reading from scale domain\n          var parentResolve = model.parent.component.resolve;\n\n          if (parentResolve.scale[channel] === 'independent') {\n            return [stepSignal(scaleName, range)];\n          }\n        }\n\n        return [stepSignal(scaleName, range), {\n          name: name,\n          update: sizeExpr(scaleName, scaleComponent, \"domain('\".concat(scaleName, \"').length\"))\n        }];\n      }\n    }\n    /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n\n\n    throw new Error('layout size is step although width/height is not step.');\n  } else if (size == 'container') {\n    var isWidth = name.endsWith('width');\n    var expr = isWidth ? 'containerSize()[0]' : 'containerSize()[1]';\n    var defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? 'width' : 'height');\n    var safeExpr = \"isFinite(\".concat(expr, \") ? \").concat(expr, \" : \").concat(defaultValue);\n    return [{\n      name: name,\n      init: safeExpr,\n      on: [{\n        update: safeExpr,\n        events: 'window:resize'\n      }]\n    }];\n  } else {\n    return [{\n      name: name,\n      value: size\n    }];\n  }\n}\n\nfunction stepSignal(scaleName, range) {\n  return {\n    name: scaleName + '_step',\n    value: range.step\n  };\n}\n\nexport function sizeExpr(scaleName, scaleComponent, cardinality) {\n  var type = scaleComponent.get('type');\n  var padding = scaleComponent.get('padding');\n  var paddingOuter = getFirstDefined(scaleComponent.get('paddingOuter'), padding);\n  var paddingInner = scaleComponent.get('paddingInner');\n  paddingInner = type === 'band' ? // only band has real paddingInner\n  paddingInner !== undefined ? paddingInner : padding : // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n  // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n  1;\n  return \"bandspace(\".concat(cardinality, \", \").concat(paddingInner, \", \").concat(paddingOuter, \") * \").concat(scaleName, \"_step\");\n}","map":null,"metadata":{},"sourceType":"module"}