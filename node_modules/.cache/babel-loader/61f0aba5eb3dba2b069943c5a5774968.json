{"ast":null,"code":"import _defineProperty from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/mirunabetianu/WebstormProjects/rps/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { getSecondaryRangeChannel } from '../../channel';\nimport { hasBand, vgField } from '../../channeldef';\nimport { getTimeUnitParts } from '../../timeunit';\nimport { duplicate, hash as _hash, keys, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\nexport var TimeUnitNode =\n/*#__PURE__*/\nfunction (_DataFlowNode) {\n  _inherits(TimeUnitNode, _DataFlowNode);\n\n  function TimeUnitNode(parent, formula) {\n    var _this;\n\n    _classCallCheck(this, TimeUnitNode);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TimeUnitNode).call(this, parent));\n    _this.formula = formula;\n    return _this;\n  }\n\n  _createClass(TimeUnitNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new TimeUnitNode(null, duplicate(this.formula));\n    }\n  }, {\n    key: \"merge\",\n\n    /**\n     * Merge together TimeUnitNodes assigning the children of `other` to `this`\n     * and removing `other`.\n     */\n    value: function merge(other) {\n      this.formula = Object.assign({}, this.formula); // if the same hash happen twice, merge \"band\"\n\n      for (var key in other.formula) {\n        if (!this.formula[key] || other.formula[key].band) {\n          // copy if it's not a duplicate or if we need to include copy band over\n          this.formula[key] = other.formula[key];\n        }\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = other.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n          other.removeChild(child);\n          child.parent = this;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      other.remove();\n    }\n  }, {\n    key: \"producedFields\",\n    value: function producedFields() {\n      return new Set(vals(this.formula).map(function (f) {\n        return f.as;\n      }));\n    }\n  }, {\n    key: \"dependentFields\",\n    value: function dependentFields() {\n      return new Set(vals(this.formula).map(function (f) {\n        return f.field;\n      }));\n    }\n  }, {\n    key: \"hash\",\n    value: function hash() {\n      return \"TimeUnit \".concat(_hash(this.formula));\n    }\n  }, {\n    key: \"assemble\",\n    value: function assemble() {\n      var transforms = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = vals(this.formula)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var f = _step2.value;\n          var timeUnit = f.timeUnit,\n              field = f.field,\n              as = f.as;\n          transforms.push({\n            field: field,\n            type: 'timeunit',\n            units: getTimeUnitParts(timeUnit),\n            as: [as, \"\".concat(as, \"_end\")]\n          });\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return transforms;\n    }\n  }], [{\n    key: \"makeFromEncoding\",\n    value: function makeFromEncoding(parent, model) {\n      var formula = model.reduceFieldDef(function (timeUnitComponent, fieldDef, channel) {\n        var timeUnit = fieldDef.timeUnit,\n            field = fieldDef.field;\n        var channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n        var band = isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.markDef, model.config);\n\n        if (timeUnit) {\n          var as = vgField(fieldDef, {\n            forAs: true\n          });\n          timeUnitComponent[_hash({\n            as: as,\n            timeUnit: timeUnit,\n            field: field\n          })] = Object.assign({\n            as: as,\n            timeUnit: timeUnit,\n            field: field\n          }, band ? {\n            band: true\n          } : {});\n        }\n\n        return timeUnitComponent;\n      }, {});\n\n      if (keys(formula).length === 0) {\n        return null;\n      }\n\n      return new TimeUnitNode(parent, formula);\n    }\n  }, {\n    key: \"makeFromTransform\",\n    value: function makeFromTransform(parent, t) {\n      var component = Object.assign({}, t);\n      return new TimeUnitNode(parent, _defineProperty({}, _hash(component), component));\n    }\n  }]);\n\n  return TimeUnitNode;\n}(DataFlowNode);","map":null,"metadata":{},"sourceType":"module"}